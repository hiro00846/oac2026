"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@videojs";
exports.ids = ["vendor-chunks/@videojs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/byte-helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ENDIANNESS: () => (/* binding */ ENDIANNESS),\n/* harmony export */   IS_BIG_ENDIAN: () => (/* binding */ IS_BIG_ENDIAN),\n/* harmony export */   IS_LITTLE_ENDIAN: () => (/* binding */ IS_LITTLE_ENDIAN),\n/* harmony export */   bytesMatch: () => (/* binding */ bytesMatch),\n/* harmony export */   bytesToNumber: () => (/* binding */ bytesToNumber),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   concatTypedArrays: () => (/* binding */ concatTypedArrays),\n/* harmony export */   countBits: () => (/* binding */ countBits),\n/* harmony export */   countBytes: () => (/* binding */ countBytes),\n/* harmony export */   isArrayBufferView: () => (/* binding */ isArrayBufferView),\n/* harmony export */   isTypedArray: () => (/* binding */ isTypedArray),\n/* harmony export */   numberToBytes: () => (/* binding */ numberToBytes),\n/* harmony export */   padStart: () => (/* binding */ padStart),\n/* harmony export */   reverseBytes: () => (/* binding */ reverseBytes),\n/* harmony export */   sliceBytes: () => (/* binding */ sliceBytes),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   toBinaryString: () => (/* binding */ toBinaryString),\n/* harmony export */   toHexString: () => (/* binding */ toHexString),\n/* harmony export */   toUint8: () => (/* binding */ toUint8)\n/* harmony export */ });\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__);\n // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\n\nvar repeat = function repeat(str, len) {\n  var acc = '';\n\n  while (len--) {\n    acc += str;\n  }\n\n  return acc;\n}; // count the number of bits it would take to represent a number\n// we used to do this with log2 but BigInt does not support builtin math\n// Math.ceil(log2(x));\n\n\nvar countBits = function countBits(x) {\n  return x.toString(2).length;\n}; // count the number of whole bytes it would take to represent a number\n\nvar countBytes = function countBytes(x) {\n  return Math.ceil(countBits(x) / 8);\n};\nvar padStart = function padStart(b, len, str) {\n  if (str === void 0) {\n    str = ' ';\n  }\n\n  return (repeat(str, len) + b.toString()).slice(-len);\n};\nvar isArrayBufferView = function isArrayBufferView(obj) {\n  if (ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(obj);\n  }\n\n  return obj && obj.buffer instanceof ArrayBuffer;\n};\nvar isTypedArray = function isTypedArray(obj) {\n  return isArrayBufferView(obj);\n};\nvar toUint8 = function toUint8(bytes) {\n  if (bytes instanceof Uint8Array) {\n    return bytes;\n  }\n\n  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n    // any non-number or NaN leads to empty uint8array\n    // eslint-disable-next-line\n    if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n      bytes = 0;\n    } else {\n      bytes = [bytes];\n    }\n  }\n\n  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n};\nvar toHexString = function toHexString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(16), 2, '0');\n  }\n\n  return str;\n};\nvar toBinaryString = function toBinaryString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(2), 8, '0');\n  }\n\n  return str;\n};\nvar BigInt = (global_window__WEBPACK_IMPORTED_MODULE_0___default().BigInt) || Number;\nvar BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\nvar ENDIANNESS = function () {\n  var a = new Uint16Array([0xFFCC]);\n  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n\n  if (b[0] === 0xFF) {\n    return 'big';\n  }\n\n  if (b[0] === 0xCC) {\n    return 'little';\n  }\n\n  return 'unknown';\n}();\nvar IS_BIG_ENDIAN = ENDIANNESS === 'big';\nvar IS_LITTLE_ENDIAN = ENDIANNESS === 'little';\nvar bytesToNumber = function bytesToNumber(bytes, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$signed = _ref.signed,\n      signed = _ref$signed === void 0 ? false : _ref$signed,\n      _ref$le = _ref.le,\n      le = _ref$le === void 0 ? false : _ref$le;\n\n  bytes = toUint8(bytes);\n  var fn = le ? 'reduce' : 'reduceRight';\n  var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n  var number = obj.call(bytes, function (total, byte, i) {\n    var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n    return total + BigInt(byte) * BYTE_TABLE[exponent];\n  }, BigInt(0));\n\n  if (signed) {\n    var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n    number = BigInt(number);\n\n    if (number > max) {\n      number -= max;\n      number -= max;\n      number -= BigInt(2);\n    }\n  }\n\n  return Number(number);\n};\nvar numberToBytes = function numberToBytes(number, _temp2) {\n  var _ref2 = _temp2 === void 0 ? {} : _temp2,\n      _ref2$le = _ref2.le,\n      le = _ref2$le === void 0 ? false : _ref2$le;\n\n  // eslint-disable-next-line\n  if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n    number = 0;\n  }\n\n  number = BigInt(number);\n  var byteCount = countBytes(number);\n  var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n\n  for (var i = 0; i < byteCount; i++) {\n    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n\n    if (number < 0) {\n      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n      bytes[byteIndex] -= i === 0 ? 1 : 2;\n    }\n  }\n\n  return bytes;\n};\nvar bytesToString = function bytesToString(bytes) {\n  if (!bytes) {\n    return '';\n  } // TODO: should toUint8 handle cases where we only have 8 bytes\n  // but report more since this is a Uint16+ Array?\n\n\n  bytes = Array.prototype.slice.call(bytes);\n  var string = String.fromCharCode.apply(null, toUint8(bytes));\n\n  try {\n    return decodeURIComponent(escape(string));\n  } catch (e) {// if decodeURIComponent/escape fails, we are dealing with partial\n    // or full non string data. Just return the potentially garbled string.\n  }\n\n  return string;\n};\nvar stringToBytes = function stringToBytes(string, stringIsBytes) {\n  if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n    string = string.toString();\n  }\n\n  if (typeof string !== 'string') {\n    return new Uint8Array();\n  } // If the string already is bytes, we don't have to do this\n  // otherwise we do this so that we split multi length characters\n  // into individual bytes\n\n\n  if (!stringIsBytes) {\n    string = unescape(encodeURIComponent(string));\n  }\n\n  var view = new Uint8Array(string.length);\n\n  for (var i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n\n  return view;\n};\nvar concatTypedArrays = function concatTypedArrays() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  buffers = buffers.filter(function (b) {\n    return b && (b.byteLength || b.length) && typeof b !== 'string';\n  });\n\n  if (buffers.length <= 1) {\n    // for 0 length we will return empty uint8\n    // for 1 length we return the first uint8\n    return toUint8(buffers[0]);\n  }\n\n  var totalLen = buffers.reduce(function (total, buf, i) {\n    return total + (buf.byteLength || buf.length);\n  }, 0);\n  var tempBuffer = new Uint8Array(totalLen);\n  var offset = 0;\n  buffers.forEach(function (buf) {\n    buf = toUint8(buf);\n    tempBuffer.set(buf, offset);\n    offset += buf.byteLength;\n  });\n  return tempBuffer;\n};\n/**\n * Check if the bytes \"b\" are contained within bytes \"a\".\n *\n * @param {Uint8Array|Array} a\n *        Bytes to check in\n *\n * @param {Uint8Array|Array} b\n *        Bytes to check for\n *\n * @param {Object} options\n *        options\n *\n * @param {Array|Uint8Array} [offset=0]\n *        offset to use when looking at bytes in a\n *\n * @param {Array|Uint8Array} [mask=[]]\n *        mask to use on bytes before comparison.\n *\n * @return {boolean}\n *         If all bytes in b are inside of a, taking into account\n *         bit masks.\n */\n\nvar bytesMatch = function bytesMatch(a, b, _temp3) {\n  var _ref3 = _temp3 === void 0 ? {} : _temp3,\n      _ref3$offset = _ref3.offset,\n      offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n      _ref3$mask = _ref3.mask,\n      mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n\n  a = toUint8(a);\n  b = toUint8(b); // ie 11 does not support uint8 every\n\n  var fn = b.every ? b.every : Array.prototype.every;\n  return b.length && a.length - offset >= b.length && // ie 11 doesn't support every on uin8\n  fn.call(b, function (bByte, i) {\n    var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n    return bByte === aByte;\n  });\n};\nvar sliceBytes = function sliceBytes(src, start, end) {\n  if (Uint8Array.prototype.slice) {\n    return Uint8Array.prototype.slice.call(src, start, end);\n  }\n\n  return new Uint8Array(Array.prototype.slice.call(src, start, end));\n};\nvar reverseBytes = function reverseBytes(src) {\n  if (src.reverse) {\n    return src.reverse();\n  }\n\n  return Array.prototype.reverse.call(src);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2J5dGUtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUMsQ0FBQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR087QUFDUDtBQUNBLEdBQUc7O0FBRUk7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2REFBYTtBQUMxQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNNO0FBQ0E7QUFDQTtBQUNQLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1AscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLFdBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1AseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVPO0FBQ1AscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvZXMvYnl0ZS1oZWxwZXJzLmpzPzYzMjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JzsgLy8gY29uc3QgbG9nMiA9IE1hdGgubG9nMiA/IE1hdGgubG9nMiA6ICh4KSA9PiAoTWF0aC5sb2coeCkgLyBNYXRoLmxvZygyKSk7XG5cbnZhciByZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQoc3RyLCBsZW4pIHtcbiAgdmFyIGFjYyA9ICcnO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGFjYyArPSBzdHI7XG4gIH1cblxuICByZXR1cm4gYWNjO1xufTsgLy8gY291bnQgdGhlIG51bWJlciBvZiBiaXRzIGl0IHdvdWxkIHRha2UgdG8gcmVwcmVzZW50IGEgbnVtYmVyXG4vLyB3ZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBsb2cyIGJ1dCBCaWdJbnQgZG9lcyBub3Qgc3VwcG9ydCBidWlsdGluIG1hdGhcbi8vIE1hdGguY2VpbChsb2cyKHgpKTtcblxuXG5leHBvcnQgdmFyIGNvdW50Qml0cyA9IGZ1bmN0aW9uIGNvdW50Qml0cyh4KSB7XG4gIHJldHVybiB4LnRvU3RyaW5nKDIpLmxlbmd0aDtcbn07IC8vIGNvdW50IHRoZSBudW1iZXIgb2Ygd2hvbGUgYnl0ZXMgaXQgd291bGQgdGFrZSB0byByZXByZXNlbnQgYSBudW1iZXJcblxuZXhwb3J0IHZhciBjb3VudEJ5dGVzID0gZnVuY3Rpb24gY291bnRCeXRlcyh4KSB7XG4gIHJldHVybiBNYXRoLmNlaWwoY291bnRCaXRzKHgpIC8gOCk7XG59O1xuZXhwb3J0IHZhciBwYWRTdGFydCA9IGZ1bmN0aW9uIHBhZFN0YXJ0KGIsIGxlbiwgc3RyKSB7XG4gIGlmIChzdHIgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9ICcgJztcbiAgfVxuXG4gIHJldHVybiAocmVwZWF0KHN0ciwgbGVuKSArIGIudG9TdHJpbmcoKSkuc2xpY2UoLWxlbik7XG59O1xuZXhwb3J0IHZhciBpc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KG9iaikge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopO1xuICB9XG5cbiAgcmV0dXJuIG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuZXhwb3J0IHZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2JqKSB7XG4gIHJldHVybiBpc0FycmF5QnVmZmVyVmlldyhvYmopO1xufTtcbmV4cG9ydCB2YXIgdG9VaW50OCA9IGZ1bmN0aW9uIHRvVWludDgoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShieXRlcykgJiYgIWlzVHlwZWRBcnJheShieXRlcykgJiYgIShieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIC8vIGFueSBub24tbnVtYmVyIG9yIE5hTiBsZWFkcyB0byBlbXB0eSB1aW50OGFycmF5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaWYgKHR5cGVvZiBieXRlcyAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGJ5dGVzID09PSAnbnVtYmVyJyAmJiBieXRlcyAhPT0gYnl0ZXMpIHtcbiAgICAgIGJ5dGVzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMgPSBbYnl0ZXNdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyAmJiBieXRlcy5idWZmZXIgfHwgYnl0ZXMsIGJ5dGVzICYmIGJ5dGVzLmJ5dGVPZmZzZXQgfHwgMCwgYnl0ZXMgJiYgYnl0ZXMuYnl0ZUxlbmd0aCB8fCAwKTtcbn07XG5leHBvcnQgdmFyIHRvSGV4U3RyaW5nID0gZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gcGFkU3RhcnQoYnl0ZXNbaV0udG9TdHJpbmcoMTYpLCAyLCAnMCcpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5leHBvcnQgdmFyIHRvQmluYXJ5U3RyaW5nID0gZnVuY3Rpb24gdG9CaW5hcnlTdHJpbmcoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gcGFkU3RhcnQoYnl0ZXNbaV0udG9TdHJpbmcoMiksIDgsICcwJyk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcbnZhciBCaWdJbnQgPSB3aW5kb3cuQmlnSW50IHx8IE51bWJlcjtcbnZhciBCWVRFX1RBQkxFID0gW0JpZ0ludCgnMHgxJyksIEJpZ0ludCgnMHgxMDAnKSwgQmlnSW50KCcweDEwMDAwJyksIEJpZ0ludCgnMHgxMDAwMDAwJyksIEJpZ0ludCgnMHgxMDAwMDAwMDAnKSwgQmlnSW50KCcweDEwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwJyldO1xuZXhwb3J0IHZhciBFTkRJQU5ORVNTID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYSA9IG5ldyBVaW50MTZBcnJheShbMHhGRkNDXSk7XG4gIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcblxuICBpZiAoYlswXSA9PT0gMHhGRikge1xuICAgIHJldHVybiAnYmlnJztcbiAgfVxuXG4gIGlmIChiWzBdID09PSAweENDKSB7XG4gICAgcmV0dXJuICdsaXR0bGUnO1xuICB9XG5cbiAgcmV0dXJuICd1bmtub3duJztcbn0oKTtcbmV4cG9ydCB2YXIgSVNfQklHX0VORElBTiA9IEVORElBTk5FU1MgPT09ICdiaWcnO1xuZXhwb3J0IHZhciBJU19MSVRUTEVfRU5ESUFOID0gRU5ESUFOTkVTUyA9PT0gJ2xpdHRsZSc7XG5leHBvcnQgdmFyIGJ5dGVzVG9OdW1iZXIgPSBmdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzLCBfdGVtcCkge1xuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgX3JlZiRzaWduZWQgPSBfcmVmLnNpZ25lZCxcbiAgICAgIHNpZ25lZCA9IF9yZWYkc2lnbmVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkc2lnbmVkLFxuICAgICAgX3JlZiRsZSA9IF9yZWYubGUsXG4gICAgICBsZSA9IF9yZWYkbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRsZTtcblxuICBieXRlcyA9IHRvVWludDgoYnl0ZXMpO1xuICB2YXIgZm4gPSBsZSA/ICdyZWR1Y2UnIDogJ3JlZHVjZVJpZ2h0JztcbiAgdmFyIG9iaiA9IGJ5dGVzW2ZuXSA/IGJ5dGVzW2ZuXSA6IEFycmF5LnByb3RvdHlwZVtmbl07XG4gIHZhciBudW1iZXIgPSBvYmouY2FsbChieXRlcywgZnVuY3Rpb24gKHRvdGFsLCBieXRlLCBpKSB7XG4gICAgdmFyIGV4cG9uZW50ID0gbGUgPyBpIDogTWF0aC5hYnMoaSArIDEgLSBieXRlcy5sZW5ndGgpO1xuICAgIHJldHVybiB0b3RhbCArIEJpZ0ludChieXRlKSAqIEJZVEVfVEFCTEVbZXhwb25lbnRdO1xuICB9LCBCaWdJbnQoMCkpO1xuXG4gIGlmIChzaWduZWQpIHtcbiAgICB2YXIgbWF4ID0gQllURV9UQUJMRVtieXRlcy5sZW5ndGhdIC8gQmlnSW50KDIpIC0gQmlnSW50KDEpO1xuICAgIG51bWJlciA9IEJpZ0ludChudW1iZXIpO1xuXG4gICAgaWYgKG51bWJlciA+IG1heCkge1xuICAgICAgbnVtYmVyIC09IG1heDtcbiAgICAgIG51bWJlciAtPSBtYXg7XG4gICAgICBudW1iZXIgLT0gQmlnSW50KDIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOdW1iZXIobnVtYmVyKTtcbn07XG5leHBvcnQgdmFyIG51bWJlclRvQnl0ZXMgPSBmdW5jdGlvbiBudW1iZXJUb0J5dGVzKG51bWJlciwgX3RlbXAyKSB7XG4gIHZhciBfcmVmMiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICBfcmVmMiRsZSA9IF9yZWYyLmxlLFxuICAgICAgbGUgPSBfcmVmMiRsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRsZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdiaWdpbnQnICYmIHR5cGVvZiBudW1iZXIgIT09ICdudW1iZXInIHx8IHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInICYmIG51bWJlciAhPT0gbnVtYmVyKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIG51bWJlciA9IEJpZ0ludChudW1iZXIpO1xuICB2YXIgYnl0ZUNvdW50ID0gY291bnRCeXRlcyhudW1iZXIpO1xuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoYnl0ZUNvdW50KSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlQ291bnQ7IGkrKykge1xuICAgIHZhciBieXRlSW5kZXggPSBsZSA/IGkgOiBNYXRoLmFicyhpICsgMSAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgYnl0ZXNbYnl0ZUluZGV4XSA9IE51bWJlcihudW1iZXIgLyBCWVRFX1RBQkxFW2ldICYgQmlnSW50KDB4RkYpKTtcblxuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICBieXRlc1tieXRlSW5kZXhdID0gTWF0aC5hYnMofmJ5dGVzW2J5dGVJbmRleF0pO1xuICAgICAgYnl0ZXNbYnl0ZUluZGV4XSAtPSBpID09PSAwID8gMSA6IDI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcbmV4cG9ydCB2YXIgYnl0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKCFieXRlcykge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyBUT0RPOiBzaG91bGQgdG9VaW50OCBoYW5kbGUgY2FzZXMgd2hlcmUgd2Ugb25seSBoYXZlIDggYnl0ZXNcbiAgLy8gYnV0IHJlcG9ydCBtb3JlIHNpbmNlIHRoaXMgaXMgYSBVaW50MTYrIEFycmF5P1xuXG5cbiAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIHZhciBzdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHRvVWludDgoYnl0ZXMpKTtcblxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cmluZykpO1xuICB9IGNhdGNoIChlKSB7Ly8gaWYgZGVjb2RlVVJJQ29tcG9uZW50L2VzY2FwZSBmYWlscywgd2UgYXJlIGRlYWxpbmcgd2l0aCBwYXJ0aWFsXG4gICAgLy8gb3IgZnVsbCBub24gc3RyaW5nIGRhdGEuIEp1c3QgcmV0dXJuIHRoZSBwb3RlbnRpYWxseSBnYXJibGVkIHN0cmluZy5cbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59O1xuZXhwb3J0IHZhciBzdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHJpbmcsIHN0cmluZ0lzQnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnICYmIHN0cmluZyAmJiB0eXBlb2Ygc3RyaW5nLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfSAvLyBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaXMgYnl0ZXMsIHdlIGRvbid0IGhhdmUgdG8gZG8gdGhpc1xuICAvLyBvdGhlcndpc2Ugd2UgZG8gdGhpcyBzbyB0aGF0IHdlIHNwbGl0IG11bHRpIGxlbmd0aCBjaGFyYWN0ZXJzXG4gIC8vIGludG8gaW5kaXZpZHVhbCBieXRlc1xuXG5cbiAgaWYgKCFzdHJpbmdJc0J5dGVzKSB7XG4gICAgc3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICB9XG5cbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIHZpZXdbaV0gPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiB2aWV3O1xufTtcbmV4cG9ydCB2YXIgY29uY2F0VHlwZWRBcnJheXMgPSBmdW5jdGlvbiBjb25jYXRUeXBlZEFycmF5cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGJ1ZmZlcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYnVmZmVyc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGJ1ZmZlcnMgPSBidWZmZXJzLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiBiICYmIChiLmJ5dGVMZW5ndGggfHwgYi5sZW5ndGgpICYmIHR5cGVvZiBiICE9PSAnc3RyaW5nJztcbiAgfSk7XG5cbiAgaWYgKGJ1ZmZlcnMubGVuZ3RoIDw9IDEpIHtcbiAgICAvLyBmb3IgMCBsZW5ndGggd2Ugd2lsbCByZXR1cm4gZW1wdHkgdWludDhcbiAgICAvLyBmb3IgMSBsZW5ndGggd2UgcmV0dXJuIHRoZSBmaXJzdCB1aW50OFxuICAgIHJldHVybiB0b1VpbnQ4KGJ1ZmZlcnNbMF0pO1xuICB9XG5cbiAgdmFyIHRvdGFsTGVuID0gYnVmZmVycy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCBidWYsIGkpIHtcbiAgICByZXR1cm4gdG90YWwgKyAoYnVmLmJ5dGVMZW5ndGggfHwgYnVmLmxlbmd0aCk7XG4gIH0sIDApO1xuICB2YXIgdGVtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gdG9VaW50OChidWYpO1xuICAgIHRlbXBCdWZmZXIuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmJ5dGVMZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gdGVtcEJ1ZmZlcjtcbn07XG4vKipcbiAqIENoZWNrIGlmIHRoZSBieXRlcyBcImJcIiBhcmUgY29udGFpbmVkIHdpdGhpbiBieXRlcyBcImFcIi5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QXJyYXl9IGFcbiAqICAgICAgICBCeXRlcyB0byBjaGVjayBpblxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxBcnJheX0gYlxuICogICAgICAgIEJ5dGVzIHRvIGNoZWNrIGZvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheX0gW29mZnNldD0wXVxuICogICAgICAgIG9mZnNldCB0byB1c2Ugd2hlbiBsb29raW5nIGF0IGJ5dGVzIGluIGFcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl9IFttYXNrPVtdXVxuICogICAgICAgIG1hc2sgdG8gdXNlIG9uIGJ5dGVzIGJlZm9yZSBjb21wYXJpc29uLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIElmIGFsbCBieXRlcyBpbiBiIGFyZSBpbnNpZGUgb2YgYSwgdGFraW5nIGludG8gYWNjb3VudFxuICogICAgICAgICBiaXQgbWFza3MuXG4gKi9cblxuZXhwb3J0IHZhciBieXRlc01hdGNoID0gZnVuY3Rpb24gYnl0ZXNNYXRjaChhLCBiLCBfdGVtcDMpIHtcbiAgdmFyIF9yZWYzID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMyxcbiAgICAgIF9yZWYzJG9mZnNldCA9IF9yZWYzLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9yZWYzJG9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJG9mZnNldCxcbiAgICAgIF9yZWYzJG1hc2sgPSBfcmVmMy5tYXNrLFxuICAgICAgbWFzayA9IF9yZWYzJG1hc2sgPT09IHZvaWQgMCA/IFtdIDogX3JlZjMkbWFzaztcblxuICBhID0gdG9VaW50OChhKTtcbiAgYiA9IHRvVWludDgoYik7IC8vIGllIDExIGRvZXMgbm90IHN1cHBvcnQgdWludDggZXZlcnlcblxuICB2YXIgZm4gPSBiLmV2ZXJ5ID8gYi5ldmVyeSA6IEFycmF5LnByb3RvdHlwZS5ldmVyeTtcbiAgcmV0dXJuIGIubGVuZ3RoICYmIGEubGVuZ3RoIC0gb2Zmc2V0ID49IGIubGVuZ3RoICYmIC8vIGllIDExIGRvZXNuJ3Qgc3VwcG9ydCBldmVyeSBvbiB1aW44XG4gIGZuLmNhbGwoYiwgZnVuY3Rpb24gKGJCeXRlLCBpKSB7XG4gICAgdmFyIGFCeXRlID0gbWFza1tpXSA/IG1hc2tbaV0gJiBhW29mZnNldCArIGldIDogYVtvZmZzZXQgKyBpXTtcbiAgICByZXR1cm4gYkJ5dGUgPT09IGFCeXRlO1xuICB9KTtcbn07XG5leHBvcnQgdmFyIHNsaWNlQnl0ZXMgPSBmdW5jdGlvbiBzbGljZUJ5dGVzKHNyYywgc3RhcnQsIGVuZCkge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgc3RhcnQsIGVuZCkpO1xufTtcbmV4cG9ydCB2YXIgcmV2ZXJzZUJ5dGVzID0gZnVuY3Rpb24gcmV2ZXJzZUJ5dGVzKHNyYykge1xuICBpZiAoc3JjLnJldmVyc2UpIHtcbiAgICByZXR1cm4gc3JjLnJldmVyc2UoKTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKHNyYyk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/codec-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/codec-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAv1Codec: () => (/* binding */ getAv1Codec),\n/* harmony export */   getAvcCodec: () => (/* binding */ getAvcCodec),\n/* harmony export */   getHvcCodec: () => (/* binding */ getHvcCodec)\n/* harmony export */ });\n/* harmony import */ var _byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\");\n // https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n// https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#AV1\n\nvar getAv1Codec = function getAv1Codec(bytes) {\n  var codec = '';\n  var profile = bytes[1] >>> 3;\n  var level = bytes[1] & 0x1F;\n  var tier = bytes[2] >>> 7;\n  var highBitDepth = (bytes[2] & 0x40) >> 6;\n  var twelveBit = (bytes[2] & 0x20) >> 5;\n  var monochrome = (bytes[2] & 0x10) >> 4;\n  var chromaSubsamplingX = (bytes[2] & 0x08) >> 3;\n  var chromaSubsamplingY = (bytes[2] & 0x04) >> 2;\n  var chromaSamplePosition = bytes[2] & 0x03;\n  codec += profile + \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(level, 2, '0');\n\n  if (tier === 0) {\n    codec += 'M';\n  } else if (tier === 1) {\n    codec += 'H';\n  }\n\n  var bitDepth;\n\n  if (profile === 2 && highBitDepth) {\n    bitDepth = twelveBit ? 12 : 10;\n  } else {\n    bitDepth = highBitDepth ? 10 : 8;\n  }\n\n  codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(bitDepth, 2, '0'); // TODO: can we parse color range??\n\n  codec += \".\" + monochrome;\n  codec += \".\" + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition;\n  return codec;\n};\nvar getAvcCodec = function getAvcCodec(bytes) {\n  var profileId = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toHexString)(bytes[1]);\n  var constraintFlags = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toHexString)(bytes[2] & 0xFC);\n  var levelId = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toHexString)(bytes[3]);\n  return \"\" + profileId + constraintFlags + levelId;\n};\nvar getHvcCodec = function getHvcCodec(bytes) {\n  var codec = '';\n  var profileSpace = bytes[1] >> 6;\n  var profileId = bytes[1] & 0x1F;\n  var tierFlag = (bytes[1] & 0x20) >> 5;\n  var profileCompat = bytes.subarray(2, 6);\n  var constraintIds = bytes.subarray(6, 12);\n  var levelId = bytes[12];\n\n  if (profileSpace === 1) {\n    codec += 'A';\n  } else if (profileSpace === 2) {\n    codec += 'B';\n  } else if (profileSpace === 3) {\n    codec += 'C';\n  }\n\n  codec += profileId + \".\"; // ffmpeg does this in big endian\n\n  var profileCompatVal = parseInt((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toBinaryString)(profileCompat).split('').reverse().join(''), 2); // apple does this in little endian...\n\n  if (profileCompatVal > 255) {\n    profileCompatVal = parseInt((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toBinaryString)(profileCompat), 2);\n  }\n\n  codec += profileCompatVal.toString(16) + \".\";\n\n  if (tierFlag === 0) {\n    codec += 'L';\n  } else {\n    codec += 'H';\n  }\n\n  codec += levelId;\n  var constraints = '';\n\n  for (var i = 0; i < constraintIds.length; i++) {\n    var v = constraintIds[i];\n\n    if (v) {\n      if (constraints) {\n        constraints += '.';\n      }\n\n      constraints += v.toString(16);\n    }\n  }\n\n  if (constraints) {\n    codec += \".\" + constraints;\n  }\n\n  return codec;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2NvZGVjLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwRSxDQUFDO0FBQzNFOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQVE7O0FBRW5DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUJBQWlCLDBEQUFRLG9CQUFvQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQiw2REFBVztBQUM3Qix3QkFBd0IsNkRBQVc7QUFDbkMsZ0JBQWdCLDZEQUFXO0FBQzNCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCLGtDQUFrQyxnRUFBYyxrREFBa0Q7O0FBRWxHO0FBQ0EsZ0NBQWdDLGdFQUFjO0FBQzlDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2NvZGVjLWhlbHBlcnMuanM/OWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYWRTdGFydCwgdG9IZXhTdHJpbmcsIHRvQmluYXJ5U3RyaW5nIH0gZnJvbSAnLi9ieXRlLWhlbHBlcnMuanMnOyAvLyBodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLWlzb2JtZmYvI2F2MWNvZGVjY29uZmlndXJhdGlvbmJveC1zeW50YXhcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL01lZGlhL0Zvcm1hdHMvY29kZWNzX3BhcmFtZXRlciNBVjFcblxuZXhwb3J0IHZhciBnZXRBdjFDb2RlYyA9IGZ1bmN0aW9uIGdldEF2MUNvZGVjKGJ5dGVzKSB7XG4gIHZhciBjb2RlYyA9ICcnO1xuICB2YXIgcHJvZmlsZSA9IGJ5dGVzWzFdID4+PiAzO1xuICB2YXIgbGV2ZWwgPSBieXRlc1sxXSAmIDB4MUY7XG4gIHZhciB0aWVyID0gYnl0ZXNbMl0gPj4+IDc7XG4gIHZhciBoaWdoQml0RGVwdGggPSAoYnl0ZXNbMl0gJiAweDQwKSA+PiA2O1xuICB2YXIgdHdlbHZlQml0ID0gKGJ5dGVzWzJdICYgMHgyMCkgPj4gNTtcbiAgdmFyIG1vbm9jaHJvbWUgPSAoYnl0ZXNbMl0gJiAweDEwKSA+PiA0O1xuICB2YXIgY2hyb21hU3Vic2FtcGxpbmdYID0gKGJ5dGVzWzJdICYgMHgwOCkgPj4gMztcbiAgdmFyIGNocm9tYVN1YnNhbXBsaW5nWSA9IChieXRlc1syXSAmIDB4MDQpID4+IDI7XG4gIHZhciBjaHJvbWFTYW1wbGVQb3NpdGlvbiA9IGJ5dGVzWzJdICYgMHgwMztcbiAgY29kZWMgKz0gcHJvZmlsZSArIFwiLlwiICsgcGFkU3RhcnQobGV2ZWwsIDIsICcwJyk7XG5cbiAgaWYgKHRpZXIgPT09IDApIHtcbiAgICBjb2RlYyArPSAnTSc7XG4gIH0gZWxzZSBpZiAodGllciA9PT0gMSkge1xuICAgIGNvZGVjICs9ICdIJztcbiAgfVxuXG4gIHZhciBiaXREZXB0aDtcblxuICBpZiAocHJvZmlsZSA9PT0gMiAmJiBoaWdoQml0RGVwdGgpIHtcbiAgICBiaXREZXB0aCA9IHR3ZWx2ZUJpdCA/IDEyIDogMTA7XG4gIH0gZWxzZSB7XG4gICAgYml0RGVwdGggPSBoaWdoQml0RGVwdGggPyAxMCA6IDg7XG4gIH1cblxuICBjb2RlYyArPSBcIi5cIiArIHBhZFN0YXJ0KGJpdERlcHRoLCAyLCAnMCcpOyAvLyBUT0RPOiBjYW4gd2UgcGFyc2UgY29sb3IgcmFuZ2U/P1xuXG4gIGNvZGVjICs9IFwiLlwiICsgbW9ub2Nocm9tZTtcbiAgY29kZWMgKz0gXCIuXCIgKyBjaHJvbWFTdWJzYW1wbGluZ1ggKyBjaHJvbWFTdWJzYW1wbGluZ1kgKyBjaHJvbWFTYW1wbGVQb3NpdGlvbjtcbiAgcmV0dXJuIGNvZGVjO1xufTtcbmV4cG9ydCB2YXIgZ2V0QXZjQ29kZWMgPSBmdW5jdGlvbiBnZXRBdmNDb2RlYyhieXRlcykge1xuICB2YXIgcHJvZmlsZUlkID0gdG9IZXhTdHJpbmcoYnl0ZXNbMV0pO1xuICB2YXIgY29uc3RyYWludEZsYWdzID0gdG9IZXhTdHJpbmcoYnl0ZXNbMl0gJiAweEZDKTtcbiAgdmFyIGxldmVsSWQgPSB0b0hleFN0cmluZyhieXRlc1szXSk7XG4gIHJldHVybiBcIlwiICsgcHJvZmlsZUlkICsgY29uc3RyYWludEZsYWdzICsgbGV2ZWxJZDtcbn07XG5leHBvcnQgdmFyIGdldEh2Y0NvZGVjID0gZnVuY3Rpb24gZ2V0SHZjQ29kZWMoYnl0ZXMpIHtcbiAgdmFyIGNvZGVjID0gJyc7XG4gIHZhciBwcm9maWxlU3BhY2UgPSBieXRlc1sxXSA+PiA2O1xuICB2YXIgcHJvZmlsZUlkID0gYnl0ZXNbMV0gJiAweDFGO1xuICB2YXIgdGllckZsYWcgPSAoYnl0ZXNbMV0gJiAweDIwKSA+PiA1O1xuICB2YXIgcHJvZmlsZUNvbXBhdCA9IGJ5dGVzLnN1YmFycmF5KDIsIDYpO1xuICB2YXIgY29uc3RyYWludElkcyA9IGJ5dGVzLnN1YmFycmF5KDYsIDEyKTtcbiAgdmFyIGxldmVsSWQgPSBieXRlc1sxMl07XG5cbiAgaWYgKHByb2ZpbGVTcGFjZSA9PT0gMSkge1xuICAgIGNvZGVjICs9ICdBJztcbiAgfSBlbHNlIGlmIChwcm9maWxlU3BhY2UgPT09IDIpIHtcbiAgICBjb2RlYyArPSAnQic7XG4gIH0gZWxzZSBpZiAocHJvZmlsZVNwYWNlID09PSAzKSB7XG4gICAgY29kZWMgKz0gJ0MnO1xuICB9XG5cbiAgY29kZWMgKz0gcHJvZmlsZUlkICsgXCIuXCI7IC8vIGZmbXBlZyBkb2VzIHRoaXMgaW4gYmlnIGVuZGlhblxuXG4gIHZhciBwcm9maWxlQ29tcGF0VmFsID0gcGFyc2VJbnQodG9CaW5hcnlTdHJpbmcocHJvZmlsZUNvbXBhdCkuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSwgMik7IC8vIGFwcGxlIGRvZXMgdGhpcyBpbiBsaXR0bGUgZW5kaWFuLi4uXG5cbiAgaWYgKHByb2ZpbGVDb21wYXRWYWwgPiAyNTUpIHtcbiAgICBwcm9maWxlQ29tcGF0VmFsID0gcGFyc2VJbnQodG9CaW5hcnlTdHJpbmcocHJvZmlsZUNvbXBhdCksIDIpO1xuICB9XG5cbiAgY29kZWMgKz0gcHJvZmlsZUNvbXBhdFZhbC50b1N0cmluZygxNikgKyBcIi5cIjtcblxuICBpZiAodGllckZsYWcgPT09IDApIHtcbiAgICBjb2RlYyArPSAnTCc7XG4gIH0gZWxzZSB7XG4gICAgY29kZWMgKz0gJ0gnO1xuICB9XG5cbiAgY29kZWMgKz0gbGV2ZWxJZDtcbiAgdmFyIGNvbnN0cmFpbnRzID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50SWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHYgPSBjb25zdHJhaW50SWRzW2ldO1xuXG4gICAgaWYgKHYpIHtcbiAgICAgIGlmIChjb25zdHJhaW50cykge1xuICAgICAgICBjb25zdHJhaW50cyArPSAnLic7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cmFpbnRzICs9IHYudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb25zdHJhaW50cykge1xuICAgIGNvZGVjICs9IFwiLlwiICsgY29uc3RyYWludHM7XG4gIH1cblxuICByZXR1cm4gY29kZWM7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/codec-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/codecs.js":
/*!******************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/codecs.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUDIO_CODEC: () => (/* binding */ DEFAULT_AUDIO_CODEC),\n/* harmony export */   DEFAULT_VIDEO_CODEC: () => (/* binding */ DEFAULT_VIDEO_CODEC),\n/* harmony export */   browserSupportsCodec: () => (/* binding */ browserSupportsCodec),\n/* harmony export */   codecsFromDefault: () => (/* binding */ codecsFromDefault),\n/* harmony export */   getMimeForCodec: () => (/* binding */ getMimeForCodec),\n/* harmony export */   isAudioCodec: () => (/* binding */ isAudioCodec),\n/* harmony export */   isTextCodec: () => (/* binding */ isTextCodec),\n/* harmony export */   isVideoCodec: () => (/* binding */ isVideoCodec),\n/* harmony export */   mapLegacyAvcCodecs: () => (/* binding */ mapLegacyAvcCodecs),\n/* harmony export */   muxerSupportsCodec: () => (/* binding */ muxerSupportsCodec),\n/* harmony export */   parseCodecs: () => (/* binding */ parseCodecs),\n/* harmony export */   translateLegacyCodec: () => (/* binding */ translateLegacyCodec),\n/* harmony export */   translateLegacyCodecs: () => (/* binding */ translateLegacyCodecs)\n/* harmony export */ });\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__);\n\nvar regexs = {\n  // to determine mime types\n  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n  // to determine if a codec is audio or video\n  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n  text: /^(stpp.ttml.im1t)/,\n  // mux.js support regex\n  muxerVideo: /^(avc0?1)/,\n  muxerAudio: /^(mp4a)/,\n  // match nothing as muxer does not support text right now.\n  // there cannot never be a character before the start of a string\n  // so this matches nothing.\n  muxerText: /a^/\n};\nvar mediaTypes = ['video', 'audio', 'text'];\nvar upperMediaTypes = ['Video', 'Audio', 'Text'];\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string} codec\n *        Codec string to translate\n * @return {string}\n *         The translated codec string\n */\n\nvar translateLegacyCodec = function translateLegacyCodec(codec) {\n  if (!codec) {\n    return codec;\n  }\n\n  return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n    var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n    var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n    return 'avc1.' + profileHex + '00' + avcLevelHex;\n  });\n};\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec strings with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string[]} codecs\n *        An array of codec strings to translate\n * @return {string[]}\n *         The translated array of codec strings\n */\n\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(translateLegacyCodec);\n};\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param {string} codecString\n *        The codec string\n * @return {string}\n *         The codec string with old apple-style codecs replaced\n *\n * @private\n */\n\nvar mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return translateLegacyCodecs([match])[0];\n  });\n};\n/**\n * @typedef {Object} ParsedCodecInfo\n * @property {number} codecCount\n *           Number of codecs parsed\n * @property {string} [videoCodec]\n *           Parsed video codec (if found)\n * @property {string} [videoObjectTypeIndicator]\n *           Video object type indicator (if found)\n * @property {string|null} audioProfile\n *           Audio profile\n */\n\n/**\n * Parses a codec string to retrieve the number of codecs specified, the video codec and\n * object type indicator, and the audio profile.\n *\n * @param {string} [codecString]\n *        The codec string to parse\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\nvar parseCodecs = function parseCodecs(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  var codecs = codecString.split(',');\n  var result = [];\n  codecs.forEach(function (codec) {\n    codec = codec.trim();\n    var codecType;\n    mediaTypes.forEach(function (name) {\n      var match = regexs[name].exec(codec.toLowerCase());\n\n      if (!match || match.length <= 1) {\n        return;\n      }\n\n      codecType = name; // maintain codec case\n\n      var type = codec.substring(0, match[1].length);\n      var details = codec.replace(type, '');\n      result.push({\n        type: type,\n        details: details,\n        mediaType: name\n      });\n    });\n\n    if (!codecType) {\n      result.push({\n        type: codec,\n        details: '',\n        mediaType: 'unknown'\n      });\n    }\n  });\n  return result;\n};\n/**\n * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n * a default alternate audio playlist for the provided audio group.\n *\n * @param {Object} master\n *        The master playlist\n * @param {string} audioGroupId\n *        ID of the audio group for which to find the default codec info\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\nvar codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\n    return null;\n  }\n\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n\n  if (!audioGroup) {\n    return null;\n  }\n\n  for (var name in audioGroup) {\n    var audioType = audioGroup[name];\n\n    if (audioType.default && audioType.playlists) {\n      // codec should be the same for all playlists within the audio type\n      return parseCodecs(audioType.playlists[0].attributes.CODECS);\n    }\n  }\n\n  return null;\n};\nvar isVideoCodec = function isVideoCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.video.test(codec.trim().toLowerCase());\n};\nvar isAudioCodec = function isAudioCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.audio.test(codec.trim().toLowerCase());\n};\nvar isTextCodec = function isTextCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.text.test(codec.trim().toLowerCase());\n};\nvar getMimeForCodec = function getMimeForCodec(codecString) {\n  if (!codecString || typeof codecString !== 'string') {\n    return;\n  }\n\n  var codecs = codecString.toLowerCase().split(',').map(function (c) {\n    return translateLegacyCodec(c.trim());\n  }); // default to video type\n\n  var type = 'video'; // only change to audio type if the only codec we have is\n  // audio\n\n  if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n    type = 'audio';\n  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n    // text uses application/<container> for now\n    type = 'application';\n  } // default the container to mp4\n\n\n  var container = 'mp4'; // every codec must be able to go into the container\n  // for that container to be the correct one\n\n  if (codecs.every(function (c) {\n    return regexs.mp4.test(c);\n  })) {\n    container = 'mp4';\n  } else if (codecs.every(function (c) {\n    return regexs.webm.test(c);\n  })) {\n    container = 'webm';\n  } else if (codecs.every(function (c) {\n    return regexs.ogg.test(c);\n  })) {\n    container = 'ogg';\n  }\n\n  return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n};\n/**\n * Tests whether the codec is supported by MediaSource. Optionally also tests ManagedMediaSource.\n *\n * @param {string} codecString\n *        Codec to test\n * @param {boolean} [withMMS]\n *        Whether to check if ManagedMediaSource supports it\n * @return {boolean}\n *          Codec is supported\n */\n\nvar browserSupportsCodec = function browserSupportsCodec(codecString, withMMS) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  if (withMMS === void 0) {\n    withMMS = false;\n  }\n\n  return (global_window__WEBPACK_IMPORTED_MODULE_0___default().MediaSource) && (global_window__WEBPACK_IMPORTED_MODULE_0___default().MediaSource).isTypeSupported && global_window__WEBPACK_IMPORTED_MODULE_0___default().MediaSource.isTypeSupported(getMimeForCodec(codecString)) || withMMS && (global_window__WEBPACK_IMPORTED_MODULE_0___default().ManagedMediaSource) && (global_window__WEBPACK_IMPORTED_MODULE_0___default().ManagedMediaSource).isTypeSupported && global_window__WEBPACK_IMPORTED_MODULE_0___default().ManagedMediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n};\nvar muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return codecString.toLowerCase().split(',').every(function (codec) {\n    codec = codec.trim(); // any match is supported.\n\n    for (var i = 0; i < upperMediaTypes.length; i++) {\n      var type = upperMediaTypes[i];\n\n      if (regexs[\"muxer\" + type].test(codec)) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\nvar DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\nvar DEFAULT_VIDEO_CODEC = 'avc1.4d400d';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2NvZGVjcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0oseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxrRUFBa0IsSUFBSSxrRUFBa0Isb0JBQW9CLGdFQUFrQiw2REFBNkQseUVBQXlCLElBQUkseUVBQXlCLG9CQUFvQix1RUFBeUI7QUFDdlA7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsb0JBQW9CLDRCQUE0QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNPO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvZXMvY29kZWNzLmpzP2I1ZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbnZhciByZWdleHMgPSB7XG4gIC8vIHRvIGRldGVybWluZSBtaW1lIHR5cGVzXG4gIG1wNDogL14oYXYwPzF8YXZjMD9bMTIzNF18dnAwPzl8ZmxhY3xvcHVzfG1wM3xtcDRhfG1wNHZ8c3RwcC50dG1sLmltMXQpLyxcbiAgd2VibTogL14odnAwP1s4OV18YXYwPzF8b3B1c3x2b3JiaXMpLyxcbiAgb2dnOiAvXih2cDA/Wzg5XXx0aGVvcmF8ZmxhY3xvcHVzfHZvcmJpcykvLFxuICAvLyB0byBkZXRlcm1pbmUgaWYgYSBjb2RlYyBpcyBhdWRpbyBvciB2aWRlb1xuICB2aWRlbzogL14oYXYwPzF8YXZjMD9bMTIzNF18dnAwP1s4OV18aHZjMXxoZXYxfHRoZW9yYXxtcDR2KS8sXG4gIGF1ZGlvOiAvXihtcDRhfGZsYWN8dm9yYmlzfG9wdXN8YWMtWzM0XXxlYy0zfGFsYWN8bXAzfHNwZWV4fGFhYykvLFxuICB0ZXh0OiAvXihzdHBwLnR0bWwuaW0xdCkvLFxuICAvLyBtdXguanMgc3VwcG9ydCByZWdleFxuICBtdXhlclZpZGVvOiAvXihhdmMwPzEpLyxcbiAgbXV4ZXJBdWRpbzogL14obXA0YSkvLFxuICAvLyBtYXRjaCBub3RoaW5nIGFzIG11eGVyIGRvZXMgbm90IHN1cHBvcnQgdGV4dCByaWdodCBub3cuXG4gIC8vIHRoZXJlIGNhbm5vdCBuZXZlciBiZSBhIGNoYXJhY3RlciBiZWZvcmUgdGhlIHN0YXJ0IG9mIGEgc3RyaW5nXG4gIC8vIHNvIHRoaXMgbWF0Y2hlcyBub3RoaW5nLlxuICBtdXhlclRleHQ6IC9hXi9cbn07XG52YXIgbWVkaWFUeXBlcyA9IFsndmlkZW8nLCAnYXVkaW8nLCAndGV4dCddO1xudmFyIHVwcGVyTWVkaWFUeXBlcyA9IFsnVmlkZW8nLCAnQXVkaW8nLCAnVGV4dCddO1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBvbGQgYXBwbGUtc3R5bGUgYGF2YzEuPGRkPi48ZGQ+YCBjb2RlYyBzdHJpbmcgd2l0aCB0aGUgc3RhbmRhcmRcbiAqIGBhdmMxLjxoaGhoaGg+YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlY1xuICogICAgICAgIENvZGVjIHN0cmluZyB0byB0cmFuc2xhdGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHRyYW5zbGF0ZWQgY29kZWMgc3RyaW5nXG4gKi9cblxuZXhwb3J0IHZhciB0cmFuc2xhdGVMZWdhY3lDb2RlYyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUxlZ2FjeUNvZGVjKGNvZGVjKSB7XG4gIGlmICghY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWM7XG4gIH1cblxuICByZXR1cm4gY29kZWMucmVwbGFjZSgvYXZjMVxcLihcXGQrKVxcLihcXGQrKS9pLCBmdW5jdGlvbiAob3JpZywgcHJvZmlsZSwgYXZjTGV2ZWwpIHtcbiAgICB2YXIgcHJvZmlsZUhleCA9ICgnMDAnICsgTnVtYmVyKHByb2ZpbGUpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIHZhciBhdmNMZXZlbEhleCA9ICgnMDAnICsgTnVtYmVyKGF2Y0xldmVsKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICByZXR1cm4gJ2F2YzEuJyArIHByb2ZpbGVIZXggKyAnMDAnICsgYXZjTGV2ZWxIZXg7XG4gIH0pO1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgb2xkIGFwcGxlLXN0eWxlIGBhdmMxLjxkZD4uPGRkPmAgY29kZWMgc3RyaW5ncyB3aXRoIHRoZSBzdGFuZGFyZFxuICogYGF2YzEuPGhoaGhoaD5gXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gY29kZWNzXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgY29kZWMgc3RyaW5ncyB0byB0cmFuc2xhdGVcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogICAgICAgICBUaGUgdHJhbnNsYXRlZCBhcnJheSBvZiBjb2RlYyBzdHJpbmdzXG4gKi9cblxuZXhwb3J0IHZhciB0cmFuc2xhdGVMZWdhY3lDb2RlY3MgPSBmdW5jdGlvbiB0cmFuc2xhdGVMZWdhY3lDb2RlY3MoY29kZWNzKSB7XG4gIHJldHVybiBjb2RlY3MubWFwKHRyYW5zbGF0ZUxlZ2FjeUNvZGVjKTtcbn07XG4vKipcbiAqIFJlcGxhY2UgY29kZWNzIGluIHRoZSBjb2RlYyBzdHJpbmcgd2l0aCB0aGUgb2xkIGFwcGxlLXN0eWxlIGBhdmMxLjxkZD4uPGRkPmAgdG8gdGhlXG4gKiBzdGFuZGFyZCBgYXZjMS48aGhoaGhoPmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVjU3RyaW5nXG4gKiAgICAgICAgVGhlIGNvZGVjIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgY29kZWMgc3RyaW5nIHdpdGggb2xkIGFwcGxlLXN0eWxlIGNvZGVjcyByZXBsYWNlZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IHZhciBtYXBMZWdhY3lBdmNDb2RlY3MgPSBmdW5jdGlvbiBtYXBMZWdhY3lBdmNDb2RlY3MoY29kZWNTdHJpbmcpIHtcbiAgcmV0dXJuIGNvZGVjU3RyaW5nLnJlcGxhY2UoL2F2YzFcXC4oXFxkKylcXC4oXFxkKykvaSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZUxlZ2FjeUNvZGVjcyhbbWF0Y2hdKVswXTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZWRDb2RlY0luZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlY0NvdW50XG4gKiAgICAgICAgICAgTnVtYmVyIG9mIGNvZGVjcyBwYXJzZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmlkZW9Db2RlY11cbiAqICAgICAgICAgICBQYXJzZWQgdmlkZW8gY29kZWMgKGlmIGZvdW5kKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2aWRlb09iamVjdFR5cGVJbmRpY2F0b3JdXG4gKiAgICAgICAgICAgVmlkZW8gb2JqZWN0IHR5cGUgaW5kaWNhdG9yIChpZiBmb3VuZClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IGF1ZGlvUHJvZmlsZVxuICogICAgICAgICAgIEF1ZGlvIHByb2ZpbGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBhIGNvZGVjIHN0cmluZyB0byByZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGNvZGVjcyBzcGVjaWZpZWQsIHRoZSB2aWRlbyBjb2RlYyBhbmRcbiAqIG9iamVjdCB0eXBlIGluZGljYXRvciwgYW5kIHRoZSBhdWRpbyBwcm9maWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZWNTdHJpbmddXG4gKiAgICAgICAgVGhlIGNvZGVjIHN0cmluZyB0byBwYXJzZVxuICogQHJldHVybiB7UGFyc2VkQ29kZWNJbmZvfVxuICogICAgICAgICBQYXJzZWQgY29kZWMgaW5mb1xuICovXG5cbmV4cG9ydCB2YXIgcGFyc2VDb2RlY3MgPSBmdW5jdGlvbiBwYXJzZUNvZGVjcyhjb2RlY1N0cmluZykge1xuICBpZiAoY29kZWNTdHJpbmcgPT09IHZvaWQgMCkge1xuICAgIGNvZGVjU3RyaW5nID0gJyc7XG4gIH1cblxuICB2YXIgY29kZWNzID0gY29kZWNTdHJpbmcuc3BsaXQoJywnKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBjb2RlY3MuZm9yRWFjaChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBjb2RlYyA9IGNvZGVjLnRyaW0oKTtcbiAgICB2YXIgY29kZWNUeXBlO1xuICAgIG1lZGlhVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIG1hdGNoID0gcmVnZXhzW25hbWVdLmV4ZWMoY29kZWMudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2gubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb2RlY1R5cGUgPSBuYW1lOyAvLyBtYWludGFpbiBjb2RlYyBjYXNlXG5cbiAgICAgIHZhciB0eXBlID0gY29kZWMuc3Vic3RyaW5nKDAsIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICB2YXIgZGV0YWlscyA9IGNvZGVjLnJlcGxhY2UodHlwZSwgJycpO1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICBtZWRpYVR5cGU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCFjb2RlY1R5cGUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgdHlwZTogY29kZWMsXG4gICAgICAgIGRldGFpbHM6ICcnLFxuICAgICAgICBtZWRpYVR5cGU6ICd1bmtub3duJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIFJldHVybnMgYSBQYXJzZWRDb2RlY0luZm8gb2JqZWN0IGZvciB0aGUgZGVmYXVsdCBhbHRlcm5hdGUgYXVkaW8gcGxheWxpc3QgaWYgdGhlcmUgaXNcbiAqIGEgZGVmYXVsdCBhbHRlcm5hdGUgYXVkaW8gcGxheWxpc3QgZm9yIHRoZSBwcm92aWRlZCBhdWRpbyBncm91cC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFzdGVyXG4gKiAgICAgICAgVGhlIG1hc3RlciBwbGF5bGlzdFxuICogQHBhcmFtIHtzdHJpbmd9IGF1ZGlvR3JvdXBJZFxuICogICAgICAgIElEIG9mIHRoZSBhdWRpbyBncm91cCBmb3Igd2hpY2ggdG8gZmluZCB0aGUgZGVmYXVsdCBjb2RlYyBpbmZvXG4gKiBAcmV0dXJuIHtQYXJzZWRDb2RlY0luZm99XG4gKiAgICAgICAgIFBhcnNlZCBjb2RlYyBpbmZvXG4gKi9cblxuZXhwb3J0IHZhciBjb2RlY3NGcm9tRGVmYXVsdCA9IGZ1bmN0aW9uIGNvZGVjc0Zyb21EZWZhdWx0KG1hc3RlciwgYXVkaW9Hcm91cElkKSB7XG4gIGlmICghbWFzdGVyLm1lZGlhR3JvdXBzLkFVRElPIHx8ICFhdWRpb0dyb3VwSWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhdWRpb0dyb3VwID0gbWFzdGVyLm1lZGlhR3JvdXBzLkFVRElPW2F1ZGlvR3JvdXBJZF07XG5cbiAgaWYgKCFhdWRpb0dyb3VwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGF1ZGlvR3JvdXApIHtcbiAgICB2YXIgYXVkaW9UeXBlID0gYXVkaW9Hcm91cFtuYW1lXTtcblxuICAgIGlmIChhdWRpb1R5cGUuZGVmYXVsdCAmJiBhdWRpb1R5cGUucGxheWxpc3RzKSB7XG4gICAgICAvLyBjb2RlYyBzaG91bGQgYmUgdGhlIHNhbWUgZm9yIGFsbCBwbGF5bGlzdHMgd2l0aGluIHRoZSBhdWRpbyB0eXBlXG4gICAgICByZXR1cm4gcGFyc2VDb2RlY3MoYXVkaW9UeXBlLnBsYXlsaXN0c1swXS5hdHRyaWJ1dGVzLkNPREVDUyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IHZhciBpc1ZpZGVvQ29kZWMgPSBmdW5jdGlvbiBpc1ZpZGVvQ29kZWMoY29kZWMpIHtcbiAgaWYgKGNvZGVjID09PSB2b2lkIDApIHtcbiAgICBjb2RlYyA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4cy52aWRlby50ZXN0KGNvZGVjLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5leHBvcnQgdmFyIGlzQXVkaW9Db2RlYyA9IGZ1bmN0aW9uIGlzQXVkaW9Db2RlYyhjb2RlYykge1xuICBpZiAoY29kZWMgPT09IHZvaWQgMCkge1xuICAgIGNvZGVjID0gJyc7XG4gIH1cblxuICByZXR1cm4gcmVnZXhzLmF1ZGlvLnRlc3QoY29kZWMudHJpbSgpLnRvTG93ZXJDYXNlKCkpO1xufTtcbmV4cG9ydCB2YXIgaXNUZXh0Q29kZWMgPSBmdW5jdGlvbiBpc1RleHRDb2RlYyhjb2RlYykge1xuICBpZiAoY29kZWMgPT09IHZvaWQgMCkge1xuICAgIGNvZGVjID0gJyc7XG4gIH1cblxuICByZXR1cm4gcmVnZXhzLnRleHQudGVzdChjb2RlYy50cmltKCkudG9Mb3dlckNhc2UoKSk7XG59O1xuZXhwb3J0IHZhciBnZXRNaW1lRm9yQ29kZWMgPSBmdW5jdGlvbiBnZXRNaW1lRm9yQ29kZWMoY29kZWNTdHJpbmcpIHtcbiAgaWYgKCFjb2RlY1N0cmluZyB8fCB0eXBlb2YgY29kZWNTdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvZGVjcyA9IGNvZGVjU3RyaW5nLnRvTG93ZXJDYXNlKCkuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRlTGVnYWN5Q29kZWMoYy50cmltKCkpO1xuICB9KTsgLy8gZGVmYXVsdCB0byB2aWRlbyB0eXBlXG5cbiAgdmFyIHR5cGUgPSAndmlkZW8nOyAvLyBvbmx5IGNoYW5nZSB0byBhdWRpbyB0eXBlIGlmIHRoZSBvbmx5IGNvZGVjIHdlIGhhdmUgaXNcbiAgLy8gYXVkaW9cblxuICBpZiAoY29kZWNzLmxlbmd0aCA9PT0gMSAmJiBpc0F1ZGlvQ29kZWMoY29kZWNzWzBdKSkge1xuICAgIHR5cGUgPSAnYXVkaW8nO1xuICB9IGVsc2UgaWYgKGNvZGVjcy5sZW5ndGggPT09IDEgJiYgaXNUZXh0Q29kZWMoY29kZWNzWzBdKSkge1xuICAgIC8vIHRleHQgdXNlcyBhcHBsaWNhdGlvbi88Y29udGFpbmVyPiBmb3Igbm93XG4gICAgdHlwZSA9ICdhcHBsaWNhdGlvbic7XG4gIH0gLy8gZGVmYXVsdCB0aGUgY29udGFpbmVyIHRvIG1wNFxuXG5cbiAgdmFyIGNvbnRhaW5lciA9ICdtcDQnOyAvLyBldmVyeSBjb2RlYyBtdXN0IGJlIGFibGUgdG8gZ28gaW50byB0aGUgY29udGFpbmVyXG4gIC8vIGZvciB0aGF0IGNvbnRhaW5lciB0byBiZSB0aGUgY29ycmVjdCBvbmVcblxuICBpZiAoY29kZWNzLmV2ZXJ5KGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHJlZ2V4cy5tcDQudGVzdChjKTtcbiAgfSkpIHtcbiAgICBjb250YWluZXIgPSAnbXA0JztcbiAgfSBlbHNlIGlmIChjb2RlY3MuZXZlcnkoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gcmVnZXhzLndlYm0udGVzdChjKTtcbiAgfSkpIHtcbiAgICBjb250YWluZXIgPSAnd2VibSc7XG4gIH0gZWxzZSBpZiAoY29kZWNzLmV2ZXJ5KGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHJlZ2V4cy5vZ2cudGVzdChjKTtcbiAgfSkpIHtcbiAgICBjb250YWluZXIgPSAnb2dnJztcbiAgfVxuXG4gIHJldHVybiB0eXBlICsgXCIvXCIgKyBjb250YWluZXIgKyBcIjtjb2RlY3M9XFxcIlwiICsgY29kZWNTdHJpbmcgKyBcIlxcXCJcIjtcbn07XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIGNvZGVjIGlzIHN1cHBvcnRlZCBieSBNZWRpYVNvdXJjZS4gT3B0aW9uYWxseSBhbHNvIHRlc3RzIE1hbmFnZWRNZWRpYVNvdXJjZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZWNTdHJpbmdcbiAqICAgICAgICBDb2RlYyB0byB0ZXN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoTU1TXVxuICogICAgICAgIFdoZXRoZXIgdG8gY2hlY2sgaWYgTWFuYWdlZE1lZGlhU291cmNlIHN1cHBvcnRzIGl0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAgQ29kZWMgaXMgc3VwcG9ydGVkXG4gKi9cblxuZXhwb3J0IHZhciBicm93c2VyU3VwcG9ydHNDb2RlYyA9IGZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c0NvZGVjKGNvZGVjU3RyaW5nLCB3aXRoTU1TKSB7XG4gIGlmIChjb2RlY1N0cmluZyA9PT0gdm9pZCAwKSB7XG4gICAgY29kZWNTdHJpbmcgPSAnJztcbiAgfVxuXG4gIGlmICh3aXRoTU1TID09PSB2b2lkIDApIHtcbiAgICB3aXRoTU1TID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlICYmIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgJiYgd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChnZXRNaW1lRm9yQ29kZWMoY29kZWNTdHJpbmcpKSB8fCB3aXRoTU1TICYmIHdpbmRvdy5NYW5hZ2VkTWVkaWFTb3VyY2UgJiYgd2luZG93Lk1hbmFnZWRNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgJiYgd2luZG93Lk1hbmFnZWRNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoZ2V0TWltZUZvckNvZGVjKGNvZGVjU3RyaW5nKSkgfHwgZmFsc2U7XG59O1xuZXhwb3J0IHZhciBtdXhlclN1cHBvcnRzQ29kZWMgPSBmdW5jdGlvbiBtdXhlclN1cHBvcnRzQ29kZWMoY29kZWNTdHJpbmcpIHtcbiAgaWYgKGNvZGVjU3RyaW5nID09PSB2b2lkIDApIHtcbiAgICBjb2RlY1N0cmluZyA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIGNvZGVjU3RyaW5nLnRvTG93ZXJDYXNlKCkuc3BsaXQoJywnKS5ldmVyeShmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBjb2RlYyA9IGNvZGVjLnRyaW0oKTsgLy8gYW55IG1hdGNoIGlzIHN1cHBvcnRlZC5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBwZXJNZWRpYVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHlwZSA9IHVwcGVyTWVkaWFUeXBlc1tpXTtcblxuICAgICAgaWYgKHJlZ2V4c1tcIm11eGVyXCIgKyB0eXBlXS50ZXN0KGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufTtcbmV4cG9ydCB2YXIgREVGQVVMVF9BVURJT19DT0RFQyA9ICdtcDRhLjQwLjInO1xuZXhwb3J0IHZhciBERUZBVUxUX1ZJREVPX0NPREVDID0gJ2F2YzEuNGQ0MDBkJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/codecs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/containers.js":
/*!**********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/containers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectContainerForBytes: () => (/* binding */ detectContainerForBytes),\n/* harmony export */   isLikely: () => (/* binding */ isLikely),\n/* harmony export */   isLikelyFmp4MediaSegment: () => (/* binding */ isLikelyFmp4MediaSegment)\n/* harmony export */ });\n/* harmony import */ var _byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\");\n/* harmony import */ var _mp4_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mp4-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/mp4-helpers.js\");\n/* harmony import */ var _ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ebml-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/ebml-helpers.js\");\n/* harmony import */ var _id3_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./id3-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/id3-helpers.js\");\n/* harmony import */ var _nal_helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nal-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/nal-helpers.js\");\n\n\n\n\n\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x73, 0x74, 0x79, 0x70]),\n  // \"ftypqt\" string literal in hex\n  'mov': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n  // moov string literal in hex\n  'moov': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x6D, 0x6F, 0x6F, 0x76]),\n  // moof string literal in hex\n  'moof': (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x6D, 0x6F, 0x6F, 0x66])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = (0,_id3_helpers_js__WEBPACK_IMPORTED_MODULE_3__.getId3Offset)(bytes);\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = (0,_id3_helpers_js__WEBPACK_IMPORTED_MODULE_3__.getId3Offset)(bytes);\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = (0,_ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__.findEbml)(bytes, [_ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__.EBML_TAGS.EBML, _ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__.EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = (0,_ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__.findEbml)(bytes, [_ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__.EBML_TAGS.EBML, _ebml_helpers_js__WEBPACK_IMPORTED_MODULE_2__.EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    // if this file is another base media file format, it is not mp4\n    if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n      return false;\n    } // if this file starts with a ftyp or styp box its mp4\n\n\n    if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    })) {\n      return true;\n    } // if this file starts with a moof/moov box its mp4\n\n\n    if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.moof, {\n      offset: 4\n    }) || (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.moov, {\n      offset: 4\n    })) {\n      return true;\n    }\n  },\n  mov: function mov(bytes) {\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = (0,_id3_helpers_js__WEBPACK_IMPORTED_MODULE_3__.getId3Offset)(bytes);\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = (0,_id3_helpers_js__WEBPACK_IMPORTED_MODULE_3__.getId3Offset)(bytes);\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.riff) && (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.riff) && (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return (0,_nal_helpers_js__WEBPACK_IMPORTED_MODULE_4__.findH264Nal)(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return (0,_nal_helpers_js__WEBPACK_IMPORTED_MODULE_4__.findH265Nal)(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes));\n  };\n}); // export after wrapping\n\nvar isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nvar detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nvar isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return (0,_mp4_helpers_js__WEBPACK_IMPORTED_MODULE_1__.findBox)(bytes, ['moof']).length > 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2NvbnRhaW5lcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDYjtBQUNhO0FBQ1I7QUFDWTtBQUM1RDtBQUNBO0FBQ0EsVUFBVSx5REFBTztBQUNqQjtBQUNBLGNBQWMseURBQU87QUFDckI7QUFDQSxVQUFVLHlEQUFPO0FBQ2pCO0FBQ0EsU0FBUyx5REFBTztBQUNoQjtBQUNBO0FBQ0EsU0FBUyx5REFBTztBQUNoQjtBQUNBLFVBQVUseURBQU87QUFDakI7QUFDQSxTQUFTLHlEQUFPO0FBQ2hCO0FBQ0EsU0FBUyx5REFBTztBQUNoQjtBQUNBLFNBQVMseURBQU87QUFDaEI7QUFDQSxTQUFTLHlEQUFPO0FBQ2hCO0FBQ0EsVUFBVSx5REFBTztBQUNqQjtBQUNBLFNBQVMseURBQU87QUFDaEI7QUFDQSxVQUFVLHlEQUFPO0FBQ2pCO0FBQ0EsVUFBVSx5REFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVk7QUFDN0IsV0FBVyw0REFBVTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QixXQUFXLDREQUFVO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBEQUFRLFNBQVMsdURBQVMsT0FBTyx1REFBUyxlQUFlOztBQUUzRSxXQUFXLDREQUFVO0FBQ3JCLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiwwREFBUSxTQUFTLHVEQUFTLE9BQU8sdURBQVMsZUFBZTs7QUFFM0UsV0FBVyw0REFBVTtBQUNyQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixRQUFRLDREQUFVO0FBQ2xCO0FBQ0EsS0FBSyxLQUFLLDREQUFVO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTTs7O0FBR04sUUFBUSw0REFBVTtBQUNsQjtBQUNBLEtBQUssS0FBSyw0REFBVTtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyw0REFBVTtBQUNyQjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxXQUFXLDREQUFVO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QixXQUFXLDREQUFVO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkRBQVk7QUFDN0IsV0FBVyw0REFBVTtBQUNyQjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxXQUFXLDREQUFVO0FBQ3JCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNERBQVUsMkJBQTJCLDREQUFVO0FBQzFEO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFdBQVcsNERBQVUsMkJBQTJCLDREQUFVO0FBQzFEO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyw0REFBVztBQUN0QixHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVcsNERBQVc7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlEQUFPO0FBQzdCO0FBQ0EsQ0FBQyxHQUFHOztBQUVHLDBCQUEwQjtBQUNqQzs7QUFFTztBQUNQLFVBQVUseURBQU87O0FBRWpCLGtCQUFrQiwwQkFBMEI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVJO0FBQ1AsU0FBUyx3REFBTztBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXNuYXBzaG90LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9lcy9jb250YWluZXJzLmpzP2Y4NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9VaW50OCwgYnl0ZXNNYXRjaCB9IGZyb20gJy4vYnl0ZS1oZWxwZXJzLmpzJztcbmltcG9ydCB7IGZpbmRCb3ggfSBmcm9tICcuL21wNC1oZWxwZXJzLmpzJztcbmltcG9ydCB7IGZpbmRFYm1sLCBFQk1MX1RBR1MgfSBmcm9tICcuL2VibWwtaGVscGVycy5qcyc7XG5pbXBvcnQgeyBnZXRJZDNPZmZzZXQgfSBmcm9tICcuL2lkMy1oZWxwZXJzLmpzJztcbmltcG9ydCB7IGZpbmRIMjY0TmFsLCBmaW5kSDI2NU5hbCB9IGZyb20gJy4vbmFsLWhlbHBlcnMuanMnO1xudmFyIENPTlNUQU5UUyA9IHtcbiAgLy8gXCJ3ZWJtXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICd3ZWJtJzogdG9VaW50OChbMHg3NywgMHg2NSwgMHg2MiwgMHg2ZF0pLFxuICAvLyBcIm1hdHJvc2thXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdtYXRyb3NrYSc6IHRvVWludDgoWzB4NmQsIDB4NjEsIDB4NzQsIDB4NzIsIDB4NmYsIDB4NzMsIDB4NmIsIDB4NjFdKSxcbiAgLy8gXCJmTGFDXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdmbGFjJzogdG9VaW50OChbMHg2NiwgMHg0YywgMHg2MSwgMHg0M10pLFxuICAvLyBcIk9nZ1NcIiBzdHJpbmcgbGl0ZXJhbCBpbiBoZXhcbiAgJ29nZyc6IHRvVWludDgoWzB4NGYsIDB4NjcsIDB4NjcsIDB4NTNdKSxcbiAgLy8gYWMtMyBzeW5jIGJ5dGUsIGFsc28gd29ya3MgZm9yIGVjLTMgYXMgdGhhdCBpcyBzaW1wbHkgYSBjb2RlY1xuICAvLyBvZiBhYy0zXG4gICdhYzMnOiB0b1VpbnQ4KFsweDBiLCAweDc3XSksXG4gIC8vIFwiUklGRlwiIHN0cmluZyBsaXRlcmFsIGluIGhleCB1c2VkIGZvciB3YXYgYW5kIGF2aVxuICAncmlmZic6IHRvVWludDgoWzB4NTIsIDB4NDksIDB4NDYsIDB4NDZdKSxcbiAgLy8gXCJBVklcIiBzdHJpbmcgbGl0ZXJhbCBpbiBoZXhcbiAgJ2F2aSc6IHRvVWludDgoWzB4NDEsIDB4NTYsIDB4NDldKSxcbiAgLy8gXCJXQVZFXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICd3YXYnOiB0b1VpbnQ4KFsweDU3LCAweDQxLCAweDU2LCAweDQ1XSksXG4gIC8vIFwiZnR5cDNnXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICczZ3AnOiB0b1VpbnQ4KFsweDY2LCAweDc0LCAweDc5LCAweDcwLCAweDMzLCAweDY3XSksXG4gIC8vIFwiZnR5cFwiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnbXA0JzogdG9VaW50OChbMHg2NiwgMHg3NCwgMHg3OSwgMHg3MF0pLFxuICAvLyBcInN0eXBcIiBzdHJpbmcgbGl0ZXJhbCBpbiBoZXhcbiAgJ2ZtcDQnOiB0b1VpbnQ4KFsweDczLCAweDc0LCAweDc5LCAweDcwXSksXG4gIC8vIFwiZnR5cHF0XCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdtb3YnOiB0b1VpbnQ4KFsweDY2LCAweDc0LCAweDc5LCAweDcwLCAweDcxLCAweDc0XSksXG4gIC8vIG1vb3Ygc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdtb292JzogdG9VaW50OChbMHg2RCwgMHg2RiwgMHg2RiwgMHg3Nl0pLFxuICAvLyBtb29mIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnbW9vZic6IHRvVWludDgoWzB4NkQsIDB4NkYsIDB4NkYsIDB4NjZdKVxufTtcbnZhciBfaXNMaWtlbHkgPSB7XG4gIGFhYzogZnVuY3Rpb24gYWFjKGJ5dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IGdldElkM09mZnNldChieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzTWF0Y2goYnl0ZXMsIFsweEZGLCAweDEwXSwge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBtYXNrOiBbMHhGRiwgMHgxNl1cbiAgICB9KTtcbiAgfSxcbiAgbXAzOiBmdW5jdGlvbiBtcDMoYnl0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZ2V0SWQzT2Zmc2V0KGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXNNYXRjaChieXRlcywgWzB4RkYsIDB4MDJdLCB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIG1hc2s6IFsweEZGLCAweDA2XVxuICAgIH0pO1xuICB9LFxuICB3ZWJtOiBmdW5jdGlvbiB3ZWJtKGJ5dGVzKSB7XG4gICAgdmFyIGRvY1R5cGUgPSBmaW5kRWJtbChieXRlcywgW0VCTUxfVEFHUy5FQk1MLCBFQk1MX1RBR1MuRG9jVHlwZV0pWzBdOyAvLyBjaGVjayBpZiBEb2NUeXBlIEVCTUwgdGFnIGlzIHdlYm1cblxuICAgIHJldHVybiBieXRlc01hdGNoKGRvY1R5cGUsIENPTlNUQU5UUy53ZWJtKTtcbiAgfSxcbiAgbWt2OiBmdW5jdGlvbiBta3YoYnl0ZXMpIHtcbiAgICB2YXIgZG9jVHlwZSA9IGZpbmRFYm1sKGJ5dGVzLCBbRUJNTF9UQUdTLkVCTUwsIEVCTUxfVEFHUy5Eb2NUeXBlXSlbMF07IC8vIGNoZWNrIGlmIERvY1R5cGUgRUJNTCB0YWcgaXMgbWF0cm9za2FcblxuICAgIHJldHVybiBieXRlc01hdGNoKGRvY1R5cGUsIENPTlNUQU5UUy5tYXRyb3NrYSk7XG4gIH0sXG4gIG1wNDogZnVuY3Rpb24gbXA0KGJ5dGVzKSB7XG4gICAgLy8gaWYgdGhpcyBmaWxlIGlzIGFub3RoZXIgYmFzZSBtZWRpYSBmaWxlIGZvcm1hdCwgaXQgaXMgbm90IG1wNFxuICAgIGlmIChfaXNMaWtlbHlbJzNncCddKGJ5dGVzKSB8fCBfaXNMaWtlbHkubW92KGJ5dGVzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGhpcyBmaWxlIHN0YXJ0cyB3aXRoIGEgZnR5cCBvciBzdHlwIGJveCBpdHMgbXA0XG5cblxuICAgIGlmIChieXRlc01hdGNoKGJ5dGVzLCBDT05TVEFOVFMubXA0LCB7XG4gICAgICBvZmZzZXQ6IDRcbiAgICB9KSB8fCBieXRlc01hdGNoKGJ5dGVzLCBDT05TVEFOVFMuZm1wNCwge1xuICAgICAgb2Zmc2V0OiA0XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaWYgdGhpcyBmaWxlIHN0YXJ0cyB3aXRoIGEgbW9vZi9tb292IGJveCBpdHMgbXA0XG5cblxuICAgIGlmIChieXRlc01hdGNoKGJ5dGVzLCBDT05TVEFOVFMubW9vZiwge1xuICAgICAgb2Zmc2V0OiA0XG4gICAgfSkgfHwgYnl0ZXNNYXRjaChieXRlcywgQ09OU1RBTlRTLm1vb3YsIHtcbiAgICAgIG9mZnNldDogNFxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIG1vdjogZnVuY3Rpb24gbW92KGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzTWF0Y2goYnl0ZXMsIENPTlNUQU5UUy5tb3YsIHtcbiAgICAgIG9mZnNldDogNFxuICAgIH0pO1xuICB9LFxuICAnM2dwJzogZnVuY3Rpb24gZ3AoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXNNYXRjaChieXRlcywgQ09OU1RBTlRTWyczZ3AnXSwge1xuICAgICAgb2Zmc2V0OiA0XG4gICAgfSk7XG4gIH0sXG4gIGFjMzogZnVuY3Rpb24gYWMzKGJ5dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IGdldElkM09mZnNldChieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzTWF0Y2goYnl0ZXMsIENPTlNUQU5UUy5hYzMsIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgfSk7XG4gIH0sXG4gIHRzOiBmdW5jdGlvbiB0cyhieXRlcykge1xuICAgIGlmIChieXRlcy5sZW5ndGggPCAxODkgJiYgYnl0ZXMubGVuZ3RoID49IDEpIHtcbiAgICAgIHJldHVybiBieXRlc1swXSA9PT0gMHg0NztcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7IC8vIGNoZWNrIHRoZSBmaXJzdCAzNzYgYnl0ZXMgZm9yIHR3byBtYXRjaGluZyBzeW5jIGJ5dGVzXG5cbiAgICB3aGlsZSAoaSArIDE4OCA8IGJ5dGVzLmxlbmd0aCAmJiBpIDwgMTg4KSB7XG4gICAgICBpZiAoYnl0ZXNbaV0gPT09IDB4NDcgJiYgYnl0ZXNbaSArIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGZsYWM6IGZ1bmN0aW9uIGZsYWMoYnl0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZ2V0SWQzT2Zmc2V0KGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXNNYXRjaChieXRlcywgQ09OU1RBTlRTLmZsYWMsIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgfSk7XG4gIH0sXG4gIG9nZzogZnVuY3Rpb24gb2dnKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzTWF0Y2goYnl0ZXMsIENPTlNUQU5UUy5vZ2cpO1xuICB9LFxuICBhdmk6IGZ1bmN0aW9uIGF2aShieXRlcykge1xuICAgIHJldHVybiBieXRlc01hdGNoKGJ5dGVzLCBDT05TVEFOVFMucmlmZikgJiYgYnl0ZXNNYXRjaChieXRlcywgQ09OU1RBTlRTLmF2aSwge1xuICAgICAgb2Zmc2V0OiA4XG4gICAgfSk7XG4gIH0sXG4gIHdhdjogZnVuY3Rpb24gd2F2KGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzTWF0Y2goYnl0ZXMsIENPTlNUQU5UUy5yaWZmKSAmJiBieXRlc01hdGNoKGJ5dGVzLCBDT05TVEFOVFMud2F2LCB7XG4gICAgICBvZmZzZXQ6IDhcbiAgICB9KTtcbiAgfSxcbiAgJ2gyNjQnOiBmdW5jdGlvbiBoMjY0KGJ5dGVzKSB7XG4gICAgLy8gZmluZCBzZXFfcGFyYW1ldGVyX3NldF9yYnNwXG4gICAgcmV0dXJuIGZpbmRIMjY0TmFsKGJ5dGVzLCA3LCAzKS5sZW5ndGg7XG4gIH0sXG4gICdoMjY1JzogZnVuY3Rpb24gaDI2NShieXRlcykge1xuICAgIC8vIGZpbmQgdmlkZW9fcGFyYW1ldGVyX3NldF9yYnNwIG9yIHNlcV9wYXJhbWV0ZXJfc2V0X3Jic3BcbiAgICByZXR1cm4gZmluZEgyNjVOYWwoYnl0ZXMsIFszMiwgMzNdLCAzKS5sZW5ndGg7XG4gIH1cbn07IC8vIGdldCBhbGwgdGhlIGlzTGlrZWx5IGZ1bmN0aW9uc1xuLy8gYnV0IG1ha2Ugc3VyZSAndHMnIGlzIGFib3ZlIGgyNjQgYW5kIGgyNjVcbi8vIGJ1dCBiZWxvdyBldmVyeXRoaW5nIGVsc2UgYXMgaXQgaXMgdGhlIGxlYXN0IHNwZWNpZmljXG5cbnZhciBpc0xpa2VseVR5cGVzID0gT2JqZWN0LmtleXMoX2lzTGlrZWx5KSAvLyByZW1vdmUgdHMsIGgyNjQsIGgyNjVcbi5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgcmV0dXJuIHQgIT09ICd0cycgJiYgdCAhPT0gJ2gyNjQnICYmIHQgIT09ICdoMjY1Jztcbn0pIC8vIGFkZCBpdCBiYWNrIHRvIHRoZSBib3R0b21cbi5jb25jYXQoWyd0cycsICdoMjY0JywgJ2gyNjUnXSk7IC8vIG1ha2Ugc3VyZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHVpbnQ4IGRhdGEuXG5cbmlzTGlrZWx5VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgaXNMaWtlbHlGbiA9IF9pc0xpa2VseVt0eXBlXTtcblxuICBfaXNMaWtlbHlbdHlwZV0gPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gaXNMaWtlbHlGbih0b1VpbnQ4KGJ5dGVzKSk7XG4gIH07XG59KTsgLy8gZXhwb3J0IGFmdGVyIHdyYXBwaW5nXG5cbmV4cG9ydCB2YXIgaXNMaWtlbHkgPSBfaXNMaWtlbHk7IC8vIEEgdXNlZnVsIGxpc3Qgb2YgZmlsZSBzaWduYXR1cmVzIGNhbiBiZSBmb3VuZCBoZXJlXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX2ZpbGVfc2lnbmF0dXJlc1xuXG5leHBvcnQgdmFyIGRldGVjdENvbnRhaW5lckZvckJ5dGVzID0gZnVuY3Rpb24gZGV0ZWN0Q29udGFpbmVyRm9yQnl0ZXMoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlzTGlrZWx5VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZSA9IGlzTGlrZWx5VHlwZXNbaV07XG5cbiAgICBpZiAoaXNMaWtlbHlbdHlwZV0oYnl0ZXMpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59OyAvLyBmbXA0IGlzIG5vdCBhIGNvbnRhaW5lclxuXG5leHBvcnQgdmFyIGlzTGlrZWx5Rm1wNE1lZGlhU2VnbWVudCA9IGZ1bmN0aW9uIGlzTGlrZWx5Rm1wNE1lZGlhU2VnbWVudChieXRlcykge1xuICByZXR1cm4gZmluZEJveChieXRlcywgWydtb29mJ10pLmxlbmd0aCA+IDA7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/containers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ decodeB64ToUint8Array)\n/* harmony export */ });\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar atob = function atob(s) {\n  return (global_window__WEBPACK_IMPORTED_MODULE_0___default().atob) ? global_window__WEBPACK_IMPORTED_MODULE_0___default().atob(s) : Buffer.from(s, 'base64').toString('binary');\n};\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2RlY29kZS1iNjQtdG8tdWludDgtYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DOztBQUVuQztBQUNBLFNBQVMsMkRBQVcsR0FBRyx5REFBVztBQUNsQzs7QUFFZTtBQUNmO0FBQ0E7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvZXMvZGVjb2RlLWI2NC10by11aW50OC1hcnJheS5qcz9mM2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbnZhciBhdG9iID0gZnVuY3Rpb24gYXRvYihzKSB7XG4gIHJldHVybiB3aW5kb3cuYXRvYiA/IHdpbmRvdy5hdG9iKHMpIDogQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlY29kZUI2NFRvVWludDhBcnJheShiNjRUZXh0KSB7XG4gIHZhciBkZWNvZGVkU3RyaW5nID0gYXRvYihiNjRUZXh0KTtcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZFN0cmluZy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RlZFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gZGVjb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/ebml-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/ebml-helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EBML_TAGS: () => (/* binding */ EBML_TAGS),\n/* harmony export */   decodeBlock: () => (/* binding */ decodeBlock),\n/* harmony export */   findEbml: () => (/* binding */ findEbml),\n/* harmony export */   parseData: () => (/* binding */ parseData),\n/* harmony export */   parseTracks: () => (/* binding */ parseTracks)\n/* harmony export */ });\n/* harmony import */ var _byte_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-helpers */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\");\n/* harmony import */ var _codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codec-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/codec-helpers.js\");\n\n // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nvar EBML_TAGS = {\n  EBML: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x42, 0x82]),\n  Segment: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x16, 0x54, 0xAE, 0x6B]),\n  Track: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xAE]),\n  TrackNumber: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xd7]),\n  DefaultDuration: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x23, 0xe3, 0x83]),\n  TrackEntry: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xAE]),\n  TrackType: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x83]),\n  FlagDefault: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x88]),\n  CodecID: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x86]),\n  CodecPrivate: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x63, 0xA2]),\n  VideoTrack: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xe0]),\n  AudioTrack: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xE7]),\n  TimestampScale: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x2A, 0xD7, 0xB1]),\n  BlockGroup: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xA0]),\n  BlockDuration: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x9B]),\n  Block: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xA1]),\n  SimpleBlock: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.numberToBytes)(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if ((0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nvar findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if ((0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nvar decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nvar parseTracks = function parseTracks(bytes) {\n  bytes = (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToString)(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + (0,_codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getAvcCodec)(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + (0,_codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getHvcCodec)(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(profile, 2, '0') + \".\";\n        codec += (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(level, 2, '0') + \".\";\n        codec += (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(bitDepth, 2, '0') + \".\";\n        codec += \"\" + (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(colourPrimaries[0], 2, '0');\n          codec += \".\" + (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(transferCharacteristics[0], 2, '0');\n          codec += \".\" + (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(matrixCoefficients[0], 2, '0');\n          codec += \".\" + (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.padStart)(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + (0,_codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getAv1Codec)(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nvar parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = (0,_byte_helpers__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2VibWwtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRHO0FBQ2pDLENBQUM7QUFDNUU7QUFDQTtBQUNBOztBQUVPO0FBQ1AsUUFBUSxzREFBTztBQUNmLFdBQVcsc0RBQU87QUFDbEIsV0FBVyxzREFBTztBQUNsQixlQUFlLHNEQUFPO0FBQ3RCLFVBQVUsc0RBQU87QUFDakIsU0FBUyxzREFBTztBQUNoQixlQUFlLHNEQUFPO0FBQ3RCLG1CQUFtQixzREFBTztBQUMxQixjQUFjLHNEQUFPO0FBQ3JCLGFBQWEsc0RBQU87QUFDcEIsZUFBZSxzREFBTztBQUN0QixXQUFXLHNEQUFPO0FBQ2xCLGdCQUFnQixzREFBTztBQUN2QixjQUFjLHNEQUFPO0FBQ3JCLGNBQWMsc0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBTztBQUNsQixhQUFhLHNEQUFPO0FBQ3BCLGtCQUFrQixzREFBTztBQUN6QixjQUFjLHNEQUFPO0FBQ3JCLGlCQUFpQixzREFBTztBQUN4QixTQUFTLHNEQUFPO0FBQ2hCLGVBQWUsc0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNERBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsNERBQWE7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0seURBQVU7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBLFVBQVUsc0RBQU87QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEseURBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVJO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0REFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRCw0RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLHNEQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxnQkFBZ0IsNERBQWE7QUFDN0I7QUFDQTtBQUNBLGNBQWMsNERBQWE7QUFDM0IsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDhEQUFXO0FBQ25DLE1BQU07QUFDTix3QkFBd0IsOERBQVc7QUFDbkMsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdURBQVE7QUFDekIsaUJBQWlCLHVEQUFRO0FBQ3pCLGlCQUFpQix1REFBUTtBQUN6QixzQkFBc0IsdURBQVEsNkJBQTZCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7O0FBRTVGO0FBQ0EseUJBQXlCLHVEQUFRO0FBQ2pDLHlCQUF5Qix1REFBUTtBQUNqQyx5QkFBeUIsdURBQVE7QUFDakMseUJBQXlCLHVEQUFRO0FBQ2pDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCLDhEQUFXO0FBQ25DLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDTztBQUNQO0FBQ0E7QUFDQSxnR0FBZ0c7O0FBRWhHO0FBQ0EscUJBQXFCLDREQUFhO0FBQ2xDLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGtCQUFrQiw0REFBYTtBQUMvQixNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXNuYXBzaG90LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9lcy9lYm1sLWhlbHBlcnMuanM/ZDQ4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b1VpbnQ4LCBieXRlc1RvTnVtYmVyLCBieXRlc01hdGNoLCBieXRlc1RvU3RyaW5nLCBudW1iZXJUb0J5dGVzLCBwYWRTdGFydCB9IGZyb20gJy4vYnl0ZS1oZWxwZXJzJztcbmltcG9ydCB7IGdldEF2Y0NvZGVjLCBnZXRIdmNDb2RlYywgZ2V0QXYxQ29kZWMgfSBmcm9tICcuL2NvZGVjLWhlbHBlcnMuanMnOyAvLyByZWxldmFudCBzcGVjcyBmb3IgdGhpcyBwYXJzZXI6XG4vLyBodHRwczovL21hdHJvc2thLW9yZy5naXRodWIuaW8vbGliZWJtbC9zcGVjcy5odG1sXG4vLyBodHRwczovL3d3dy5tYXRyb3NrYS5vcmcvdGVjaG5pY2FsL2VsZW1lbnRzLmh0bWxcbi8vIGh0dHBzOi8vd3d3LndlYm1wcm9qZWN0Lm9yZy9kb2NzL2NvbnRhaW5lci9cblxuZXhwb3J0IHZhciBFQk1MX1RBR1MgPSB7XG4gIEVCTUw6IHRvVWludDgoWzB4MUEsIDB4NDUsIDB4REYsIDB4QTNdKSxcbiAgRG9jVHlwZTogdG9VaW50OChbMHg0MiwgMHg4Ml0pLFxuICBTZWdtZW50OiB0b1VpbnQ4KFsweDE4LCAweDUzLCAweDgwLCAweDY3XSksXG4gIFNlZ21lbnRJbmZvOiB0b1VpbnQ4KFsweDE1LCAweDQ5LCAweEE5LCAweDY2XSksXG4gIFRyYWNrczogdG9VaW50OChbMHgxNiwgMHg1NCwgMHhBRSwgMHg2Ql0pLFxuICBUcmFjazogdG9VaW50OChbMHhBRV0pLFxuICBUcmFja051bWJlcjogdG9VaW50OChbMHhkN10pLFxuICBEZWZhdWx0RHVyYXRpb246IHRvVWludDgoWzB4MjMsIDB4ZTMsIDB4ODNdKSxcbiAgVHJhY2tFbnRyeTogdG9VaW50OChbMHhBRV0pLFxuICBUcmFja1R5cGU6IHRvVWludDgoWzB4ODNdKSxcbiAgRmxhZ0RlZmF1bHQ6IHRvVWludDgoWzB4ODhdKSxcbiAgQ29kZWNJRDogdG9VaW50OChbMHg4Nl0pLFxuICBDb2RlY1ByaXZhdGU6IHRvVWludDgoWzB4NjMsIDB4QTJdKSxcbiAgVmlkZW9UcmFjazogdG9VaW50OChbMHhlMF0pLFxuICBBdWRpb1RyYWNrOiB0b1VpbnQ4KFsweGUxXSksXG4gIC8vIE5vdCB1c2VkIHlldCwgYnV0IHdpbGwgYmUgdXNlZCBmb3IgbGl2ZSB3ZWJtL21rdlxuICAvLyBzZWUgaHR0cHM6Ly93d3cubWF0cm9za2Eub3JnL3RlY2huaWNhbC9iYXNpY3MuaHRtbCNibG9jay1zdHJ1Y3R1cmVcbiAgLy8gc2VlIGh0dHBzOi8vd3d3Lm1hdHJvc2thLm9yZy90ZWNobmljYWwvYmFzaWNzLmh0bWwjc2ltcGxlYmxvY2stc3RydWN0dXJlXG4gIENsdXN0ZXI6IHRvVWludDgoWzB4MUYsIDB4NDMsIDB4QjYsIDB4NzVdKSxcbiAgVGltZXN0YW1wOiB0b1VpbnQ4KFsweEU3XSksXG4gIFRpbWVzdGFtcFNjYWxlOiB0b1VpbnQ4KFsweDJBLCAweEQ3LCAweEIxXSksXG4gIEJsb2NrR3JvdXA6IHRvVWludDgoWzB4QTBdKSxcbiAgQmxvY2tEdXJhdGlvbjogdG9VaW50OChbMHg5Ql0pLFxuICBCbG9jazogdG9VaW50OChbMHhBMV0pLFxuICBTaW1wbGVCbG9jazogdG9VaW50OChbMHhBM10pXG59O1xuLyoqXG4gKiBUaGlzIGlzIGEgc2ltcGxlIHRhYmxlIHRvIGRldGVybWluZSB0aGUgbGVuZ3RoXG4gKiBvZiB0aGluZ3MgaW4gZWJtbC4gVGhlIGxlbmd0aCBpcyBvbmUgYmFzZWQgKHN0YXJ0cyBhdCAxLFxuICogcmF0aGVyIHRoYW4gemVybykgYW5kIGZvciBldmVyeSB6ZXJvIGJpdCBiZWZvcmUgYSBvbmUgYml0XG4gKiB3ZSBhZGQgb25lIHRvIGxlbmd0aC4gV2UgYWxzbyBuZWVkIHRoaXMgdGFibGUgYmVjYXVzZSBpbiBzb21lXG4gKiBjYXNlIHdlIGhhdmUgdG8geG9yIGFsbCB0aGUgbGVuZ3RoIGJpdHMgZnJvbSBhbm90aGVyIHZhbHVlLlxuICovXG5cbnZhciBMRU5HVEhfVEFCTEUgPSBbMTI4LCA2NCwgMzIsIDE2LCA4LCA0LCAyLCAxXTtcblxudmFyIGdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aChieXRlKSB7XG4gIHZhciBsZW4gPSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTEVOR1RIX1RBQkxFLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ5dGUgJiBMRU5HVEhfVEFCTEVbaV0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxlbisrO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07IC8vIGxlbmd0aCBpbiBlYm1sIGlzIHN0b3JlZCBpbiB0aGUgZmlyc3QgNCB0byA4IGJpdHNcbi8vIG9mIHRoZSBmaXJzdCBieXRlLiA0IGZvciB0aGUgaWQgbGVuZ3RoIGFuZCA4IGZvciB0aGVcbi8vIGRhdGEgc2l6ZSBsZW5ndGguIExlbmd0aCBpcyBtZWFzdXJlZCBieSBjb252ZXJ0aW5nIHRoZSBudW1iZXIgdG8gYmluYXJ5XG4vLyB0aGVuIDEgKyB0aGUgbnVtYmVyIG9mIHplcm9zIGJlZm9yZSBhIDEgaXMgZW5jb3VudGVyZWQgc3RhcnRpbmdcbi8vIGZyb20gdGhlIGxlZnQuXG5cblxudmFyIGdldHZpbnQgPSBmdW5jdGlvbiBnZXR2aW50KGJ5dGVzLCBvZmZzZXQsIHJlbW92ZUxlbmd0aCwgc2lnbmVkKSB7XG4gIGlmIChyZW1vdmVMZW5ndGggPT09IHZvaWQgMCkge1xuICAgIHJlbW92ZUxlbmd0aCA9IHRydWU7XG4gIH1cblxuICBpZiAoc2lnbmVkID09PSB2b2lkIDApIHtcbiAgICBzaWduZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYnl0ZXNbb2Zmc2V0XSk7XG4gIHZhciB2YWx1ZUJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpOyAvLyBOT1RFIHRoYXQgd2UgZG8gKipub3QqKiBzdWJhcnJheSBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjb3B5IHRoZXNlIGJ5dGVzXG4gIC8vIGFzIHRoZXkgd2lsbCBiZSBtb2RpZmllZCBiZWxvdyB0byByZW1vdmUgdGhlIGRhdGFTaXplTGVuIGJpdHMgYW5kIHdlIGRvIG5vdFxuICAvLyB3YW50IHRvIG1vZGlmeSB0aGUgb3JpZ2luYWwgZGF0YS4gbm9ybWFsbHkgd2UgY291bGQganVzdCBjYWxsIHNsaWNlIG9uXG4gIC8vIHVpbnQ4YXJyYXkgYnV0IGllIDExIGRvZXMgbm90IHN1cHBvcnQgdGhhdC4uLlxuXG4gIGlmIChyZW1vdmVMZW5ndGgpIHtcbiAgICB2YWx1ZUJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB2YWx1ZUJ5dGVzWzBdIF49IExFTkdUSF9UQUJMRVtsZW5ndGggLSAxXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgdmFsdWU6IGJ5dGVzVG9OdW1iZXIodmFsdWVCeXRlcywge1xuICAgICAgc2lnbmVkOiBzaWduZWRcbiAgICB9KSxcbiAgICBieXRlczogdmFsdWVCeXRlc1xuICB9O1xufTtcblxudmFyIG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXRoLm1hdGNoKC8uezEsMn0vZykubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyhwYXRoKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufTtcblxudmFyIG5vcm1hbGl6ZVBhdGhzID0gZnVuY3Rpb24gbm9ybWFsaXplUGF0aHMocGF0aHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHJldHVybiBbbm9ybWFsaXplUGF0aChwYXRocyldO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBub3JtYWxpemVQYXRoKHApO1xuICB9KTtcbn07XG5cbnZhciBnZXRJbmZpbml0eURhdGFTaXplID0gZnVuY3Rpb24gZ2V0SW5maW5pdHlEYXRhU2l6ZShpZCwgYnl0ZXMsIG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBieXRlcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgaW5uZXJpZCA9IGdldHZpbnQoYnl0ZXMsIG9mZnNldCwgZmFsc2UpO1xuXG4gIGlmIChieXRlc01hdGNoKGlkLmJ5dGVzLCBpbm5lcmlkLmJ5dGVzKSkge1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICB2YXIgZGF0YUhlYWRlciA9IGdldHZpbnQoYnl0ZXMsIG9mZnNldCArIGlubmVyaWQubGVuZ3RoKTtcbiAgcmV0dXJuIGdldEluZmluaXR5RGF0YVNpemUoaWQsIGJ5dGVzLCBvZmZzZXQgKyBkYXRhSGVhZGVyLmxlbmd0aCArIGRhdGFIZWFkZXIudmFsdWUgKyBpbm5lcmlkLmxlbmd0aCk7XG59O1xuLyoqXG4gKiBOb3RlcyBvbiB0aGUgRUJMTSBmb3JtYXQuXG4gKlxuICogRUJMTSB1c2VzIFwidmludHNcIiB0YWdzLiBFdmVyeSB2aW50IHRhZyBjb250YWluc1xuICogdHdvIHBhcnRzXG4gKlxuICogMS4gVGhlIGxlbmd0aCBmcm9tIHRoZSBmaXJzdCBieXRlLiBZb3UgZ2V0IHRoaXMgYnlcbiAqICAgIGNvbnZlcnRpbmcgdGhlIGJ5dGUgdG8gYmluYXJ5IGFuZCBjb3VudGluZyB0aGUgemVyb3NcbiAqICAgIGJlZm9yZSBhIDEuIFRoZW4geW91IGFkZCAxIHRvIHRoYXQuIEV4YW1wbGVzXG4gKiAgICAwMDAxMTExMSA9IGxlbmd0aCA0IGJlY2F1c2UgdGhlcmUgYXJlIDMgemVyb3MgYmVmb3JlIGEgMS5cbiAqICAgIDAwMTAwMDAwID0gbGVuZ3RoIDMgYmVjYXVzZSB0aGVyZSBhcmUgMiB6ZXJvcyBiZWZvcmUgYSAxLlxuICogICAgMDAwMDAwMTEgPSBsZW5ndGggNyBiZWNhdXNlIHRoZXJlIGFyZSA2IHplcm9zIGJlZm9yZSBhIDEuXG4gKlxuICogMi4gVGhlIGJpdHMgdXNlZCBmb3IgbGVuZ3RoIGFyZSByZW1vdmVkIGZyb20gdGhlIGZpcnN0IGJ5dGVcbiAqICAgIFRoZW4gYWxsIHRoZSBieXRlcyBhcmUgbWVyZ2VkIGludG8gYSB2YWx1ZS4gTk9URTogdGhpc1xuICogICAgaXMgbm90IHRoZSBjYXNlIGZvciBpZCBlYm1sIHRhZ3MgYXMgdGhlcmUgaWQgaW5jbHVkZXNcbiAqICAgIGxlbmd0aCBiaXRzLlxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgZmluZEVibWwgPSBmdW5jdGlvbiBmaW5kRWJtbChieXRlcywgcGF0aHMpIHtcbiAgcGF0aHMgPSBub3JtYWxpemVQYXRocyhwYXRocyk7XG4gIGJ5dGVzID0gdG9VaW50OChieXRlcyk7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIHZhciBpZCA9IGdldHZpbnQoYnl0ZXMsIGksIGZhbHNlKTtcbiAgICB2YXIgZGF0YUhlYWRlciA9IGdldHZpbnQoYnl0ZXMsIGkgKyBpZC5sZW5ndGgpO1xuICAgIHZhciBkYXRhU3RhcnQgPSBpICsgaWQubGVuZ3RoICsgZGF0YUhlYWRlci5sZW5ndGg7IC8vIGRhdGFTaXplIGlzIHVua25vd24gb3IgdGhpcyBpcyBhIGxpdmUgc3RyZWFtXG5cbiAgICBpZiAoZGF0YUhlYWRlci52YWx1ZSA9PT0gMHg3Zikge1xuICAgICAgZGF0YUhlYWRlci52YWx1ZSA9IGdldEluZmluaXR5RGF0YVNpemUoaWQsIGJ5dGVzLCBkYXRhU3RhcnQpO1xuXG4gICAgICBpZiAoZGF0YUhlYWRlci52YWx1ZSAhPT0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFIZWFkZXIudmFsdWUgLT0gZGF0YVN0YXJ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRhRW5kID0gZGF0YVN0YXJ0ICsgZGF0YUhlYWRlci52YWx1ZSA+IGJ5dGVzLmxlbmd0aCA/IGJ5dGVzLmxlbmd0aCA6IGRhdGFTdGFydCArIGRhdGFIZWFkZXIudmFsdWU7XG4gICAgdmFyIGRhdGEgPSBieXRlcy5zdWJhcnJheShkYXRhU3RhcnQsIGRhdGFFbmQpO1xuXG4gICAgaWYgKGJ5dGVzTWF0Y2gocGF0aHNbMF0sIGlkLmJ5dGVzKSkge1xuICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGhzIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgdGFnIHdlIHdlcmVcbiAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCB0YWcgaW5zaWRlIG9mIHRoZSBkYXRhXG4gICAgICAgIC8vIG9mIHRoaXMgb25lXG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChmaW5kRWJtbChkYXRhLCBwYXRocy5zbGljZSgxKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlkLmxlbmd0aCArIGRhdGFIZWFkZXIubGVuZ3RoICsgZGF0YS5sZW5ndGg7IC8vIG1vdmUgcGFzdCB0aGlzIHRhZyBlbnRpcmVseSwgd2UgYXJlIG5vdCBsb29raW5nIGZvciBpdFxuXG4gICAgaSArPSB0b3RhbExlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTsgLy8gc2VlIGh0dHBzOi8vd3d3Lm1hdHJvc2thLm9yZy90ZWNobmljYWwvYmFzaWNzLmh0bWwjYmxvY2stc3RydWN0dXJlXG5cbmV4cG9ydCB2YXIgZGVjb2RlQmxvY2sgPSBmdW5jdGlvbiBkZWNvZGVCbG9jayhibG9jaywgdHlwZSwgdGltZXN0YW1wU2NhbGUsIGNsdXN0ZXJUaW1lc3RhbXApIHtcbiAgdmFyIGR1cmF0aW9uO1xuXG4gIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgZHVyYXRpb24gPSBmaW5kRWJtbChibG9jaywgW0VCTUxfVEFHUy5CbG9ja0R1cmF0aW9uXSlbMF07XG5cbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uID0gYnl0ZXNUb051bWJlcihkdXJhdGlvbik7XG4gICAgICBkdXJhdGlvbiA9IDEgLyB0aW1lc3RhbXBTY2FsZSAqIGR1cmF0aW9uICogdGltZXN0YW1wU2NhbGUgLyAxMDAwO1xuICAgIH1cblxuICAgIGJsb2NrID0gZmluZEVibWwoYmxvY2ssIFtFQk1MX1RBR1MuQmxvY2tdKVswXTtcbiAgICB0eXBlID0gJ2Jsb2NrJzsgLy8gdHJlYXQgZGF0YSBhcyBhIGJsb2NrIGFmdGVyIHRoaXMgcG9pbnRcbiAgfVxuXG4gIHZhciBkdiA9IG5ldyBEYXRhVmlldyhibG9jay5idWZmZXIsIGJsb2NrLmJ5dGVPZmZzZXQsIGJsb2NrLmJ5dGVMZW5ndGgpO1xuICB2YXIgdHJhY2tOdW1iZXIgPSBnZXR2aW50KGJsb2NrLCAwKTtcbiAgdmFyIHRpbWVzdGFtcCA9IGR2LmdldEludDE2KHRyYWNrTnVtYmVyLmxlbmd0aCwgZmFsc2UpO1xuICB2YXIgZmxhZ3MgPSBibG9ja1t0cmFja051bWJlci5sZW5ndGggKyAyXTtcbiAgdmFyIGRhdGEgPSBibG9jay5zdWJhcnJheSh0cmFja051bWJlci5sZW5ndGggKyAzKTsgLy8gcHRzL2R0cyBpbiBzZWNvbmRzXG5cbiAgdmFyIHB0c2R0cyA9IDEgLyB0aW1lc3RhbXBTY2FsZSAqIChjbHVzdGVyVGltZXN0YW1wICsgdGltZXN0YW1wKSAqIHRpbWVzdGFtcFNjYWxlIC8gMTAwMDsgLy8gcmV0dXJuIHRoZSBmcmFtZVxuXG4gIHZhciBwYXJzZWQgPSB7XG4gICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgIHRyYWNrTnVtYmVyOiB0cmFja051bWJlci52YWx1ZSxcbiAgICBrZXlmcmFtZTogdHlwZSA9PT0gJ3NpbXBsZScgJiYgZmxhZ3MgPj4gNyA9PT0gMSxcbiAgICBpbnZpc2libGU6IChmbGFncyAmIDB4MDgpID4+IDMgPT09IDEsXG4gICAgbGFjaW5nOiAoZmxhZ3MgJiAweDA2KSA+PiAxLFxuICAgIGRpc2NhcmRhYmxlOiB0eXBlID09PSAnc2ltcGxlJyAmJiAoZmxhZ3MgJiAweDAxKSA9PT0gMSxcbiAgICBmcmFtZXM6IFtdLFxuICAgIHB0czogcHRzZHRzLFxuICAgIGR0czogcHRzZHRzLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gIH07XG5cbiAgaWYgKCFwYXJzZWQubGFjaW5nKSB7XG4gICAgcGFyc2VkLmZyYW1lcy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgbnVtYmVyT2ZGcmFtZXMgPSBkYXRhWzBdICsgMTtcbiAgdmFyIGZyYW1lU2l6ZXMgPSBbXTtcbiAgdmFyIG9mZnNldCA9IDE7IC8vIEZpeGVkXG5cbiAgaWYgKHBhcnNlZC5sYWNpbmcgPT09IDIpIHtcbiAgICB2YXIgc2l6ZU9mRnJhbWUgPSAoZGF0YS5sZW5ndGggLSBvZmZzZXQpIC8gbnVtYmVyT2ZGcmFtZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mRnJhbWVzOyBpKyspIHtcbiAgICAgIGZyYW1lU2l6ZXMucHVzaChzaXplT2ZGcmFtZSk7XG4gICAgfVxuICB9IC8vIHhpcGhcblxuXG4gIGlmIChwYXJzZWQubGFjaW5nID09PSAxKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bWJlck9mRnJhbWVzIC0gMTsgX2krKykge1xuICAgICAgdmFyIHNpemUgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHNpemUgKz0gZGF0YVtvZmZzZXRdO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gd2hpbGUgKGRhdGFbb2Zmc2V0IC0gMV0gPT09IDB4RkYpO1xuXG4gICAgICBmcmFtZVNpemVzLnB1c2goc2l6ZSk7XG4gICAgfVxuICB9IC8vIGVibWxcblxuXG4gIGlmIChwYXJzZWQubGFjaW5nID09PSAzKSB7XG4gICAgLy8gZmlyc3QgdmludCBpcyB1bnNpbmdlZFxuICAgIC8vIGFmdGVyIHRoYXQgdmludHMgYXJlIHNpbmdlZCBhbmRcbiAgICAvLyBiYXNlZCBvbiBhIGNvbXBvdW5kaW5nIHNpemVcbiAgICB2YXIgX3NpemUgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbnVtYmVyT2ZGcmFtZXMgLSAxOyBfaTIrKykge1xuICAgICAgdmFyIHZpbnQgPSBfaTIgPT09IDAgPyBnZXR2aW50KGRhdGEsIG9mZnNldCkgOiBnZXR2aW50KGRhdGEsIG9mZnNldCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBfc2l6ZSArPSB2aW50LnZhbHVlO1xuICAgICAgZnJhbWVTaXplcy5wdXNoKF9zaXplKTtcbiAgICAgIG9mZnNldCArPSB2aW50Lmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBmcmFtZVNpemVzLmZvckVhY2goZnVuY3Rpb24gKHNpemUpIHtcbiAgICBwYXJzZWQuZnJhbWVzLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpKTtcbiAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgfSk7XG4gIHJldHVybiBwYXJzZWQ7XG59OyAvLyBWUDkgQ29kZWMgRmVhdHVyZSBNZXRhZGF0YSAoQ29kZWNQcml2YXRlKVxuLy8gaHR0cHM6Ly93d3cud2VibXByb2plY3Qub3JnL2RvY3MvY29udGFpbmVyL1xuXG52YXIgcGFyc2VWcDlQcml2YXRlID0gZnVuY3Rpb24gcGFyc2VWcDlQcml2YXRlKGJ5dGVzKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlkID0gYnl0ZXNbaV0gJiAweDdmO1xuICAgIHZhciBsZW4gPSBieXRlc1tpICsgMV07XG4gICAgdmFyIHZhbCA9IHZvaWQgMDtcblxuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIHZhbCA9IGJ5dGVzW2kgKyAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gYnl0ZXMuc3ViYXJyYXkoaSArIDIsIGkgKyAyICsgbGVuKTtcbiAgICB9XG5cbiAgICBpZiAoaWQgPT09IDEpIHtcbiAgICAgIHBhcmFtcy5wcm9maWxlID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoaWQgPT09IDIpIHtcbiAgICAgIHBhcmFtcy5sZXZlbCA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKGlkID09PSAzKSB7XG4gICAgICBwYXJhbXMuYml0RGVwdGggPSB2YWw7XG4gICAgfSBlbHNlIGlmIChpZCA9PT0gNCkge1xuICAgICAgcGFyYW1zLmNocm9tYVN1YnNhbXBsaW5nID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXNbaWRdID0gdmFsO1xuICAgIH1cblxuICAgIGkgKz0gMiArIGxlbjtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG5leHBvcnQgdmFyIHBhcnNlVHJhY2tzID0gZnVuY3Rpb24gcGFyc2VUcmFja3MoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIGRlY29kZWRUcmFja3MgPSBbXTtcbiAgdmFyIHRyYWNrcyA9IGZpbmRFYm1sKGJ5dGVzLCBbRUJNTF9UQUdTLlNlZ21lbnQsIEVCTUxfVEFHUy5UcmFja3MsIEVCTUxfVEFHUy5UcmFja10pO1xuXG4gIGlmICghdHJhY2tzLmxlbmd0aCkge1xuICAgIHRyYWNrcyA9IGZpbmRFYm1sKGJ5dGVzLCBbRUJNTF9UQUdTLlRyYWNrcywgRUJNTF9UQUdTLlRyYWNrXSk7XG4gIH1cblxuICBpZiAoIXRyYWNrcy5sZW5ndGgpIHtcbiAgICB0cmFja3MgPSBmaW5kRWJtbChieXRlcywgW0VCTUxfVEFHUy5UcmFja10pO1xuICB9XG5cbiAgaWYgKCF0cmFja3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRlY29kZWRUcmFja3M7XG4gIH1cblxuICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgdHJhY2tUeXBlID0gZmluZEVibWwodHJhY2ssIEVCTUxfVEFHUy5UcmFja1R5cGUpWzBdO1xuXG4gICAgaWYgKCF0cmFja1R5cGUgfHwgIXRyYWNrVHlwZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIDEgaXMgdmlkZW8sIDIgaXMgYXVkaW8sIDE3IGlzIHN1YnRpdGxlXG4gICAgLy8gb3RoZXIgdmFsdWVzIGFyZSB1bmltcG9ydGFudCBpbiB0aGlzIGNvbnRleHRcblxuXG4gICAgaWYgKHRyYWNrVHlwZVswXSA9PT0gMSkge1xuICAgICAgdHJhY2tUeXBlID0gJ3ZpZGVvJztcbiAgICB9IGVsc2UgaWYgKHRyYWNrVHlwZVswXSA9PT0gMikge1xuICAgICAgdHJhY2tUeXBlID0gJ2F1ZGlvJztcbiAgICB9IGVsc2UgaWYgKHRyYWNrVHlwZVswXSA9PT0gMTcpIHtcbiAgICAgIHRyYWNrVHlwZSA9ICdzdWJ0aXRsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHRvZG8gcGFyc2UgbGFuZ3VhZ2VcblxuXG4gICAgdmFyIGRlY29kZWRUcmFjayA9IHtcbiAgICAgIHJhd0NvZGVjOiBieXRlc1RvU3RyaW5nKGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkNvZGVjSURdKVswXSksXG4gICAgICB0eXBlOiB0cmFja1R5cGUsXG4gICAgICBjb2RlY1ByaXZhdGU6IGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkNvZGVjUHJpdmF0ZV0pWzBdLFxuICAgICAgbnVtYmVyOiBieXRlc1RvTnVtYmVyKGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLlRyYWNrTnVtYmVyXSlbMF0pLFxuICAgICAgZGVmYXVsdER1cmF0aW9uOiBieXRlc1RvTnVtYmVyKGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkRlZmF1bHREdXJhdGlvbl0pWzBdKSxcbiAgICAgIGRlZmF1bHQ6IGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkZsYWdEZWZhdWx0XSlbMF0sXG4gICAgICByYXdEYXRhOiB0cmFja1xuICAgIH07XG4gICAgdmFyIGNvZGVjID0gJyc7XG5cbiAgICBpZiAoL1ZfTVBFRzRcXC9JU09cXC9BVkMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSBcImF2YzEuXCIgKyBnZXRBdmNDb2RlYyhkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlKTtcbiAgICB9IGVsc2UgaWYgKC9WX01QRUdIXFwvSVNPXFwvSEVWQy8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9IFwiaGV2MS5cIiArIGdldEh2Y0NvZGVjKGRlY29kZWRUcmFjay5jb2RlY1ByaXZhdGUpO1xuICAgIH0gZWxzZSBpZiAoL1ZfTVBFRzRcXC9JU09cXC9BU1AvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgaWYgKGRlY29kZWRUcmFjay5jb2RlY1ByaXZhdGUpIHtcbiAgICAgICAgY29kZWMgPSAnbXA0di4yMC4nICsgZGVjb2RlZFRyYWNrLmNvZGVjUHJpdmF0ZVs0XS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZWMgPSAnbXA0di4yMC45JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9eVl9USEVPUkEvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAndGhlb3JhJztcbiAgICB9IGVsc2UgaWYgKC9eVl9WUDgvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAndnA4JztcbiAgICB9IGVsc2UgaWYgKC9eVl9WUDkvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgaWYgKGRlY29kZWRUcmFjay5jb2RlY1ByaXZhdGUpIHtcbiAgICAgICAgdmFyIF9wYXJzZVZwOVByaXZhdGUgPSBwYXJzZVZwOVByaXZhdGUoZGVjb2RlZFRyYWNrLmNvZGVjUHJpdmF0ZSksXG4gICAgICAgICAgICBwcm9maWxlID0gX3BhcnNlVnA5UHJpdmF0ZS5wcm9maWxlLFxuICAgICAgICAgICAgbGV2ZWwgPSBfcGFyc2VWcDlQcml2YXRlLmxldmVsLFxuICAgICAgICAgICAgYml0RGVwdGggPSBfcGFyc2VWcDlQcml2YXRlLmJpdERlcHRoLFxuICAgICAgICAgICAgY2hyb21hU3Vic2FtcGxpbmcgPSBfcGFyc2VWcDlQcml2YXRlLmNocm9tYVN1YnNhbXBsaW5nO1xuXG4gICAgICAgIGNvZGVjID0gJ3ZwMDkuJztcbiAgICAgICAgY29kZWMgKz0gcGFkU3RhcnQocHJvZmlsZSwgMiwgJzAnKSArIFwiLlwiO1xuICAgICAgICBjb2RlYyArPSBwYWRTdGFydChsZXZlbCwgMiwgJzAnKSArIFwiLlwiO1xuICAgICAgICBjb2RlYyArPSBwYWRTdGFydChiaXREZXB0aCwgMiwgJzAnKSArIFwiLlwiO1xuICAgICAgICBjb2RlYyArPSBcIlwiICsgcGFkU3RhcnQoY2hyb21hU3Vic2FtcGxpbmcsIDIsICcwJyk7IC8vIFZpZGVvIC0+IENvbG91ciAtPiBFYm1sIG5hbWVcblxuICAgICAgICB2YXIgbWF0cml4Q29lZmZpY2llbnRzID0gZmluZEVibWwodHJhY2ssIFsweEUwLCBbMHg1NSwgMHhCMF0sIFsweDU1LCAweEIxXV0pWzBdIHx8IFtdO1xuICAgICAgICB2YXIgdmlkZW9GdWxsUmFuZ2VGbGFnID0gZmluZEVibWwodHJhY2ssIFsweEUwLCBbMHg1NSwgMHhCMF0sIFsweDU1LCAweEI5XV0pWzBdIHx8IFtdO1xuICAgICAgICB2YXIgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSBmaW5kRWJtbCh0cmFjaywgWzB4RTAsIFsweDU1LCAweEIwXSwgWzB4NTUsIDB4QkFdXSlbMF0gfHwgW107XG4gICAgICAgIHZhciBjb2xvdXJQcmltYXJpZXMgPSBmaW5kRWJtbCh0cmFjaywgWzB4RTAsIFsweDU1LCAweEIwXSwgWzB4NTUsIDB4QkJdXSlbMF0gfHwgW107IC8vIGlmIHdlIGZpbmQgYW55IG9wdGlvbmFsIGNvZGVjIHBhcmFtZXRlciBzcGVjaWZ5IHRoZW0gYWxsLlxuXG4gICAgICAgIGlmIChtYXRyaXhDb2VmZmljaWVudHMubGVuZ3RoIHx8IHZpZGVvRnVsbFJhbmdlRmxhZy5sZW5ndGggfHwgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MubGVuZ3RoIHx8IGNvbG91clByaW1hcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb2RlYyArPSBcIi5cIiArIHBhZFN0YXJ0KGNvbG91clByaW1hcmllc1swXSwgMiwgJzAnKTtcbiAgICAgICAgICBjb2RlYyArPSBcIi5cIiArIHBhZFN0YXJ0KHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzWzBdLCAyLCAnMCcpO1xuICAgICAgICAgIGNvZGVjICs9IFwiLlwiICsgcGFkU3RhcnQobWF0cml4Q29lZmZpY2llbnRzWzBdLCAyLCAnMCcpO1xuICAgICAgICAgIGNvZGVjICs9IFwiLlwiICsgcGFkU3RhcnQodmlkZW9GdWxsUmFuZ2VGbGFnWzBdLCAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlYyA9ICd2cDknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL15WX0FWMS8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9IFwiYXYwMS5cIiArIGdldEF2MUNvZGVjKGRlY29kZWRUcmFjay5jb2RlY1ByaXZhdGUpO1xuICAgIH0gZWxzZSBpZiAoL0FfQUxBQy8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICdhbGFjJztcbiAgICB9IGVsc2UgaWYgKC9BX01QRUdcXC9MMi8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICdtcDInO1xuICAgIH0gZWxzZSBpZiAoL0FfTVBFR1xcL0wzLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ21wMyc7XG4gICAgfSBlbHNlIGlmICgvXkFfQUFDLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGlmIChkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlKSB7XG4gICAgICAgIGNvZGVjID0gJ21wNGEuNDAuJyArIChkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlWzBdID4+PiAzKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9eQV9BQzMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAnYWMtMyc7XG4gICAgfSBlbHNlIGlmICgvXkFfUENNLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ3BjbSc7XG4gICAgfSBlbHNlIGlmICgvXkFfTVNcXC9BQ00vLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAnc3BlZXgnO1xuICAgIH0gZWxzZSBpZiAoL15BX0VBQzMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAnZWMtMyc7XG4gICAgfSBlbHNlIGlmICgvXkFfVk9SQklTLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ3ZvcmJpcyc7XG4gICAgfSBlbHNlIGlmICgvXkFfRkxBQy8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICdmbGFjJztcbiAgICB9IGVsc2UgaWYgKC9eQV9PUFVTLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ29wdXMnO1xuICAgIH1cblxuICAgIGRlY29kZWRUcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIGRlY29kZWRUcmFja3MucHVzaChkZWNvZGVkVHJhY2spO1xuICB9KTtcbiAgcmV0dXJuIGRlY29kZWRUcmFja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLm51bWJlciAtIGIubnVtYmVyO1xuICB9KTtcbn07XG5leHBvcnQgdmFyIHBhcnNlRGF0YSA9IGZ1bmN0aW9uIHBhcnNlRGF0YShkYXRhLCB0cmFja3MpIHtcbiAgdmFyIGFsbEJsb2NrcyA9IFtdO1xuICB2YXIgc2VnbWVudCA9IGZpbmRFYm1sKGRhdGEsIFtFQk1MX1RBR1MuU2VnbWVudF0pWzBdO1xuICB2YXIgdGltZXN0YW1wU2NhbGUgPSBmaW5kRWJtbChzZWdtZW50LCBbRUJNTF9UQUdTLlNlZ21lbnRJbmZvLCBFQk1MX1RBR1MuVGltZXN0YW1wU2NhbGVdKVswXTsgLy8gaW4gbmFub3NlY29uZHMsIGRlZmF1bHRzIHRvIDFtc1xuXG4gIGlmICh0aW1lc3RhbXBTY2FsZSAmJiB0aW1lc3RhbXBTY2FsZS5sZW5ndGgpIHtcbiAgICB0aW1lc3RhbXBTY2FsZSA9IGJ5dGVzVG9OdW1iZXIodGltZXN0YW1wU2NhbGUpO1xuICB9IGVsc2Uge1xuICAgIHRpbWVzdGFtcFNjYWxlID0gMTAwMDAwMDtcbiAgfVxuXG4gIHZhciBjbHVzdGVycyA9IGZpbmRFYm1sKHNlZ21lbnQsIFtFQk1MX1RBR1MuQ2x1c3Rlcl0pO1xuXG4gIGlmICghdHJhY2tzKSB7XG4gICAgdHJhY2tzID0gcGFyc2VUcmFja3Moc2VnbWVudCk7XG4gIH1cblxuICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBjaSkge1xuICAgIHZhciBzaW1wbGVCbG9ja3MgPSBmaW5kRWJtbChjbHVzdGVyLCBbRUJNTF9UQUdTLlNpbXBsZUJsb2NrXSkubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc2ltcGxlJyxcbiAgICAgICAgZGF0YTogYlxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tHcm91cHMgPSBmaW5kRWJtbChjbHVzdGVyLCBbRUJNTF9UQUdTLkJsb2NrR3JvdXBdKS5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgIGRhdGE6IGJcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHRpbWVzdGFtcCA9IGZpbmRFYm1sKGNsdXN0ZXIsIFtFQk1MX1RBR1MuVGltZXN0YW1wXSlbMF0gfHwgMDtcblxuICAgIGlmICh0aW1lc3RhbXAgJiYgdGltZXN0YW1wLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wID0gYnl0ZXNUb051bWJlcih0aW1lc3RhbXApO1xuICAgIH0gLy8gZ2V0IGFsbCBibG9ja3MgdGhlbiBzb3J0IHRoZW0gaW50byB0aGUgY29ycmVjdCBvcmRlclxuXG5cbiAgICB2YXIgYmxvY2tzID0gc2ltcGxlQmxvY2tzLmNvbmNhdChibG9ja0dyb3Vwcykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuZGF0YS5ieXRlT2Zmc2V0IC0gYi5kYXRhLmJ5dGVPZmZzZXQ7XG4gICAgfSk7XG4gICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrLCBiaSkge1xuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVCbG9jayhibG9jay5kYXRhLCBibG9jay50eXBlLCB0aW1lc3RhbXBTY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgIGFsbEJsb2Nrcy5wdXNoKGRlY29kZWQpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0cmFja3M6IHRyYWNrcyxcbiAgICBibG9ja3M6IGFsbEJsb2Nrc1xuICB9O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/ebml-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/id3-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/id3-helpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getId3Offset: () => (/* binding */ getId3Offset),\n/* harmony export */   getId3Size: () => (/* binding */ getId3Size)\n/* harmony export */ });\n/* harmony import */ var _byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\");\n\nvar ID3 = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x49, 0x44, 0x33]);\nvar getId3Size = function getId3Size(bytes, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  var flags = bytes[offset + 5];\n  var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];\n  var footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n\n  return returnSize + 10;\n};\nvar getId3Offset = function getId3Offset(bytes, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n\n  if (bytes.length - offset < 10 || !(0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes, ID3, {\n    offset: offset\n  })) {\n    return offset;\n  }\n\n  offset += getId3Size(bytes, offset); // recursive check for id3 tags as some files\n  // have multiple ID3 tag sections even though\n  // they should not.\n\n  return getId3Offset(bytes, offset);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2lkMy1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUN4RCxVQUFVLHlEQUFPO0FBQ1Y7QUFDUDtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx5REFBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHlEQUFPOztBQUVqQixxQ0FBcUMsNERBQVU7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL2lkMy1oZWxwZXJzLmpzP2E4Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9VaW50OCwgYnl0ZXNNYXRjaCB9IGZyb20gJy4vYnl0ZS1oZWxwZXJzLmpzJztcbnZhciBJRDMgPSB0b1VpbnQ4KFsweDQ5LCAweDQ0LCAweDMzXSk7XG5leHBvcnQgdmFyIGdldElkM1NpemUgPSBmdW5jdGlvbiBnZXRJZDNTaXplKGJ5dGVzLCBvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGJ5dGVzID0gdG9VaW50OChieXRlcyk7XG4gIHZhciBmbGFncyA9IGJ5dGVzW29mZnNldCArIDVdO1xuICB2YXIgcmV0dXJuU2l6ZSA9IGJ5dGVzW29mZnNldCArIDZdIDw8IDIxIHwgYnl0ZXNbb2Zmc2V0ICsgN10gPDwgMTQgfCBieXRlc1tvZmZzZXQgKyA4XSA8PCA3IHwgYnl0ZXNbb2Zmc2V0ICsgOV07XG4gIHZhciBmb290ZXJQcmVzZW50ID0gKGZsYWdzICYgMTYpID4+IDQ7XG5cbiAgaWYgKGZvb3RlclByZXNlbnQpIHtcbiAgICByZXR1cm4gcmV0dXJuU2l6ZSArIDIwO1xuICB9XG5cbiAgcmV0dXJuIHJldHVyblNpemUgKyAxMDtcbn07XG5leHBvcnQgdmFyIGdldElkM09mZnNldCA9IGZ1bmN0aW9uIGdldElkM09mZnNldChieXRlcywgb2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IHZvaWQgMCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cblxuICBieXRlcyA9IHRvVWludDgoYnl0ZXMpO1xuXG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPCAxMCB8fCAhYnl0ZXNNYXRjaChieXRlcywgSUQzLCB7XG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfSkpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgb2Zmc2V0ICs9IGdldElkM1NpemUoYnl0ZXMsIG9mZnNldCk7IC8vIHJlY3Vyc2l2ZSBjaGVjayBmb3IgaWQzIHRhZ3MgYXMgc29tZSBmaWxlc1xuICAvLyBoYXZlIG11bHRpcGxlIElEMyB0YWcgc2VjdGlvbnMgZXZlbiB0aG91Z2hcbiAgLy8gdGhleSBzaG91bGQgbm90LlxuXG4gIHJldHVybiBnZXRJZDNPZmZzZXQoYnl0ZXMsIG9mZnNldCk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/id3-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/media-groups.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/media-groups.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   forEachMediaGroup: () => (/* binding */ forEachMediaGroup)\n/* harmony export */ });\n/**\n * Loops through all supported media groups in master and calls the provided\n * callback for each group\n *\n * @param {Object} master\n *        The parsed master manifest object\n * @param {string[]} groups\n *        The media groups to call the callback for\n * @param {Function} callback\n *        Callback to call for each media group\n */\nvar forEachMediaGroup = function forEachMediaGroup(master, groups, callback) {\n  groups.forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n        callback(mediaProperties, mediaType, groupKey, labelKey);\n      }\n    }\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL21lZGlhLWdyb3Vwcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvZXMvbWVkaWEtZ3JvdXBzLmpzPzIwYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFsbCBzdXBwb3J0ZWQgbWVkaWEgZ3JvdXBzIGluIG1hc3RlciBhbmQgY2FsbHMgdGhlIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBmb3IgZWFjaCBncm91cFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXN0ZXJcbiAqICAgICAgICBUaGUgcGFyc2VkIG1hc3RlciBtYW5pZmVzdCBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdyb3Vwc1xuICogICAgICAgIFRoZSBtZWRpYSBncm91cHMgdG8gY2FsbCB0aGUgY2FsbGJhY2sgZm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogICAgICAgIENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggbWVkaWEgZ3JvdXBcbiAqL1xuZXhwb3J0IHZhciBmb3JFYWNoTWVkaWFHcm91cCA9IGZ1bmN0aW9uIGZvckVhY2hNZWRpYUdyb3VwKG1hc3RlciwgZ3JvdXBzLCBjYWxsYmFjaykge1xuICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAobWVkaWFUeXBlKSB7XG4gICAgZm9yICh2YXIgZ3JvdXBLZXkgaW4gbWFzdGVyLm1lZGlhR3JvdXBzW21lZGlhVHlwZV0pIHtcbiAgICAgIGZvciAodmFyIGxhYmVsS2V5IGluIG1hc3Rlci5tZWRpYUdyb3Vwc1ttZWRpYVR5cGVdW2dyb3VwS2V5XSkge1xuICAgICAgICB2YXIgbWVkaWFQcm9wZXJ0aWVzID0gbWFzdGVyLm1lZGlhR3JvdXBzW21lZGlhVHlwZV1bZ3JvdXBLZXldW2xhYmVsS2V5XTtcbiAgICAgICAgY2FsbGJhY2sobWVkaWFQcm9wZXJ0aWVzLCBtZWRpYVR5cGUsIGdyb3VwS2V5LCBsYWJlbEtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/media-groups.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/media-types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/media-types.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simpleTypeFromSourceType: () => (/* binding */ simpleTypeFromSourceType)\n/* harmony export */ });\nvar MPEGURL_REGEX = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\nvar DASH_REGEX = /^application\\/dash\\+xml/i;\n/**\n * Returns a string that describes the type of source based on a video source object's\n * media type.\n *\n * @see {@link https://dev.w3.org/html5/pf-summary/video.html#dom-source-type|Source Type}\n *\n * @param {string} type\n *        Video source object media type\n * @return {('hls'|'dash'|'vhs-json'|null)}\n *         VHS source type string\n */\n\nvar simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\n  if (MPEGURL_REGEX.test(type)) {\n    return 'hls';\n  }\n\n  if (DASH_REGEX.test(type)) {\n    return 'dash';\n  } // Denotes the special case of a manifest object passed to http-streaming instead of a\n  // source URL.\n  //\n  // See https://en.wikipedia.org/wiki/Media_type for details on specifying media types.\n  //\n  // In this case, vnd stands for vendor, video.js for the organization, VHS for this\n  // project, and the +json suffix identifies the structure of the media type.\n\n\n  if (type === 'application/vnd.videojs.vhs+json') {\n    return 'vhs-json';\n  }\n\n  return null;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL21lZGlhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvZXMvbWVkaWEtdHlwZXMuanM/MDhkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTVBFR1VSTF9SRUdFWCA9IC9eKGF1ZGlvfHZpZGVvfGFwcGxpY2F0aW9uKVxcLyh4LXx2bmRcXC5hcHBsZVxcLik/bXBlZ3VybC9pO1xudmFyIERBU0hfUkVHRVggPSAvXmFwcGxpY2F0aW9uXFwvZGFzaFxcK3htbC9pO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHNvdXJjZSBiYXNlZCBvbiBhIHZpZGVvIHNvdXJjZSBvYmplY3Qnc1xuICogbWVkaWEgdHlwZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Rldi53My5vcmcvaHRtbDUvcGYtc3VtbWFyeS92aWRlby5odG1sI2RvbS1zb3VyY2UtdHlwZXxTb3VyY2UgVHlwZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFZpZGVvIHNvdXJjZSBvYmplY3QgbWVkaWEgdHlwZVxuICogQHJldHVybiB7KCdobHMnfCdkYXNoJ3wndmhzLWpzb24nfG51bGwpfVxuICogICAgICAgICBWSFMgc291cmNlIHR5cGUgc3RyaW5nXG4gKi9cblxuZXhwb3J0IHZhciBzaW1wbGVUeXBlRnJvbVNvdXJjZVR5cGUgPSBmdW5jdGlvbiBzaW1wbGVUeXBlRnJvbVNvdXJjZVR5cGUodHlwZSkge1xuICBpZiAoTVBFR1VSTF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuICdobHMnO1xuICB9XG5cbiAgaWYgKERBU0hfUkVHRVgudGVzdCh0eXBlKSkge1xuICAgIHJldHVybiAnZGFzaCc7XG4gIH0gLy8gRGVub3RlcyB0aGUgc3BlY2lhbCBjYXNlIG9mIGEgbWFuaWZlc3Qgb2JqZWN0IHBhc3NlZCB0byBodHRwLXN0cmVhbWluZyBpbnN0ZWFkIG9mIGFcbiAgLy8gc291cmNlIFVSTC5cbiAgLy9cbiAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lZGlhX3R5cGUgZm9yIGRldGFpbHMgb24gc3BlY2lmeWluZyBtZWRpYSB0eXBlcy5cbiAgLy9cbiAgLy8gSW4gdGhpcyBjYXNlLCB2bmQgc3RhbmRzIGZvciB2ZW5kb3IsIHZpZGVvLmpzIGZvciB0aGUgb3JnYW5pemF0aW9uLCBWSFMgZm9yIHRoaXNcbiAgLy8gcHJvamVjdCwgYW5kIHRoZSAranNvbiBzdWZmaXggaWRlbnRpZmllcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBtZWRpYSB0eXBlLlxuXG5cbiAgaWYgKHR5cGUgPT09ICdhcHBsaWNhdGlvbi92bmQudmlkZW9qcy52aHMranNvbicpIHtcbiAgICByZXR1cm4gJ3Zocy1qc29uJztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/media-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/mp4-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/mp4-helpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addSampleDescription: () => (/* binding */ addSampleDescription),\n/* harmony export */   buildFrameTable: () => (/* binding */ buildFrameTable),\n/* harmony export */   findBox: () => (/* binding */ findBox),\n/* harmony export */   findNamedBox: () => (/* binding */ findNamedBox),\n/* harmony export */   parseDescriptors: () => (/* binding */ parseDescriptors),\n/* harmony export */   parseMediaInfo: () => (/* binding */ parseMediaInfo),\n/* harmony export */   parseTracks: () => (/* binding */ parseTracks)\n/* harmony export */ });\n/* harmony import */ var _byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\");\n/* harmony import */ var _codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codec-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/codec-helpers.js\");\n/* harmony import */ var _opus_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./opus-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/opus-helpers.js\");\n\n\n\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\nvar parseDescriptors = function parseDescriptors(bytes) {\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToString)(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nvar findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nvar findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nvar buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(entry.subarray(0, 4)),\n      sampleDelta: (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(entry.subarray(0, 4)),\n      samplesPerChunk: (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(entry.subarray(4, 8)),\n      sampleDescriptionIndex: (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\nvar addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToString)(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + (0,_codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getAvcCodec)(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + (0,_codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getHvcCodec)(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toHexString)(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + (0,_codec_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getAv1Codec)(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(profile, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(level, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(bitDepth, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(chromaSubsampling, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(colourPrimaries, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(transferCharacteristics, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(matrixCoefficients, 2, '0');\n    codec += \".\" + (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = (0,_opus_helpers_js__WEBPACK_IMPORTED_MODULE_2__.parseOpusHead)(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\nvar parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToString)(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nvar parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(mvhd.subarray(20, 24));\n    info.duration = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(mvhd.subarray(12, 16));\n    info.duration = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumber)(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL21wNC1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNEg7QUFDakQ7QUFDekI7O0FBRWxEO0FBQ0E7QUFDQSxXQUFXLCtEQUFhO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDTztBQUNQLFVBQVUseURBQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0Esa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsaUJBQWlCLCtEQUFhO0FBQzlCO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx5REFBTztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSw0REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSw0REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0RBQWE7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLCtEQUFhOztBQUVoQyxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBYTtBQUNoQyxtQkFBbUIsK0RBQWE7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtCQUFrQiwrREFBYTtBQUMvQix1QkFBdUIsK0RBQWE7QUFDcEMsOEJBQThCLCtEQUFhO0FBQzNDO0FBQ0EsR0FBRztBQUNILHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQSwyQkFBMkIsa0NBQWtDO0FBQzdEOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUMsaURBQWlEOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQLGNBQWMsK0RBQWE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDLG1CQUFtQiw4REFBVztBQUM5Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSixtQkFBbUIsOERBQVc7QUFDOUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBVzs7QUFFaEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsOERBQVc7QUFDOUIsSUFBSTtBQUNKO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFRO0FBQzNCLG1CQUFtQiwwREFBUTtBQUMzQixtQkFBbUIsMERBQVE7QUFDM0IsbUJBQW1CLDBEQUFRO0FBQzNCLG1CQUFtQiwwREFBUTtBQUMzQixtQkFBbUIsMERBQVE7QUFDM0IsbUJBQW1CLDBEQUFRO0FBQzNCLG1CQUFtQiwwREFBUTtBQUMzQixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQiwrREFBYSxRQUFRO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHlEQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0RBQWE7O0FBRWhDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUFhO0FBQ3hDLG9CQUFvQjs7QUFFcEI7QUFDQSxnQkFBZ0IsK0RBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSwwQkFBMEIsK0RBQWE7QUFDdkMsb0JBQW9CLCtEQUFhO0FBQ2pDLElBQUk7QUFDSiwwQkFBMEIsK0RBQWE7QUFDdkMsb0JBQW9CLCtEQUFhO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXNuYXBzaG90LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9lcy9tcDQtaGVscGVycy5qcz83MWIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmluZ1RvQnl0ZXMsIHRvVWludDgsIGJ5dGVzTWF0Y2gsIGJ5dGVzVG9TdHJpbmcsIHRvSGV4U3RyaW5nLCBwYWRTdGFydCwgYnl0ZXNUb051bWJlciB9IGZyb20gJy4vYnl0ZS1oZWxwZXJzLmpzJztcbmltcG9ydCB7IGdldEF2Y0NvZGVjLCBnZXRIdmNDb2RlYywgZ2V0QXYxQ29kZWMgfSBmcm9tICcuL2NvZGVjLWhlbHBlcnMuanMnO1xuaW1wb3J0IHsgcGFyc2VPcHVzSGVhZCB9IGZyb20gJy4vb3B1cy1oZWxwZXJzLmpzJztcblxudmFyIG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHBhdGgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG52YXIgbm9ybWFsaXplUGF0aHMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXRocyhwYXRocykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgcmV0dXJuIFtub3JtYWxpemVQYXRoKHBhdGhzKV07XG4gIH1cblxuICByZXR1cm4gcGF0aHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocCk7XG4gIH0pO1xufTtcblxudmFyIERFU0NSSVBUT1JTO1xuZXhwb3J0IHZhciBwYXJzZURlc2NyaXB0b3JzID0gZnVuY3Rpb24gcGFyc2VEZXNjcmlwdG9ycyhieXRlcykge1xuICBieXRlcyA9IHRvVWludDgoYnl0ZXMpO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGJ5dGVzLmxlbmd0aCA+IGkpIHtcbiAgICB2YXIgdGFnID0gYnl0ZXNbaV07XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIHZhciBoZWFkZXJTaXplID0gMDsgLy8gdGFnXG5cbiAgICBoZWFkZXJTaXplKys7XG4gICAgdmFyIGJ5dGUgPSBieXRlc1toZWFkZXJTaXplXTsgLy8gZmlyc3QgYnl0ZVxuXG4gICAgaGVhZGVyU2l6ZSsrO1xuXG4gICAgd2hpbGUgKGJ5dGUgJiAweDgwKSB7XG4gICAgICBzaXplID0gKGJ5dGUgJiAweDdGKSA8PCA3O1xuICAgICAgYnl0ZSA9IGJ5dGVzW2hlYWRlclNpemVdO1xuICAgICAgaGVhZGVyU2l6ZSsrO1xuICAgIH1cblxuICAgIHNpemUgKz0gYnl0ZSAmIDB4N0Y7XG5cbiAgICBmb3IgKHZhciB6ID0gMDsgeiA8IERFU0NSSVBUT1JTLmxlbmd0aDsgeisrKSB7XG4gICAgICB2YXIgX0RFU0NSSVBUT1JTJHogPSBERVNDUklQVE9SU1t6XSxcbiAgICAgICAgICBpZCA9IF9ERVNDUklQVE9SUyR6LmlkLFxuICAgICAgICAgIHBhcnNlciA9IF9ERVNDUklQVE9SUyR6LnBhcnNlcjtcblxuICAgICAgaWYgKHRhZyA9PT0gaWQpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlcihieXRlcy5zdWJhcnJheShoZWFkZXJTaXplLCBoZWFkZXJTaXplICsgc2l6ZSkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaSArPSBzaXplICsgaGVhZGVyU2l6ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTtcbkRFU0NSSVBUT1JTID0gW3tcbiAgaWQ6IDB4MDMsXG4gIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKGJ5dGVzKSB7XG4gICAgdmFyIGRlc2MgPSB7XG4gICAgICB0YWc6IDB4MDMsXG4gICAgICBpZDogYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdLFxuICAgICAgZmxhZ3M6IGJ5dGVzWzJdLFxuICAgICAgc2l6ZTogMyxcbiAgICAgIGRlcGVuZHNPbkVzSWQ6IDAsXG4gICAgICBvY3JFc0lkOiAwLFxuICAgICAgZGVzY3JpcHRvcnM6IFtdLFxuICAgICAgdXJsOiAnJ1xuICAgIH07IC8vIGRlcGVuZHMgb24gZXMgaWRcblxuICAgIGlmIChkZXNjLmZsYWdzICYgMHg4MCkge1xuICAgICAgZGVzYy5kZXBlbmRzT25Fc0lkID0gYnl0ZXNbZGVzYy5zaXplXSA8PCA4IHwgYnl0ZXNbZGVzYy5zaXplICsgMV07XG4gICAgICBkZXNjLnNpemUgKz0gMjtcbiAgICB9IC8vIHVybFxuXG5cbiAgICBpZiAoZGVzYy5mbGFncyAmIDB4NDApIHtcbiAgICAgIHZhciBsZW4gPSBieXRlc1tkZXNjLnNpemVdO1xuICAgICAgZGVzYy51cmwgPSBieXRlc1RvU3RyaW5nKGJ5dGVzLnN1YmFycmF5KGRlc2Muc2l6ZSArIDEsIGRlc2Muc2l6ZSArIDEgKyBsZW4pKTtcbiAgICAgIGRlc2Muc2l6ZSArPSBsZW47XG4gICAgfSAvLyBvY3IgZXMgaWRcblxuXG4gICAgaWYgKGRlc2MuZmxhZ3MgJiAweDIwKSB7XG4gICAgICBkZXNjLm9jckVzSWQgPSBieXRlc1tkZXNjLnNpemVdIDw8IDggfCBieXRlc1tkZXNjLnNpemUgKyAxXTtcbiAgICAgIGRlc2Muc2l6ZSArPSAyO1xuICAgIH1cblxuICAgIGRlc2MuZGVzY3JpcHRvcnMgPSBwYXJzZURlc2NyaXB0b3JzKGJ5dGVzLnN1YmFycmF5KGRlc2Muc2l6ZSkpIHx8IFtdO1xuICAgIHJldHVybiBkZXNjO1xuICB9XG59LCB7XG4gIGlkOiAweDA0LFxuICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcihieXRlcykge1xuICAgIC8vIERlY29kZXJDb25maWdEZXNjcmlwdG9yXG4gICAgdmFyIGRlc2MgPSB7XG4gICAgICB0YWc6IDB4MDQsXG4gICAgICBvdGk6IGJ5dGVzWzBdLFxuICAgICAgc3RyZWFtVHlwZTogYnl0ZXNbMV0sXG4gICAgICBidWZmZXJTaXplOiBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDggfCBieXRlc1s0XSxcbiAgICAgIG1heEJpdHJhdGU6IGJ5dGVzWzVdIDw8IDI0IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCA4IHwgYnl0ZXNbOF0sXG4gICAgICBhdmdCaXRyYXRlOiBieXRlc1s5XSA8PCAyNCB8IGJ5dGVzWzEwXSA8PCAxNiB8IGJ5dGVzWzExXSA8PCA4IHwgYnl0ZXNbMTJdLFxuICAgICAgZGVzY3JpcHRvcnM6IHBhcnNlRGVzY3JpcHRvcnMoYnl0ZXMuc3ViYXJyYXkoMTMpKVxuICAgIH07XG4gICAgcmV0dXJuIGRlc2M7XG4gIH1cbn0sIHtcbiAgaWQ6IDB4MDUsXG4gIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKGJ5dGVzKSB7XG4gICAgLy8gRGVjb2RlclNwZWNpZmljSW5mb1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6IDB4MDUsXG4gICAgICBieXRlczogYnl0ZXNcbiAgICB9O1xuICB9XG59LCB7XG4gIGlkOiAweDA2LFxuICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcihieXRlcykge1xuICAgIC8vIFNMQ29uZmlnRGVzY3JpcHRvclxuICAgIHJldHVybiB7XG4gICAgICB0YWc6IDB4MDYsXG4gICAgICBieXRlczogYnl0ZXNcbiAgICB9O1xuICB9XG59XTtcbi8qKlxuICogZmluZCBhbnkgbnVtYmVyIG9mIGJveGVzIGJ5IG5hbWUgZ2l2ZW4gYSBwYXRoIHRvIGl0IGluIGFuIGlzbyBibWZmXG4gKiBzdWNoIGFzIG1wNC5cbiAqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGJ5dGVzXG4gKiAgICAgICAgYnl0ZXMgZm9yIHRoZSBpc28gYm1mZiB0byBzZWFyY2ggZm9yIGJveGVzIGluXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5W118c3RyaW5nW118c3RyaW5nfFVpbnQ4QXJyYXl9IG5hbWVcbiAqICAgICAgICBBbiBhcnJheSBvZiBwYXRocyBvciBhIHNpbmdsZSBwYXRoIHJlcHJlc2VudGluZyB0aGUgbmFtZVxuICogICAgICAgIG9mIGJveGVzIHRvIHNlYXJjaCB0aHJvdWdoIGluIGJ5dGVzLiBQYXRocyBtYXkgYmVcbiAqICAgICAgICB1aW50OCAoY2hhcmFjdGVyIGNvZGVzKSBvciBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbXBsZXRlPWZhbHNlXVxuICogICAgICAgIFNob3VsZCB3ZSBzZWFyY2ggb25seSBmb3IgY29tcGxldGUgYm94ZXMgb24gdGhlIGZpbmFsIHBhdGguXG4gKiAgICAgICAgVGhpcyBpcyB2ZXJ5IHVzZWZ1bCB3aGVuIHlvdSBkbyBub3Qgd2FudCB0byBnZXQgYmFjayBwYXJ0aWFsIGJveGVzXG4gKiAgICAgICAgaW4gdGhlIGNhc2Ugb2Ygc3RyZWFtaW5nIGZpbGVzLlxuICpcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXlbXX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2YgdGhlIGVuZCBwYXRocyB0aGF0IHdlIGZvdW5kLlxuICovXG5cbmV4cG9ydCB2YXIgZmluZEJveCA9IGZ1bmN0aW9uIGZpbmRCb3goYnl0ZXMsIHBhdGhzLCBjb21wbGV0ZSkge1xuICBpZiAoY29tcGxldGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXBsZXRlID0gZmFsc2U7XG4gIH1cblxuICBwYXRocyA9IG5vcm1hbGl6ZVBhdGhzKHBhdGhzKTtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAoIXBhdGhzLmxlbmd0aCkge1xuICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIHZhciBzaXplID0gKGJ5dGVzW2ldIDw8IDI0IHwgYnl0ZXNbaSArIDFdIDw8IDE2IHwgYnl0ZXNbaSArIDJdIDw8IDggfCBieXRlc1tpICsgM10pID4+PiAwO1xuICAgIHZhciB0eXBlID0gYnl0ZXMuc3ViYXJyYXkoaSArIDQsIGkgKyA4KTsgLy8gaW52YWxpZCBib3ggZm9ybWF0LlxuXG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBpICsgc2l6ZTtcblxuICAgIGlmIChlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgIC8vIHRoaXMgYm94IGlzIGJpZ2dlciB0aGFuIHRoZSBudW1iZXIgb2YgYnl0ZXMgd2UgaGF2ZVxuICAgICAgLy8gYW5kIGNvbXBsZXRlIGlzIHNldCwgd2UgY2Fubm90IGZpbmQgYW55IG1vcmUgYm94ZXMuXG4gICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IGJ5dGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IGJ5dGVzLnN1YmFycmF5KGkgKyA4LCBlbmQpO1xuXG4gICAgaWYgKGJ5dGVzTWF0Y2godHlwZSwgcGF0aHNbMF0pKSB7XG4gICAgICBpZiAocGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgIHJlc3VsdHMucHVzaChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBmaW5kQm94KGRhdGEsIHBhdGhzLnNsaWNlKDEpLCBjb21wbGV0ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkgPSBlbmQ7XG4gIH0gLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBieXRlc1xuXG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuLyoqXG4gKiBTZWFyY2ggZm9yIGEgc2luZ2xlIG1hdGNoaW5nIGJveCBieSBuYW1lIGluIGFuIGlzbyBibWZmIGZvcm1hdCBsaWtlXG4gKiBtcDQuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBmaW5kaW5nIGNvZGVjIGJveGVzIHdoaWNoXG4gKiBjYW4gYmUgcGxhY2VkIGFyYml0cmFyaWx5IGluIHNhbXBsZSBkZXNjcmlwdGlvbnMgZGVwZW5kaW5nXG4gKiBvbiB0aGUgdmVyc2lvbiBvZiB0aGUgZmlsZSBvciBmaWxlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSBieXRlc1xuICogICAgICAgIGJ5dGVzIGZvciB0aGUgaXNvIGJtZmYgdG8gc2VhcmNoIGZvciBib3hlcyBpblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IG5hbWVcbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgYm94IHRvIGZpbmQuXG4gKlxuICogQHJldHVybiB7VWludDhBcnJheVtdfVxuICogICAgICAgICBhIHN1YmFycmF5IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgbmFtZSBib3hlZCB3ZSBmb3VuZC5cbiAqL1xuXG5leHBvcnQgdmFyIGZpbmROYW1lZEJveCA9IGZ1bmN0aW9uIGZpbmROYW1lZEJveChieXRlcywgbmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplUGF0aChuYW1lKTtcblxuICBpZiAoIW5hbWUubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiBieXRlcy5zdWJhcnJheShieXRlcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzTWF0Y2goYnl0ZXMuc3ViYXJyYXkoaSwgaSArIG5hbWUubGVuZ3RoKSwgbmFtZSkpIHtcbiAgICAgIHZhciBzaXplID0gKGJ5dGVzW2kgLSA0XSA8PCAyNCB8IGJ5dGVzW2kgLSAzXSA8PCAxNiB8IGJ5dGVzW2kgLSAyXSA8PCA4IHwgYnl0ZXNbaSAtIDFdKSA+Pj4gMDtcbiAgICAgIHZhciBlbmQgPSBzaXplID4gMSA/IGkgKyBzaXplIDogYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheShpICsgNCwgZW5kKTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH0gLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBieXRlc1xuXG5cbiAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KGJ5dGVzLmxlbmd0aCk7XG59O1xuXG52YXIgcGFyc2VTYW1wbGVzID0gZnVuY3Rpb24gcGFyc2VTYW1wbGVzKGRhdGEsIGVudHJ5U2l6ZSwgcGFyc2VFbnRyeSkge1xuICBpZiAoZW50cnlTaXplID09PSB2b2lkIDApIHtcbiAgICBlbnRyeVNpemUgPSA0O1xuICB9XG5cbiAgaWYgKHBhcnNlRW50cnkgPT09IHZvaWQgMCkge1xuICAgIHBhcnNlRW50cnkgPSBmdW5jdGlvbiBwYXJzZUVudHJ5KGQpIHtcbiAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyKGQpO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW50cmllcyA9IFtdO1xuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuXG4gIHZhciBlbnRyeUNvdW50ID0gYnl0ZXNUb051bWJlcihkYXRhLnN1YmFycmF5KDQsIDgpKTtcblxuICBmb3IgKHZhciBpID0gODsgZW50cnlDb3VudDsgaSArPSBlbnRyeVNpemUsIGVudHJ5Q291bnQtLSkge1xuICAgIGVudHJpZXMucHVzaChwYXJzZUVudHJ5KGRhdGEuc3ViYXJyYXkoaSwgaSArIGVudHJ5U2l6ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBlbnRyaWVzO1xufTtcblxuZXhwb3J0IHZhciBidWlsZEZyYW1lVGFibGUgPSBmdW5jdGlvbiBidWlsZEZyYW1lVGFibGUoc3RibCwgdGltZXNjYWxlKSB7XG4gIHZhciBrZXlTYW1wbGVzID0gcGFyc2VTYW1wbGVzKGZpbmRCb3goc3RibCwgWydzdHNzJ10pWzBdKTtcbiAgdmFyIGNodW5rT2Zmc2V0cyA9IHBhcnNlU2FtcGxlcyhmaW5kQm94KHN0YmwsIFsnc3RjbyddKVswXSk7XG4gIHZhciB0aW1lVG9TYW1wbGVzID0gcGFyc2VTYW1wbGVzKGZpbmRCb3goc3RibCwgWydzdHRzJ10pWzBdLCA4LCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlQ291bnQ6IGJ5dGVzVG9OdW1iZXIoZW50cnkuc3ViYXJyYXkoMCwgNCkpLFxuICAgICAgc2FtcGxlRGVsdGE6IGJ5dGVzVG9OdW1iZXIoZW50cnkuc3ViYXJyYXkoNCwgOCkpXG4gICAgfTtcbiAgfSk7XG4gIHZhciBzYW1wbGVzVG9DaHVua3MgPSBwYXJzZVNhbXBsZXMoZmluZEJveChzdGJsLCBbJ3N0c2MnXSlbMF0sIDEyLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3RDaHVuazogYnl0ZXNUb051bWJlcihlbnRyeS5zdWJhcnJheSgwLCA0KSksXG4gICAgICBzYW1wbGVzUGVyQ2h1bms6IGJ5dGVzVG9OdW1iZXIoZW50cnkuc3ViYXJyYXkoNCwgOCkpLFxuICAgICAgc2FtcGxlRGVzY3JpcHRpb25JbmRleDogYnl0ZXNUb051bWJlcihlbnRyeS5zdWJhcnJheSg4LCAxMikpXG4gICAgfTtcbiAgfSk7XG4gIHZhciBzdHN6ID0gZmluZEJveChzdGJsLCBbJ3N0c3onXSlbMF07IC8vIHN0c3ogc3RhcnRzIHdpdGggYSA0IGJ5dGUgc2FtcGxlU2l6ZSB3aGljaCB3ZSBkb24ndCBuZWVkXG5cbiAgdmFyIHNhbXBsZVNpemVzID0gcGFyc2VTYW1wbGVzKHN0c3ogJiYgc3Rzei5sZW5ndGggJiYgc3Rzei5zdWJhcnJheSg0KSB8fCBudWxsKTtcbiAgdmFyIGZyYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIGNodW5rSW5kZXggPSAwOyBjaHVua0luZGV4IDwgY2h1bmtPZmZzZXRzLmxlbmd0aDsgY2h1bmtJbmRleCsrKSB7XG4gICAgdmFyIHNhbXBsZXNJbkNodW5rID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzVG9DaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzYW1wbGVUb0NodW5rID0gc2FtcGxlc1RvQ2h1bmtzW2ldO1xuICAgICAgdmFyIGlzVGhpc09uZSA9IGNodW5rSW5kZXggKyAxID49IHNhbXBsZVRvQ2h1bmsuZmlyc3RDaHVuayAmJiAoaSArIDEgPj0gc2FtcGxlc1RvQ2h1bmtzLmxlbmd0aCB8fCBjaHVua0luZGV4ICsgMSA8IHNhbXBsZXNUb0NodW5rc1tpICsgMV0uZmlyc3RDaHVuayk7XG5cbiAgICAgIGlmIChpc1RoaXNPbmUpIHtcbiAgICAgICAgc2FtcGxlc0luQ2h1bmsgPSBzYW1wbGVUb0NodW5rLnNhbXBsZXNQZXJDaHVuaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gY2h1bmtPZmZzZXRzW2NodW5rSW5kZXhdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNhbXBsZXNJbkNodW5rOyBfaSsrKSB7XG4gICAgICB2YXIgZnJhbWVFbmQgPSBzYW1wbGVTaXplc1tmcmFtZXMubGVuZ3RoXTsgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBrZXkgc2FtcGxlcyBldmVyeSBmcmFtZSBpcyBhIGtleWZyYW1lXG5cbiAgICAgIHZhciBrZXlmcmFtZSA9ICFrZXlTYW1wbGVzLmxlbmd0aDtcblxuICAgICAgaWYgKGtleVNhbXBsZXMubGVuZ3RoICYmIGtleVNhbXBsZXMuaW5kZXhPZihmcmFtZXMubGVuZ3RoICsgMSkgIT09IC0xKSB7XG4gICAgICAgIGtleWZyYW1lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyYW1lID0ge1xuICAgICAgICBrZXlmcmFtZToga2V5ZnJhbWUsXG4gICAgICAgIHN0YXJ0OiBjaHVua09mZnNldCxcbiAgICAgICAgZW5kOiBjaHVua09mZnNldCArIGZyYW1lRW5kXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbWVUb1NhbXBsZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIF90aW1lVG9TYW1wbGVzJGsgPSB0aW1lVG9TYW1wbGVzW2tdLFxuICAgICAgICAgICAgc2FtcGxlQ291bnQgPSBfdGltZVRvU2FtcGxlcyRrLnNhbXBsZUNvdW50LFxuICAgICAgICAgICAgc2FtcGxlRGVsdGEgPSBfdGltZVRvU2FtcGxlcyRrLnNhbXBsZURlbHRhO1xuXG4gICAgICAgIGlmIChmcmFtZXMubGVuZ3RoIDw9IHNhbXBsZUNvdW50KSB7XG4gICAgICAgICAgLy8gbXMgdG8gbnNcbiAgICAgICAgICB2YXIgbGFzdFRpbWVzdGFtcCA9IGZyYW1lcy5sZW5ndGggPyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdLnRpbWVzdGFtcCA6IDA7XG4gICAgICAgICAgZnJhbWUudGltZXN0YW1wID0gbGFzdFRpbWVzdGFtcCArIHNhbXBsZURlbHRhIC8gdGltZXNjYWxlICogMTAwMDtcbiAgICAgICAgICBmcmFtZS5kdXJhdGlvbiA9IHNhbXBsZURlbHRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgIGNodW5rT2Zmc2V0ICs9IGZyYW1lRW5kO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcmFtZXM7XG59O1xuZXhwb3J0IHZhciBhZGRTYW1wbGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGFkZFNhbXBsZURlc2NyaXB0aW9uKHRyYWNrLCBieXRlcykge1xuICB2YXIgY29kZWMgPSBieXRlc1RvU3RyaW5nKGJ5dGVzLnN1YmFycmF5KDAsIDQpKTtcblxuICBpZiAodHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgIHRyYWNrLmluZm8gPSB0cmFjay5pbmZvIHx8IHt9O1xuICAgIHRyYWNrLmluZm8ud2lkdGggPSBieXRlc1syOF0gPDwgOCB8IGJ5dGVzWzI5XTtcbiAgICB0cmFjay5pbmZvLmhlaWdodCA9IGJ5dGVzWzMwXSA8PCA4IHwgYnl0ZXNbMzFdO1xuICB9IGVsc2UgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICB0cmFjay5pbmZvID0gdHJhY2suaW5mbyB8fCB7fTtcbiAgICB0cmFjay5pbmZvLmNoYW5uZWxzID0gYnl0ZXNbMjBdIDw8IDggfCBieXRlc1syMV07XG4gICAgdHJhY2suaW5mby5iaXREZXB0aCA9IGJ5dGVzWzIyXSA8PCA4IHwgYnl0ZXNbMjNdO1xuICAgIHRyYWNrLmluZm8uc2FtcGxlUmF0ZSA9IGJ5dGVzWzI4XSA8PCA4IHwgYnl0ZXNbMjldO1xuICB9XG5cbiAgaWYgKGNvZGVjID09PSAnYXZjMScpIHtcbiAgICB2YXIgYXZjQyA9IGZpbmROYW1lZEJveChieXRlcywgJ2F2Y0MnKTsgLy8gQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmRcblxuICAgIGNvZGVjICs9IFwiLlwiICsgZ2V0QXZjQ29kZWMoYXZjQyk7XG4gICAgdHJhY2suaW5mby5hdmNDID0gYXZjQzsgLy8gVE9ETzogZG8gd2UgbmVlZCB0byBwYXJzZSBhbGwgdGhpcz9cblxuICAgIC8qIHtcbiAgICAgIGNvbmZpZ3VyYXRpb25WZXJzaW9uOiBhdmNDWzBdLFxuICAgICAgcHJvZmlsZTogYXZjQ1sxXSxcbiAgICAgIHByb2ZpbGVDb21wYXRpYmlsaXR5OiBhdmNDWzJdLFxuICAgICAgbGV2ZWw6IGF2Y0NbM10sXG4gICAgICBsZW5ndGhTaXplTWludXNPbmU6IGF2Y0NbNF0gJiAweDNcbiAgICB9O1xuICAgICBsZXQgc3BzTmFsVW5pdENvdW50ID0gYXZjQ1s1XSAmIDB4MUY7XG4gICAgY29uc3Qgc3BzTmFsVW5pdHMgPSB0cmFjay5pbmZvLmF2Yy5zcHNOYWxVbml0cyA9IFtdO1xuICAgICAvLyBwYXN0IHNwc05hbFVuaXRDb3VudFxuICAgIGxldCBvZmZzZXQgPSA2O1xuICAgICB3aGlsZSAoc3BzTmFsVW5pdENvdW50LS0pIHtcbiAgICAgIGNvbnN0IG5hbExlbiA9IGF2Y0Nbb2Zmc2V0XSA8PCA4IHwgYXZjQ1tvZmZzZXQgKyAxXTtcbiAgICAgICBzcHNOYWxVbml0cy5wdXNoKGF2Y0Muc3ViYXJyYXkob2Zmc2V0ICsgMiwgb2Zmc2V0ICsgMiArIG5hbExlbikpO1xuICAgICAgIG9mZnNldCArPSBuYWxMZW4gKyAyO1xuICAgIH1cbiAgICBsZXQgcHBzTmFsVW5pdENvdW50ID0gYXZjQ1tvZmZzZXRdO1xuICAgIGNvbnN0IHBwc05hbFVuaXRzID0gdHJhY2suaW5mby5hdmMucHBzTmFsVW5pdHMgPSBbXTtcbiAgICAgLy8gcGFzdCBwcHNOYWxVbml0Q291bnRcbiAgICBvZmZzZXQgKz0gMTtcbiAgICAgd2hpbGUgKHBwc05hbFVuaXRDb3VudC0tKSB7XG4gICAgICBjb25zdCBuYWxMZW4gPSBhdmNDW29mZnNldF0gPDwgOCB8IGF2Y0Nbb2Zmc2V0ICsgMV07XG4gICAgICAgcHBzTmFsVW5pdHMucHVzaChhdmNDLnN1YmFycmF5KG9mZnNldCArIDIsIG9mZnNldCArIDIgKyBuYWxMZW4pKTtcbiAgICAgICBvZmZzZXQgKz0gbmFsTGVuICsgMjtcbiAgICB9Ki9cbiAgICAvLyBIRVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmRcbiAgfSBlbHNlIGlmIChjb2RlYyA9PT0gJ2h2YzEnIHx8IGNvZGVjID09PSAnaGV2MScpIHtcbiAgICBjb2RlYyArPSBcIi5cIiArIGdldEh2Y0NvZGVjKGZpbmROYW1lZEJveChieXRlcywgJ2h2Y0MnKSk7XG4gIH0gZWxzZSBpZiAoY29kZWMgPT09ICdtcDRhJyB8fCBjb2RlYyA9PT0gJ21wNHYnKSB7XG4gICAgdmFyIGVzZHMgPSBmaW5kTmFtZWRCb3goYnl0ZXMsICdlc2RzJyk7XG4gICAgdmFyIGVzRGVzY3JpcHRvciA9IHBhcnNlRGVzY3JpcHRvcnMoZXNkcy5zdWJhcnJheSg0KSlbMF07XG4gICAgdmFyIGRlY29kZXJDb25maWcgPSBlc0Rlc2NyaXB0b3IgJiYgZXNEZXNjcmlwdG9yLmRlc2NyaXB0b3JzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHRhZyA9IF9yZWYudGFnO1xuICAgICAgcmV0dXJuIHRhZyA9PT0gMHgwNDtcbiAgICB9KVswXTtcblxuICAgIGlmIChkZWNvZGVyQ29uZmlnKSB7XG4gICAgICAvLyBtb3N0IGNvZGVjcyBkbyBub3QgaGF2ZSBhIGZ1cnRoZXIgJy4nXG4gICAgICAvLyBzdWNoIGFzIDB4YTUgZm9yIGFjLTMgYW5kIDB4YTYgZm9yIGUtYWMtM1xuICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXhTdHJpbmcoZGVjb2RlckNvbmZpZy5vdGkpO1xuXG4gICAgICBpZiAoZGVjb2RlckNvbmZpZy5vdGkgPT09IDB4NDApIHtcbiAgICAgICAgY29kZWMgKz0gJy4nICsgKGRlY29kZXJDb25maWcuZGVzY3JpcHRvcnNbMF0uYnl0ZXNbMF0gPj4gMykudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVjb2RlckNvbmZpZy5vdGkgPT09IDB4MjApIHtcbiAgICAgICAgY29kZWMgKz0gJy4nICsgZGVjb2RlckNvbmZpZy5kZXNjcmlwdG9yc1swXS5ieXRlc1s0XS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvZGVyQ29uZmlnLm90aSA9PT0gMHhkZCkge1xuICAgICAgICBjb2RlYyA9ICd2b3JiaXMnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgY29kZWMgKz0gJy40MC4yJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZWMgKz0gJy4yMC45JztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29kZWMgPT09ICdhdjAxJykge1xuICAgIC8vIEFWMURlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkXG4gICAgY29kZWMgKz0gXCIuXCIgKyBnZXRBdjFDb2RlYyhmaW5kTmFtZWRCb3goYnl0ZXMsICdhdjFDJykpO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAndnAwOScpIHtcbiAgICAvLyBWUENvZGVjQ29uZmlndXJhdGlvblJlY29yZFxuICAgIHZhciB2cGNDID0gZmluZE5hbWVkQm94KGJ5dGVzLCAndnBjQycpOyAvLyBodHRwczovL3d3dy53ZWJtcHJvamVjdC5vcmcvdnA5L21wNC9cblxuICAgIHZhciBwcm9maWxlID0gdnBjQ1swXTtcbiAgICB2YXIgbGV2ZWwgPSB2cGNDWzFdO1xuICAgIHZhciBiaXREZXB0aCA9IHZwY0NbMl0gPj4gNDtcbiAgICB2YXIgY2hyb21hU3Vic2FtcGxpbmcgPSAodnBjQ1syXSAmIDB4MEYpID4+IDE7XG4gICAgdmFyIHZpZGVvRnVsbFJhbmdlRmxhZyA9ICh2cGNDWzJdICYgMHgwRikgPj4gMztcbiAgICB2YXIgY29sb3VyUHJpbWFyaWVzID0gdnBjQ1szXTtcbiAgICB2YXIgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSB2cGNDWzRdO1xuICAgIHZhciBtYXRyaXhDb2VmZmljaWVudHMgPSB2cGNDWzVdO1xuICAgIGNvZGVjICs9IFwiLlwiICsgcGFkU3RhcnQocHJvZmlsZSwgMiwgJzAnKTtcbiAgICBjb2RlYyArPSBcIi5cIiArIHBhZFN0YXJ0KGxldmVsLCAyLCAnMCcpO1xuICAgIGNvZGVjICs9IFwiLlwiICsgcGFkU3RhcnQoYml0RGVwdGgsIDIsICcwJyk7XG4gICAgY29kZWMgKz0gXCIuXCIgKyBwYWRTdGFydChjaHJvbWFTdWJzYW1wbGluZywgMiwgJzAnKTtcbiAgICBjb2RlYyArPSBcIi5cIiArIHBhZFN0YXJ0KGNvbG91clByaW1hcmllcywgMiwgJzAnKTtcbiAgICBjb2RlYyArPSBcIi5cIiArIHBhZFN0YXJ0KHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzLCAyLCAnMCcpO1xuICAgIGNvZGVjICs9IFwiLlwiICsgcGFkU3RhcnQobWF0cml4Q29lZmZpY2llbnRzLCAyLCAnMCcpO1xuICAgIGNvZGVjICs9IFwiLlwiICsgcGFkU3RhcnQodmlkZW9GdWxsUmFuZ2VGbGFnLCAyLCAnMCcpO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAndGhlbycpIHtcbiAgICBjb2RlYyA9ICd0aGVvcmEnO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAnc3BleCcpIHtcbiAgICBjb2RlYyA9ICdzcGVleCc7XG4gIH0gZWxzZSBpZiAoY29kZWMgPT09ICcubXAzJykge1xuICAgIGNvZGVjID0gJ21wNGEuNDAuMzQnO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAnbXNWbycpIHtcbiAgICBjb2RlYyA9ICd2b3JiaXMnO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAnT3B1cycpIHtcbiAgICBjb2RlYyA9ICdvcHVzJztcbiAgICB2YXIgZE9wcyA9IGZpbmROYW1lZEJveChieXRlcywgJ2RPcHMnKTtcbiAgICB0cmFjay5pbmZvLm9wdXMgPSBwYXJzZU9wdXNIZWFkKGRPcHMpOyAvLyBUT0RPOiBzaG91bGQgdGhpcyBnbyBpbnRvIHRoZSB3ZWJtIGNvZGU/P1xuICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgYSBjb2RlY0RlbGF5IGZvciBvcHVzIHBsYXliYWNrXG4gICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyMzhcblxuICAgIHRyYWNrLmluZm8uY29kZWNEZWxheSA9IDY1MDAwMDA7XG4gIH0gZWxzZSB7XG4gICAgY29kZWMgPSBjb2RlYy50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cbiAgLy8gZmxhYywgYWMtMywgZWMtMywgb3B1c1xuXG5cbiAgdHJhY2suY29kZWMgPSBjb2RlYztcbn07XG5leHBvcnQgdmFyIHBhcnNlVHJhY2tzID0gZnVuY3Rpb24gcGFyc2VUcmFja3MoYnl0ZXMsIGZyYW1lVGFibGUpIHtcbiAgaWYgKGZyYW1lVGFibGUgPT09IHZvaWQgMCkge1xuICAgIGZyYW1lVGFibGUgPSB0cnVlO1xuICB9XG5cbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIHRyYWtzID0gZmluZEJveChieXRlcywgWydtb292JywgJ3RyYWsnXSwgdHJ1ZSk7XG4gIHZhciB0cmFja3MgPSBbXTtcbiAgdHJha3MuZm9yRWFjaChmdW5jdGlvbiAodHJhaykge1xuICAgIHZhciB0cmFjayA9IHtcbiAgICAgIGJ5dGVzOiB0cmFrXG4gICAgfTtcbiAgICB2YXIgbWRpYSA9IGZpbmRCb3godHJhaywgWydtZGlhJ10pWzBdO1xuICAgIHZhciBoZGxyID0gZmluZEJveChtZGlhLCBbJ2hkbHInXSlbMF07XG4gICAgdmFyIHRyYWtUeXBlID0gYnl0ZXNUb1N0cmluZyhoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG5cbiAgICBpZiAodHJha1R5cGUgPT09ICdzb3VuJykge1xuICAgICAgdHJhY2sudHlwZSA9ICdhdWRpbyc7XG4gICAgfSBlbHNlIGlmICh0cmFrVHlwZSA9PT0gJ3ZpZGUnKSB7XG4gICAgICB0cmFjay50eXBlID0gJ3ZpZGVvJztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sudHlwZSA9IHRyYWtUeXBlO1xuICAgIH1cblxuICAgIHZhciB0a2hkID0gZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG5cbiAgICBpZiAodGtoZCkge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcodGtoZC5idWZmZXIsIHRraGQuYnl0ZU9mZnNldCwgdGtoZC5ieXRlTGVuZ3RoKTtcbiAgICAgIHZhciB0a2hkVmVyc2lvbiA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICB0cmFjay5udW1iZXIgPSB0a2hkVmVyc2lvbiA9PT0gMCA/IHZpZXcuZ2V0VWludDMyKDEyKSA6IHZpZXcuZ2V0VWludDMyKDIwKTtcbiAgICB9XG5cbiAgICB2YXIgbWRoZCA9IGZpbmRCb3gobWRpYSwgWydtZGhkJ10pWzBdO1xuXG4gICAgaWYgKG1kaGQpIHtcbiAgICAgIC8vIG1kaGQgaXMgYSBGdWxsQm94LCBtZWFuaW5nIGl0IHdpbGwgaGF2ZSBpdHMgb3duIHZlcnNpb24gYXMgdGhlIGZpcnN0IGJ5dGVcbiAgICAgIHZhciB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICAgIHZhciBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgdHJhY2sudGltZXNjYWxlID0gKG1kaGRbaW5kZXhdIDw8IDI0IHwgbWRoZFtpbmRleCArIDFdIDw8IDE2IHwgbWRoZFtpbmRleCArIDJdIDw8IDggfCBtZGhkW2luZGV4ICsgM10pID4+PiAwO1xuICAgIH1cblxuICAgIHZhciBzdGJsID0gZmluZEJveChtZGlhLCBbJ21pbmYnLCAnc3RibCddKVswXTtcbiAgICB2YXIgc3RzZCA9IGZpbmRCb3goc3RibCwgWydzdHNkJ10pWzBdO1xuICAgIHZhciBkZXNjcmlwdGlvbkNvdW50ID0gYnl0ZXNUb051bWJlcihzdHNkLnN1YmFycmF5KDQsIDgpKTtcbiAgICB2YXIgb2Zmc2V0ID0gODsgLy8gYWRkIGNvZGVjIGFuZCBjb2RlYyBpbmZvXG5cbiAgICB3aGlsZSAoZGVzY3JpcHRpb25Db3VudC0tKSB7XG4gICAgICB2YXIgbGVuID0gYnl0ZXNUb051bWJlcihzdHNkLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgNCkpO1xuICAgICAgdmFyIHNhbXBsZURlc2NyaXB0b3IgPSBzdHNkLnN1YmFycmF5KG9mZnNldCArIDQsIG9mZnNldCArIDQgKyBsZW4pO1xuICAgICAgYWRkU2FtcGxlRGVzY3JpcHRpb24odHJhY2ssIHNhbXBsZURlc2NyaXB0b3IpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW47XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lVGFibGUpIHtcbiAgICAgIHRyYWNrLmZyYW1lVGFibGUgPSBidWlsZEZyYW1lVGFibGUoc3RibCwgdHJhY2sudGltZXNjYWxlKTtcbiAgICB9IC8vIGNvZGVjIGhhcyBubyBzdWIgcGFyYW1ldGVyc1xuXG5cbiAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gIH0pO1xuICByZXR1cm4gdHJhY2tzO1xufTtcbmV4cG9ydCB2YXIgcGFyc2VNZWRpYUluZm8gPSBmdW5jdGlvbiBwYXJzZU1lZGlhSW5mbyhieXRlcykge1xuICB2YXIgbXZoZCA9IGZpbmRCb3goYnl0ZXMsIFsnbW9vdicsICdtdmhkJ10sIHRydWUpWzBdO1xuXG4gIGlmICghbXZoZCB8fCAhbXZoZC5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5mbyA9IHt9OyAvLyBtcyB0byBuc1xuICAvLyBtdmhkIHYxIGhhcyA4IGJ5dGUgZHVyYXRpb24gYW5kIG90aGVyIGZpZWxkcyB0b29cblxuICBpZiAobXZoZFswXSA9PT0gMSkge1xuICAgIGluZm8udGltZXN0YW1wU2NhbGUgPSBieXRlc1RvTnVtYmVyKG12aGQuc3ViYXJyYXkoMjAsIDI0KSk7XG4gICAgaW5mby5kdXJhdGlvbiA9IGJ5dGVzVG9OdW1iZXIobXZoZC5zdWJhcnJheSgyNCwgMzIpKTtcbiAgfSBlbHNlIHtcbiAgICBpbmZvLnRpbWVzdGFtcFNjYWxlID0gYnl0ZXNUb051bWJlcihtdmhkLnN1YmFycmF5KDEyLCAxNikpO1xuICAgIGluZm8uZHVyYXRpb24gPSBieXRlc1RvTnVtYmVyKG12aGQuc3ViYXJyYXkoMTYsIDIwKSk7XG4gIH1cblxuICBpbmZvLmJ5dGVzID0gbXZoZDtcbiAgcmV0dXJuIGluZm87XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/mp4-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/nal-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/nal-helpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMULATION_PREVENTION: () => (/* binding */ EMULATION_PREVENTION),\n/* harmony export */   NAL_TYPE_ONE: () => (/* binding */ NAL_TYPE_ONE),\n/* harmony export */   NAL_TYPE_TWO: () => (/* binding */ NAL_TYPE_TWO),\n/* harmony export */   discardEmulationPreventionBytes: () => (/* binding */ discardEmulationPreventionBytes),\n/* harmony export */   findH264Nal: () => (/* binding */ findH264Nal),\n/* harmony export */   findH265Nal: () => (/* binding */ findH265Nal),\n/* harmony export */   findNal: () => (/* binding */ findNal)\n/* harmony export */ });\n/* harmony import */ var _byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/byte-helpers.js\");\n\nvar NAL_TYPE_ONE = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x00, 0x00, 0x00, 0x01]);\nvar NAL_TYPE_TWO = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x00, 0x00, 0x01]);\nvar EMULATION_PREVENTION = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nvar discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\nvar findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = (0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if ((0,_byte_helpers_js__WEBPACK_IMPORTED_MODULE_0__.bytesMatch)(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\nvar findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nvar findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL25hbC1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ2pELG1CQUFtQix5REFBTztBQUMxQixtQkFBbUIseURBQU87QUFDMUIsMkJBQTJCLHlEQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFTztBQUNQO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFFBQVEsNERBQVU7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLFVBQVUseURBQU87QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSw0REFBVTtBQUNsQjtBQUNBLE1BQU0sU0FBUyw0REFBVTtBQUN6QjtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL25hbC1oZWxwZXJzLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXNNYXRjaCwgdG9VaW50OCB9IGZyb20gJy4vYnl0ZS1oZWxwZXJzLmpzJztcbmV4cG9ydCB2YXIgTkFMX1RZUEVfT05FID0gdG9VaW50OChbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pO1xuZXhwb3J0IHZhciBOQUxfVFlQRV9UV08gPSB0b1VpbnQ4KFsweDAwLCAweDAwLCAweDAxXSk7XG5leHBvcnQgdmFyIEVNVUxBVElPTl9QUkVWRU5USU9OID0gdG9VaW50OChbMHgwMCwgMHgwMCwgMHgwM10pO1xuLyoqXG4gKiBFeHB1bmdlIGFueSBcIkVtdWxhdGlvbiBQcmV2ZW50aW9uXCIgYnl0ZXMgZnJvbSBhIFwiUmF3IEJ5dGVcbiAqIFNlcXVlbmNlIFBheWxvYWRcIlxuICpcbiAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBSQlNQIGZyb20gYSBOQUxcbiAqIHVuaXRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBSQlNQIHdpdGhvdXQgYW55IEVtdWxhdGlvblxuICogUHJldmVudGlvbiBCeXRlc1xuICovXG5cbmV4cG9ydCB2YXIgZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyA9IGZ1bmN0aW9uIGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMoYnl0ZXMpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICB2YXIgaSA9IDE7IC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCAtIDIpIHtcbiAgICBpZiAoYnl0ZXNNYXRjaChieXRlcy5zdWJhcnJheShpLCBpICsgMyksIEVNVUxBVElPTl9QUkVWRU5USU9OKSkge1xuICAgICAgcG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIGkrKztcbiAgfSAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBhcnJheVxuXG5cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH0gLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcblxuXG4gIHZhciBuZXdMZW5ndGggPSBieXRlcy5sZW5ndGggLSBwb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSBwb3NpdGlvbnNbMF0pIHtcbiAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICBzb3VyY2VJbmRleCsrOyAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuXG4gICAgICBwb3NpdGlvbnMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBuZXdEYXRhW2ldID0gYnl0ZXNbc291cmNlSW5kZXhdO1xuICB9XG5cbiAgcmV0dXJuIG5ld0RhdGE7XG59O1xuZXhwb3J0IHZhciBmaW5kTmFsID0gZnVuY3Rpb24gZmluZE5hbChieXRlcywgZGF0YVR5cGUsIHR5cGVzLCBuYWxMaW1pdCkge1xuICBpZiAobmFsTGltaXQgPT09IHZvaWQgMCkge1xuICAgIG5hbExpbWl0ID0gSW5maW5pdHk7XG4gIH1cblxuICBieXRlcyA9IHRvVWludDgoYnl0ZXMpO1xuICB0eXBlcyA9IFtdLmNvbmNhdCh0eXBlcyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIG5hbFN0YXJ0O1xuICB2YXIgbmFsc0ZvdW5kID0gMDsgLy8ga2VlcCBzZWFyY2hpbmcgdW50aWw6XG4gIC8vIHdlIHJlYWNoIHRoZSBlbmQgb2YgYnl0ZXNcbiAgLy8gd2UgcmVhY2ggdGhlIG1heGltdW0gbnVtYmVyIG9mIG5hbHMgdGhleSB3YW50IHRvIHNlYWNoXG4gIC8vIE5PVEU6IHRoYXQgd2UgZGlzcmVnYXJkIG5hbExpbWl0IHdoZW4gd2UgaGF2ZSBmb3VuZCB0aGUgc3RhcnRcbiAgLy8gb2YgdGhlIG5hbCB3ZSB3YW50IHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlIGVuZCBvZiB0aGUgbmFsIHdlIHdhbnQuXG5cbiAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGggJiYgKG5hbHNGb3VuZCA8IG5hbExpbWl0IHx8IG5hbFN0YXJ0KSkge1xuICAgIHZhciBuYWxPZmZzZXQgPSB2b2lkIDA7XG5cbiAgICBpZiAoYnl0ZXNNYXRjaChieXRlcy5zdWJhcnJheShpKSwgTkFMX1RZUEVfT05FKSkge1xuICAgICAgbmFsT2Zmc2V0ID0gNDtcbiAgICB9IGVsc2UgaWYgKGJ5dGVzTWF0Y2goYnl0ZXMuc3ViYXJyYXkoaSksIE5BTF9UWVBFX1RXTykpIHtcbiAgICAgIG5hbE9mZnNldCA9IDM7XG4gICAgfSAvLyB3ZSBhcmUgdW5zeW5jZWQsXG4gICAgLy8gZmluZCB0aGUgbmV4dCBuYWwgdW5pdFxuXG5cbiAgICBpZiAoIW5hbE9mZnNldCkge1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbmFsc0ZvdW5kKys7XG5cbiAgICBpZiAobmFsU3RhcnQpIHtcbiAgICAgIHJldHVybiBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKGJ5dGVzLnN1YmFycmF5KG5hbFN0YXJ0LCBpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5hbFR5cGUgPSB2b2lkIDA7XG5cbiAgICBpZiAoZGF0YVR5cGUgPT09ICdoMjY0Jykge1xuICAgICAgbmFsVHlwZSA9IGJ5dGVzW2kgKyBuYWxPZmZzZXRdICYgMHgxZjtcbiAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSAnaDI2NScpIHtcbiAgICAgIG5hbFR5cGUgPSBieXRlc1tpICsgbmFsT2Zmc2V0XSA+PiAxICYgMHgzZjtcbiAgICB9XG5cbiAgICBpZiAodHlwZXMuaW5kZXhPZihuYWxUeXBlKSAhPT0gLTEpIHtcbiAgICAgIG5hbFN0YXJ0ID0gaSArIG5hbE9mZnNldDtcbiAgICB9IC8vIG5hbCBoZWFkZXIgaXMgMSBsZW5ndGggZm9yIGgyNjQsIGFuZCAyIGZvciBoMjY1XG5cblxuICAgIGkgKz0gbmFsT2Zmc2V0ICsgKGRhdGFUeXBlID09PSAnaDI2NCcgPyAxIDogMik7XG4gIH1cblxuICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgMCk7XG59O1xuZXhwb3J0IHZhciBmaW5kSDI2NE5hbCA9IGZ1bmN0aW9uIGZpbmRIMjY0TmFsKGJ5dGVzLCB0eXBlLCBuYWxMaW1pdCkge1xuICByZXR1cm4gZmluZE5hbChieXRlcywgJ2gyNjQnLCB0eXBlLCBuYWxMaW1pdCk7XG59O1xuZXhwb3J0IHZhciBmaW5kSDI2NU5hbCA9IGZ1bmN0aW9uIGZpbmRIMjY1TmFsKGJ5dGVzLCB0eXBlLCBuYWxMaW1pdCkge1xuICByZXR1cm4gZmluZE5hbChieXRlcywgJ2gyNjUnLCB0eXBlLCBuYWxMaW1pdCk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/nal-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/opus-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/opus-helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OPUS_HEAD: () => (/* binding */ OPUS_HEAD),\n/* harmony export */   parseOpusHead: () => (/* binding */ parseOpusHead),\n/* harmony export */   setOpusHead: () => (/* binding */ setOpusHead)\n/* harmony export */ });\nvar OPUS_HEAD = new Uint8Array([// O, p, u, s\n0x4f, 0x70, 0x75, 0x73, // H, e, a, d\n0x48, 0x65, 0x61, 0x64]); // https://wiki.xiph.org/OggOpus\n// https://vfrmaniac.fushizen.eu/contents/opus_in_isobmff.html\n// https://opus-codec.org/docs/opusfile_api-0.7/structOpusHead.html\n\nvar parseOpusHead = function parseOpusHead(bytes) {\n  var view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  var version = view.getUint8(0); // version 0, from mp4, does not use littleEndian.\n\n  var littleEndian = version !== 0;\n  var config = {\n    version: version,\n    channels: view.getUint8(1),\n    preSkip: view.getUint16(2, littleEndian),\n    sampleRate: view.getUint32(4, littleEndian),\n    outputGain: view.getUint16(8, littleEndian),\n    channelMappingFamily: view.getUint8(10)\n  };\n\n  if (config.channelMappingFamily > 0 && bytes.length > 10) {\n    config.streamCount = view.getUint8(11);\n    config.twoChannelStreamCount = view.getUint8(12);\n    config.channelMapping = [];\n\n    for (var c = 0; c < config.channels; c++) {\n      config.channelMapping.push(view.getUint8(13 + c));\n    }\n  }\n\n  return config;\n};\nvar setOpusHead = function setOpusHead(config) {\n  var size = config.channelMappingFamily <= 0 ? 11 : 12 + config.channels;\n  var view = new DataView(new ArrayBuffer(size));\n  var littleEndian = config.version !== 0;\n  view.setUint8(0, config.version);\n  view.setUint8(1, config.channels);\n  view.setUint16(2, config.preSkip, littleEndian);\n  view.setUint32(4, config.sampleRate, littleEndian);\n  view.setUint16(8, config.outputGain, littleEndian);\n  view.setUint8(10, config.channelMappingFamily);\n\n  if (config.channelMappingFamily > 0) {\n    view.setUint8(11, config.streamCount);\n    config.channelMapping.foreach(function (cm, i) {\n      view.setUint8(12 + i, cm);\n    });\n  }\n\n  return new Uint8Array(view.buffer);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL29wdXMtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL29wdXMtaGVscGVycy5qcz8yNjIxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgT1BVU19IRUFEID0gbmV3IFVpbnQ4QXJyYXkoWy8vIE8sIHAsIHUsIHNcbjB4NGYsIDB4NzAsIDB4NzUsIDB4NzMsIC8vIEgsIGUsIGEsIGRcbjB4NDgsIDB4NjUsIDB4NjEsIDB4NjRdKTsgLy8gaHR0cHM6Ly93aWtpLnhpcGgub3JnL09nZ09wdXNcbi8vIGh0dHBzOi8vdmZybWFuaWFjLmZ1c2hpemVuLmV1L2NvbnRlbnRzL29wdXNfaW5faXNvYm1mZi5odG1sXG4vLyBodHRwczovL29wdXMtY29kZWMub3JnL2RvY3Mvb3B1c2ZpbGVfYXBpLTAuNy9zdHJ1Y3RPcHVzSGVhZC5odG1sXG5cbmV4cG9ydCB2YXIgcGFyc2VPcHVzSGVhZCA9IGZ1bmN0aW9uIHBhcnNlT3B1c0hlYWQoYnl0ZXMpIHtcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgdmFyIHZlcnNpb24gPSB2aWV3LmdldFVpbnQ4KDApOyAvLyB2ZXJzaW9uIDAsIGZyb20gbXA0LCBkb2VzIG5vdCB1c2UgbGl0dGxlRW5kaWFuLlxuXG4gIHZhciBsaXR0bGVFbmRpYW4gPSB2ZXJzaW9uICE9PSAwO1xuICB2YXIgY29uZmlnID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgY2hhbm5lbHM6IHZpZXcuZ2V0VWludDgoMSksXG4gICAgcHJlU2tpcDogdmlldy5nZXRVaW50MTYoMiwgbGl0dGxlRW5kaWFuKSxcbiAgICBzYW1wbGVSYXRlOiB2aWV3LmdldFVpbnQzMig0LCBsaXR0bGVFbmRpYW4pLFxuICAgIG91dHB1dEdhaW46IHZpZXcuZ2V0VWludDE2KDgsIGxpdHRsZUVuZGlhbiksXG4gICAgY2hhbm5lbE1hcHBpbmdGYW1pbHk6IHZpZXcuZ2V0VWludDgoMTApXG4gIH07XG5cbiAgaWYgKGNvbmZpZy5jaGFubmVsTWFwcGluZ0ZhbWlseSA+IDAgJiYgYnl0ZXMubGVuZ3RoID4gMTApIHtcbiAgICBjb25maWcuc3RyZWFtQ291bnQgPSB2aWV3LmdldFVpbnQ4KDExKTtcbiAgICBjb25maWcudHdvQ2hhbm5lbFN0cmVhbUNvdW50ID0gdmlldy5nZXRVaW50OCgxMik7XG4gICAgY29uZmlnLmNoYW5uZWxNYXBwaW5nID0gW107XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbmZpZy5jaGFubmVsczsgYysrKSB7XG4gICAgICBjb25maWcuY2hhbm5lbE1hcHBpbmcucHVzaCh2aWV3LmdldFVpbnQ4KDEzICsgYykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWc7XG59O1xuZXhwb3J0IHZhciBzZXRPcHVzSGVhZCA9IGZ1bmN0aW9uIHNldE9wdXNIZWFkKGNvbmZpZykge1xuICB2YXIgc2l6ZSA9IGNvbmZpZy5jaGFubmVsTWFwcGluZ0ZhbWlseSA8PSAwID8gMTEgOiAxMiArIGNvbmZpZy5jaGFubmVscztcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHNpemUpKTtcbiAgdmFyIGxpdHRsZUVuZGlhbiA9IGNvbmZpZy52ZXJzaW9uICE9PSAwO1xuICB2aWV3LnNldFVpbnQ4KDAsIGNvbmZpZy52ZXJzaW9uKTtcbiAgdmlldy5zZXRVaW50OCgxLCBjb25maWcuY2hhbm5lbHMpO1xuICB2aWV3LnNldFVpbnQxNigyLCBjb25maWcucHJlU2tpcCwgbGl0dGxlRW5kaWFuKTtcbiAgdmlldy5zZXRVaW50MzIoNCwgY29uZmlnLnNhbXBsZVJhdGUsIGxpdHRsZUVuZGlhbik7XG4gIHZpZXcuc2V0VWludDE2KDgsIGNvbmZpZy5vdXRwdXRHYWluLCBsaXR0bGVFbmRpYW4pO1xuICB2aWV3LnNldFVpbnQ4KDEwLCBjb25maWcuY2hhbm5lbE1hcHBpbmdGYW1pbHkpO1xuXG4gIGlmIChjb25maWcuY2hhbm5lbE1hcHBpbmdGYW1pbHkgPiAwKSB7XG4gICAgdmlldy5zZXRVaW50OCgxMSwgY29uZmlnLnN0cmVhbUNvdW50KTtcbiAgICBjb25maWcuY2hhbm5lbE1hcHBpbmcuZm9yZWFjaChmdW5jdGlvbiAoY20sIGkpIHtcbiAgICAgIHZpZXcuc2V0VWludDgoMTIgKyBpLCBjbSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/opus-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/resolve-url.js":
/*!***********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/resolve-url.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__);\n\nvar DEFAULT_LOCATION = 'https://example.com';\n\nvar resolveUrl = function resolveUrl(baseUrl, relativeUrl) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeUrl)) {\n    return relativeUrl;\n  } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n\n  if (/^data:/.test(baseUrl)) {\n    baseUrl = (global_window__WEBPACK_IMPORTED_MODULE_0___default().location) && (global_window__WEBPACK_IMPORTED_MODULE_0___default().location).href || '';\n  }\n\n  var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n  // and if baseUrl isn't an absolute url\n\n  var removeLocation = !(global_window__WEBPACK_IMPORTED_MODULE_0___default().location) && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n  baseUrl = new (global_window__WEBPACK_IMPORTED_MODULE_0___default().URL)(baseUrl, (global_window__WEBPACK_IMPORTED_MODULE_0___default().location) || DEFAULT_LOCATION);\n  var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n  // and if we're location-less, remove the location\n  // otherwise, return the url unmodified\n\n  if (removeLocation) {\n    return newUrl.href.slice(DEFAULT_LOCATION.length);\n  } else if (protocolLess) {\n    return newUrl.href.slice(newUrl.protocol.length);\n  }\n\n  return newUrl.href;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolveUrl);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL3Jlc29sdmUtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsY0FBYywrREFBZSxJQUFJLCtEQUFlO0FBQ2hEOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQSx3QkFBd0IsK0RBQWUsNEJBQTRCOztBQUVuRSxnQkFBZ0IsMERBQVUsVUFBVSwrREFBZTtBQUNuRCw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL3Jlc29sdmUtdXJsLmpzPzYwMDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbnZhciBERUZBVUxUX0xPQ0FUSU9OID0gJ2h0dHBzOi8vZXhhbXBsZS5jb20nO1xuXG52YXIgcmVzb2x2ZVVybCA9IGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZVVybCwgcmVsYXRpdmVVcmwpIHtcbiAgLy8gcmV0dXJuIGVhcmx5IGlmIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZVxuICBpZiAoL15bYS16XSs6L2kudGVzdChyZWxhdGl2ZVVybCkpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVVcmw7XG4gIH0gLy8gaWYgYmFzZVVybCBpcyBhIGRhdGEgVVJJLCBpZ25vcmUgaXQgYW5kIHJlc29sdmUgZXZlcnl0aGluZyByZWxhdGl2ZSB0byB3aW5kb3cubG9jYXRpb25cblxuXG4gIGlmICgvXmRhdGE6Ly50ZXN0KGJhc2VVcmwpKSB7XG4gICAgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbExlc3MgPSAvXlxcL1xcLy8udGVzdChiYXNlVXJsKTsgLy8gcmVtb3ZlIGxvY2F0aW9uIGlmIHdpbmRvdy5sb2NhdGlvbiBpc24ndCBhdmFpbGFibGUgKGkuZS4gd2UncmUgaW4gbm9kZSlcbiAgLy8gYW5kIGlmIGJhc2VVcmwgaXNuJ3QgYW4gYWJzb2x1dGUgdXJsXG5cbiAgdmFyIHJlbW92ZUxvY2F0aW9uID0gIXdpbmRvdy5sb2NhdGlvbiAmJiAhL1xcL1xcLy9pLnRlc3QoYmFzZVVybCk7IC8vIGlmIHRoZSBiYXNlIFVSTCBpcyByZWxhdGl2ZSB0aGVuIGNvbWJpbmUgd2l0aCB0aGUgY3VycmVudCBsb2NhdGlvblxuXG4gIGJhc2VVcmwgPSBuZXcgd2luZG93LlVSTChiYXNlVXJsLCB3aW5kb3cubG9jYXRpb24gfHwgREVGQVVMVF9MT0NBVElPTik7XG4gIHZhciBuZXdVcmwgPSBuZXcgVVJMKHJlbGF0aXZlVXJsLCBiYXNlVXJsKTsgLy8gaWYgd2UncmUgYSBwcm90b2NvbC1sZXNzIHVybCwgcmVtb3ZlIHRoZSBwcm90b2NvbFxuICAvLyBhbmQgaWYgd2UncmUgbG9jYXRpb24tbGVzcywgcmVtb3ZlIHRoZSBsb2NhdGlvblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgdXJsIHVubW9kaWZpZWRcblxuICBpZiAocmVtb3ZlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmV3VXJsLmhyZWYuc2xpY2UoREVGQVVMVF9MT0NBVElPTi5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKHByb3RvY29sTGVzcykge1xuICAgIHJldHVybiBuZXdVcmwuaHJlZi5zbGljZShuZXdVcmwucHJvdG9jb2wubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBuZXdVcmwuaHJlZjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVVcmw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/resolve-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/es/stream.js":
/*!******************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/es/stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Stream)\n/* harmony export */ });\n/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2VzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXNuYXBzaG90LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9lcy9zdHJlYW0uanM/YTgzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIHN0cmVhbS5qc1xuICovXG5cbi8qKlxuICogQSBsaWdodHdlaWdodCByZWFkYWJsZSBzdHJlYW0gaW1wbGVtZW50aW9uIHRoYXQgaGFuZGxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAqXG4gKiBAY2xhc3MgU3RyZWFtXG4gKi9cbnZhciBTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW0oKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIHRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYW4gZXZlbnQgb2ZcbiAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHJlYW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBmb3IgdGhpc1xuICAgKiB0eXBlIG9mIGV2ZW50IHRocm91Z2ggYG9uYFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiB3ZSBjb3VsZCB0dXJuIGl0IG9mZiBvciBub3RcbiAgICovXG4gIDtcblxuICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpOyAvLyBUT0RPOiB3aGljaCBpcyBiZXR0ZXI/XG4gICAgLy8gSW4gVmlkZW8uanMgd2Ugc2xpY2UgbGlzdGVuZXIgZnVuY3Rpb25zXG4gICAgLy8gb24gdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXMgbm90IG1lc3MgdXAgdGhlIG9yZGVyXG4gICAgLy8gd2hpbGUgd2UgbG9vcCB0aHJvdWdoLlxuICAgIC8vXG4gICAgLy8gSGVyZSB3ZSBzbGljZSBvbiBvZmYgc28gdGhhdCB0aGUgbG9vcCBpbiB0cmlnZ2VyXG4gICAgLy8gY2FuIGNvbnRpbnVlIHVzaW5nIGl0J3Mgb2xkIHJlZmVyZW5jZSB0byBsb29wIHdpdGhvdXRcbiAgICAvLyBtZXNzaW5nIHVwIHRoZSBvcmRlci5cblxuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uc2xpY2UoMCk7XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAqIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKHR5cGUpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG5cbiAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2xpY2luZyB0aGUgYXJndW1lbnRzIG9uIGV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2RcbiAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAvLyBpbnRlcm1lZGlhdGUgb2JqZWN0IGNyZWF0aW9uIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYVxuICAgIC8vIHNpbmdsZSBjYWxsYmFjayBhcmd1bWVudFxuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIF9sZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2xlbmd0aDsgKytfaSkge1xuICAgICAgICBjYWxsYmFja3NbX2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBGb3J3YXJkcyBhbGwgYGRhdGFgIGV2ZW50cyBvbiB0aGlzIHN0cmVhbSB0byB0aGUgZGVzdGluYXRpb24gc3RyZWFtLiBUaGVcbiAgICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gICAqIGV2ZW50cyBhcyB0aGV5IGFycml2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJlYW19IGRlc3RpbmF0aW9uIHRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgYWxsIGBkYXRhYCBldmVudHNcbiAgICogQHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3BpcGVfZGVzdGluYXRpb25fb3B0aW9uc1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5waXBlID0gZnVuY3Rpb24gcGlwZShkZXN0aW5hdGlvbikge1xuICAgIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3RyZWFtO1xufSgpO1xuXG5leHBvcnQgeyBTdHJlYW0gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/es/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/http-handler.js":
/*!*******************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/http-handler.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar window = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n\nvar httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {\n  if (decodeResponseBody === void 0) {\n    decodeResponseBody = false;\n  }\n\n  return function (err, response, responseBody) {\n    // if the XHR failed, return that error\n    if (err) {\n      callback(err);\n      return;\n    } // if the HTTP status code is 4xx or 5xx, the request also failed\n\n\n    if (response.statusCode >= 400 && response.statusCode <= 599) {\n      var cause = responseBody;\n\n      if (decodeResponseBody) {\n        if (window.TextDecoder) {\n          var charset = getCharset(response.headers && response.headers['content-type']);\n\n          try {\n            cause = new TextDecoder(charset).decode(responseBody);\n          } catch (e) {}\n        } else {\n          cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));\n        }\n      }\n\n      callback({\n        cause: cause\n      });\n      return;\n    } // otherwise, request succeeded\n\n\n    callback(null, responseBody);\n  };\n};\n\nfunction getCharset(contentTypeHeader) {\n  if (contentTypeHeader === void 0) {\n    contentTypeHeader = '';\n  }\n\n  return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {\n    var _contentType$split = contentType.split('='),\n        type = _contentType$split[0],\n        value = _contentType$split[1];\n\n    if (type.trim() === 'charset') {\n      return value.trim();\n    }\n\n    return charset;\n  }, 'utf-8');\n}\n\nmodule.exports = httpResponseHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9odHRwLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy94aHIvbGliL2h0dHAtaGFuZGxlci5qcz8zNDIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgaHR0cFJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uIGh0dHBSZXNwb25zZUhhbmRsZXIoY2FsbGJhY2ssIGRlY29kZVJlc3BvbnNlQm9keSkge1xuICBpZiAoZGVjb2RlUmVzcG9uc2VCb2R5ID09PSB2b2lkIDApIHtcbiAgICBkZWNvZGVSZXNwb25zZUJvZHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgLy8gaWYgdGhlIFhIUiBmYWlsZWQsIHJldHVybiB0aGF0IGVycm9yXG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHRoZSBIVFRQIHN0YXR1cyBjb2RlIGlzIDR4eCBvciA1eHgsIHRoZSByZXF1ZXN0IGFsc28gZmFpbGVkXG5cblxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDw9IDU5OSkge1xuICAgICAgdmFyIGNhdXNlID0gcmVzcG9uc2VCb2R5O1xuXG4gICAgICBpZiAoZGVjb2RlUmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIGlmICh3aW5kb3cuVGV4dERlY29kZXIpIHtcbiAgICAgICAgICB2YXIgY2hhcnNldCA9IGdldENoYXJzZXQocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2F1c2UgPSBuZXcgVGV4dERlY29kZXIoY2hhcnNldCkuZGVjb2RlKHJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXVzZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VCb2R5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBjYXVzZTogY2F1c2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCByZXF1ZXN0IHN1Y2NlZWRlZFxuXG5cbiAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZUJvZHkpO1xuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Q2hhcnNldChjb250ZW50VHlwZUhlYWRlcikge1xuICBpZiAoY29udGVudFR5cGVIZWFkZXIgPT09IHZvaWQgMCkge1xuICAgIGNvbnRlbnRUeXBlSGVhZGVyID0gJyc7XG4gIH1cblxuICByZXR1cm4gY29udGVudFR5cGVIZWFkZXIudG9Mb3dlckNhc2UoKS5zcGxpdCgnOycpLnJlZHVjZShmdW5jdGlvbiAoY2hhcnNldCwgY29udGVudFR5cGUpIHtcbiAgICB2YXIgX2NvbnRlbnRUeXBlJHNwbGl0ID0gY29udGVudFR5cGUuc3BsaXQoJz0nKSxcbiAgICAgICAgdHlwZSA9IF9jb250ZW50VHlwZSRzcGxpdFswXSxcbiAgICAgICAgdmFsdWUgPSBfY29udGVudFR5cGUkc3BsaXRbMV07XG5cbiAgICBpZiAodHlwZS50cmltKCkgPT09ICdjaGFyc2V0Jykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbiAgfSwgJ3V0Zi04Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHR0cFJlc3BvbnNlSGFuZGxlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/http-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar window = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n\nvar _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\n\nvar isFunction = __webpack_require__(/*! is-function */ \"(ssr)/./node_modules/is-function/index.js\");\n\nvar InterceptorsStorage = __webpack_require__(/*! ./interceptors.js */ \"(ssr)/./node_modules/@videojs/xhr/lib/interceptors.js\");\n\nvar RetryManager = __webpack_require__(/*! ./retry.js */ \"(ssr)/./node_modules/@videojs/xhr/lib/retry.js\");\n\ncreateXHR.httpHandler = __webpack_require__(/*! ./http-handler.js */ \"(ssr)/./node_modules/@videojs/xhr/lib/http-handler.js\");\ncreateXHR.requestInterceptorsStorage = new InterceptorsStorage();\ncreateXHR.responseInterceptorsStorage = new InterceptorsStorage();\ncreateXHR.retryManager = new RetryManager();\n/**\n * @license\n * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>\n * Copyright (c) 2014 David Bjrklund\n * Available under the MIT license\n * <https://github.com/kesla/parse-headers/blob/master/LICENCE>\n */\n\nvar parseHeaders = function parseHeaders(headers) {\n  var result = {};\n\n  if (!headers) {\n    return result;\n  }\n\n  headers.trim().split('\\n').forEach(function (row) {\n    var index = row.indexOf(':');\n    var key = row.slice(0, index).trim().toLowerCase();\n    var value = row.slice(index + 1).trim();\n\n    if (typeof result[key] === 'undefined') {\n      result[key] = value;\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value);\n    } else {\n      result[key] = [result[key], value];\n    }\n  });\n  return result;\n};\n\nmodule.exports = createXHR; // Allow use of default import syntax in TypeScript\n\nmodule.exports[\"default\"] = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop;\ncreateXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n  createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n    options = initParams(uri, options, callback);\n    options.method = method.toUpperCase();\n    return _createXHR(options);\n  };\n});\n\nfunction forEachArray(array, iterator) {\n  for (var i = 0; i < array.length; i++) {\n    iterator(array[i]);\n  }\n}\n\nfunction isEmpty(obj) {\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) return false;\n  }\n\n  return true;\n}\n\nfunction initParams(uri, options, callback) {\n  var params = uri;\n\n  if (isFunction(options)) {\n    callback = options;\n\n    if (typeof uri === \"string\") {\n      params = {\n        uri: uri\n      };\n    }\n  } else {\n    params = _extends({}, options, {\n      uri: uri\n    });\n  }\n\n  params.callback = callback;\n  return params;\n}\n\nfunction createXHR(uri, options, callback) {\n  options = initParams(uri, options, callback);\n  return _createXHR(options);\n}\n\nfunction _createXHR(options) {\n  if (typeof options.callback === \"undefined\") {\n    throw new Error(\"callback argument missing\");\n  } // call all registered request interceptors for a given request type:\n\n\n  if (options.requestType && createXHR.requestInterceptorsStorage.getIsEnabled()) {\n    var requestInterceptorPayload = {\n      uri: options.uri || options.url,\n      headers: options.headers || {},\n      body: options.body,\n      metadata: options.metadata || {},\n      retry: options.retry,\n      timeout: options.timeout\n    };\n    var updatedPayload = createXHR.requestInterceptorsStorage.execute(options.requestType, requestInterceptorPayload);\n    options.uri = updatedPayload.uri;\n    options.headers = updatedPayload.headers;\n    options.body = updatedPayload.body;\n    options.metadata = updatedPayload.metadata;\n    options.retry = updatedPayload.retry;\n    options.timeout = updatedPayload.timeout;\n  }\n\n  var called = false;\n\n  var callback = function cbOnce(err, response, body) {\n    if (!called) {\n      called = true;\n      options.callback(err, response, body);\n    }\n  };\n\n  function readystatechange() {\n    // do not call load 2 times when response interceptors are enabled\n    // why do we even need this 2nd load?\n    if (xhr.readyState === 4 && !createXHR.responseInterceptorsStorage.getIsEnabled()) {\n      setTimeout(loadFunc, 0);\n    }\n  }\n\n  function getBody() {\n    // Chrome with requestType=blob throws errors arround when even testing access to responseText\n    var body = undefined;\n\n    if (xhr.response) {\n      body = xhr.response;\n    } else {\n      body = xhr.responseText || getXml(xhr);\n    }\n\n    if (isJson) {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {}\n    }\n\n    return body;\n  }\n\n  function errorFunc(evt) {\n    clearTimeout(timeoutTimer);\n    clearTimeout(options.retryTimeout);\n\n    if (!(evt instanceof Error)) {\n      evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n    }\n\n    evt.statusCode = 0; // we would like to retry on error:\n\n    if (!aborted && createXHR.retryManager.getIsEnabled() && options.retry && options.retry.shouldRetry()) {\n      options.retryTimeout = setTimeout(function () {\n        options.retry.moveToNextAttempt(); // we want to re-use the same options and the same xhr object:\n\n        options.xhr = xhr;\n\n        _createXHR(options);\n      }, options.retry.getCurrentFuzzedDelay());\n      return;\n    } // call all registered response interceptors for a given request type:\n\n\n    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {\n      var responseInterceptorPayload = {\n        headers: failureResponse.headers || {},\n        body: failureResponse.body,\n        responseUrl: xhr.responseURL,\n        responseType: xhr.responseType\n      };\n\n      var _updatedPayload = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);\n\n      failureResponse.body = _updatedPayload.body;\n      failureResponse.headers = _updatedPayload.headers;\n    }\n\n    return callback(evt, failureResponse);\n  } // will load the data & process the response in a special response object\n\n\n  function loadFunc() {\n    if (aborted) return;\n    var status;\n    clearTimeout(timeoutTimer);\n    clearTimeout(options.retryTimeout);\n\n    if (options.useXDR && xhr.status === undefined) {\n      //IE8 CORS GET successful response doesn't have a status field, but body is fine\n      status = 200;\n    } else {\n      status = xhr.status === 1223 ? 204 : xhr.status;\n    }\n\n    var response = failureResponse;\n    var err = null;\n\n    if (status !== 0) {\n      response = {\n        body: getBody(),\n        statusCode: status,\n        method: method,\n        headers: {},\n        url: uri,\n        rawRequest: xhr\n      };\n\n      if (xhr.getAllResponseHeaders) {\n        //remember xhr can in fact be XDR for CORS in IE\n        response.headers = parseHeaders(xhr.getAllResponseHeaders());\n      }\n    } else {\n      err = new Error(\"Internal XMLHttpRequest Error\");\n    } // call all registered response interceptors for a given request type:\n\n\n    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {\n      var responseInterceptorPayload = {\n        headers: response.headers || {},\n        body: response.body,\n        responseUrl: xhr.responseURL,\n        responseType: xhr.responseType\n      };\n\n      var _updatedPayload2 = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);\n\n      response.body = _updatedPayload2.body;\n      response.headers = _updatedPayload2.headers;\n    }\n\n    return callback(err, response, response.body);\n  }\n\n  var xhr = options.xhr || null;\n\n  if (!xhr) {\n    if (options.cors || options.useXDR) {\n      xhr = new createXHR.XDomainRequest();\n    } else {\n      xhr = new createXHR.XMLHttpRequest();\n    }\n  }\n\n  var key;\n  var aborted;\n  var uri = xhr.url = options.uri || options.url;\n  var method = xhr.method = options.method || \"GET\";\n  var body = options.body || options.data;\n  var headers = xhr.headers = options.headers || {};\n  var sync = !!options.sync;\n  var isJson = false;\n  var timeoutTimer;\n  var failureResponse = {\n    body: undefined,\n    headers: {},\n    statusCode: 0,\n    method: method,\n    url: uri,\n    rawRequest: xhr\n  };\n\n  if (\"json\" in options && options.json !== false) {\n    isJson = true;\n    headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n      body = JSON.stringify(options.json === true ? body : options.json);\n    }\n  }\n\n  xhr.onreadystatechange = readystatechange;\n  xhr.onload = loadFunc;\n  xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.\n\n  xhr.onprogress = function () {// IE must die\n  };\n\n  xhr.onabort = function () {\n    aborted = true;\n    clearTimeout(options.retryTimeout);\n  };\n\n  xhr.ontimeout = errorFunc;\n  xhr.open(method, uri, !sync, options.username, options.password); //has to be after open\n\n  if (!sync) {\n    xhr.withCredentials = !!options.withCredentials;\n  } // Cannot set timeout with sync request\n  // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n  // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n\n\n  if (!sync && options.timeout > 0) {\n    timeoutTimer = setTimeout(function () {\n      if (aborted) return;\n      aborted = true; //IE9 may still call readystatechange\n\n      xhr.abort(\"timeout\");\n      var e = new Error(\"XMLHttpRequest timeout\");\n      e.code = \"ETIMEDOUT\";\n      errorFunc(e);\n    }, options.timeout);\n  }\n\n  if (xhr.setRequestHeader) {\n    for (key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  } else if (options.headers && !isEmpty(options.headers)) {\n    throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n  }\n\n  if (\"responseType\" in options) {\n    xhr.responseType = options.responseType;\n  }\n\n  if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n    options.beforeSend(xhr);\n  } // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n  // XMLHttpRequest spec says to pass null as body to indicate no body\n  // See https://github.com/naugtur/xhr/issues/100.\n\n\n  xhr.send(body || null);\n  return xhr;\n}\n\nfunction getXml(xhr) {\n  // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n  // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n  try {\n    if (xhr.responseType === \"document\") {\n      return xhr.responseXML;\n    }\n\n    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n\n    if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n      return xhr.responseXML;\n    }\n  } catch (e) {}\n\n  return null;\n}\n\nfunction noop() {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNERBQWU7O0FBRXBDLGVBQWUsbUJBQU8sQ0FBQyw4RkFBZ0M7O0FBRXZELGlCQUFpQixtQkFBTyxDQUFDLDhEQUFhOztBQUV0QywwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBbUI7O0FBRXJELG1CQUFtQixtQkFBTyxDQUFDLGtFQUFZOztBQUV2Qyx3QkFBd0IsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qix5QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0EsNEdBQTRHOztBQUU1RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0IsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXNuYXBzaG90LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3hoci9saWIvaW5kZXguanM/ZWYwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpO1xuXG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJyk7XG5cbnZhciBJbnRlcmNlcHRvcnNTdG9yYWdlID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvcnMuanMnKTtcblxudmFyIFJldHJ5TWFuYWdlciA9IHJlcXVpcmUoXCIuL3JldHJ5LmpzXCIpO1xuXG5jcmVhdGVYSFIuaHR0cEhhbmRsZXIgPSByZXF1aXJlKCcuL2h0dHAtaGFuZGxlci5qcycpO1xuY3JlYXRlWEhSLnJlcXVlc3RJbnRlcmNlcHRvcnNTdG9yYWdlID0gbmV3IEludGVyY2VwdG9yc1N0b3JhZ2UoKTtcbmNyZWF0ZVhIUi5yZXNwb25zZUludGVyY2VwdG9yc1N0b3JhZ2UgPSBuZXcgSW50ZXJjZXB0b3JzU3RvcmFnZSgpO1xuY3JlYXRlWEhSLnJldHJ5TWFuYWdlciA9IG5ldyBSZXRyeU1hbmFnZXIoKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIHNsaWdobHkgbW9kaWZpZWQgcGFyc2UtaGVhZGVycyAyLjAuMiA8aHR0cHM6Ly9naXRodWIuY29tL2tlc2xhL3BhcnNlLWhlYWRlcnMvPlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERhdmlkIEJqw7Zya2x1bmRcbiAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIDxodHRwczovL2dpdGh1Yi5jb20va2VzbGEvcGFyc2UtaGVhZGVycy9ibG9iL21hc3Rlci9MSUNFTkNFPlxuICovXG5cbnZhciBwYXJzZUhlYWRlcnMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGhlYWRlcnMudHJpbSgpLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpO1xuICAgIHZhciBrZXkgPSByb3cuc2xpY2UoMCwgaW5kZXgpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IHJvdy5zbGljZShpbmRleCArIDEpLnRyaW0oKTtcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IFtyZXN1bHRba2V5XSwgdmFsdWVdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUjsgLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVYSFI7XG5jcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcDtcbmNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gbmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0O1xuZm9yRWFjaEFycmF5KFtcImdldFwiLCBcInB1dFwiLCBcInBvc3RcIiwgXCJwYXRjaFwiLCBcImhlYWRcIiwgXCJkZWxldGVcIl0sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgY3JlYXRlWEhSW21ldGhvZCA9PT0gXCJkZWxldGVcIiA/IFwiZGVsXCIgOiBtZXRob2RdID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGl0ZXJhdG9yKGFycmF5W2ldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmFtcyA9IHVyaTtcblxuICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcblxuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXJhbXMgPSB7XG4gICAgICAgIHVyaTogdXJpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgdXJpOiB1cmlcbiAgICB9KTtcbiAgfVxuXG4gIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVYSFIodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVYSFIob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpO1xuICB9IC8vIGNhbGwgYWxsIHJlZ2lzdGVyZWQgcmVxdWVzdCBpbnRlcmNlcHRvcnMgZm9yIGEgZ2l2ZW4gcmVxdWVzdCB0eXBlOlxuXG5cbiAgaWYgKG9wdGlvbnMucmVxdWVzdFR5cGUgJiYgY3JlYXRlWEhSLnJlcXVlc3RJbnRlcmNlcHRvcnNTdG9yYWdlLmdldElzRW5hYmxlZCgpKSB7XG4gICAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvclBheWxvYWQgPSB7XG4gICAgICB1cmk6IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHt9LFxuICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEgfHwge30sXG4gICAgICByZXRyeTogb3B0aW9ucy5yZXRyeSxcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dFxuICAgIH07XG4gICAgdmFyIHVwZGF0ZWRQYXlsb2FkID0gY3JlYXRlWEhSLnJlcXVlc3RJbnRlcmNlcHRvcnNTdG9yYWdlLmV4ZWN1dGUob3B0aW9ucy5yZXF1ZXN0VHlwZSwgcmVxdWVzdEludGVyY2VwdG9yUGF5bG9hZCk7XG4gICAgb3B0aW9ucy51cmkgPSB1cGRhdGVkUGF5bG9hZC51cmk7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gdXBkYXRlZFBheWxvYWQuaGVhZGVycztcbiAgICBvcHRpb25zLmJvZHkgPSB1cGRhdGVkUGF5bG9hZC5ib2R5O1xuICAgIG9wdGlvbnMubWV0YWRhdGEgPSB1cGRhdGVkUGF5bG9hZC5tZXRhZGF0YTtcbiAgICBvcHRpb25zLnJldHJ5ID0gdXBkYXRlZFBheWxvYWQucmV0cnk7XG4gICAgb3B0aW9ucy50aW1lb3V0ID0gdXBkYXRlZFBheWxvYWQudGltZW91dDtcbiAgfVxuXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAvLyBkbyBub3QgY2FsbCBsb2FkIDIgdGltZXMgd2hlbiByZXNwb25zZSBpbnRlcmNlcHRvcnMgYXJlIGVuYWJsZWRcbiAgICAvLyB3aHkgZG8gd2UgZXZlbiBuZWVkIHRoaXMgMm5kIGxvYWQ/XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmICFjcmVhdGVYSFIucmVzcG9uc2VJbnRlcmNlcHRvcnNTdG9yYWdlLmdldElzRW5hYmxlZCgpKSB7XG4gICAgICBzZXRUaW1lb3V0KGxvYWRGdW5jLCAwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICB2YXIgYm9keSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IGdldFhtbCh4aHIpO1xuICAgIH1cblxuICAgIGlmIChpc0pzb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQob3B0aW9ucy5yZXRyeVRpbWVvdXQpO1xuXG4gICAgaWYgKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpKTtcbiAgICB9XG5cbiAgICBldnQuc3RhdHVzQ29kZSA9IDA7IC8vIHdlIHdvdWxkIGxpa2UgdG8gcmV0cnkgb24gZXJyb3I6XG5cbiAgICBpZiAoIWFib3J0ZWQgJiYgY3JlYXRlWEhSLnJldHJ5TWFuYWdlci5nZXRJc0VuYWJsZWQoKSAmJiBvcHRpb25zLnJldHJ5ICYmIG9wdGlvbnMucmV0cnkuc2hvdWxkUmV0cnkoKSkge1xuICAgICAgb3B0aW9ucy5yZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9ucy5yZXRyeS5tb3ZlVG9OZXh0QXR0ZW1wdCgpOyAvLyB3ZSB3YW50IHRvIHJlLXVzZSB0aGUgc2FtZSBvcHRpb25zIGFuZCB0aGUgc2FtZSB4aHIgb2JqZWN0OlxuXG4gICAgICAgIG9wdGlvbnMueGhyID0geGhyO1xuXG4gICAgICAgIF9jcmVhdGVYSFIob3B0aW9ucyk7XG4gICAgICB9LCBvcHRpb25zLnJldHJ5LmdldEN1cnJlbnRGdXp6ZWREZWxheSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNhbGwgYWxsIHJlZ2lzdGVyZWQgcmVzcG9uc2UgaW50ZXJjZXB0b3JzIGZvciBhIGdpdmVuIHJlcXVlc3QgdHlwZTpcblxuXG4gICAgaWYgKG9wdGlvbnMucmVxdWVzdFR5cGUgJiYgY3JlYXRlWEhSLnJlc3BvbnNlSW50ZXJjZXB0b3JzU3RvcmFnZS5nZXRJc0VuYWJsZWQoKSkge1xuICAgICAgdmFyIHJlc3BvbnNlSW50ZXJjZXB0b3JQYXlsb2FkID0ge1xuICAgICAgICBoZWFkZXJzOiBmYWlsdXJlUmVzcG9uc2UuaGVhZGVycyB8fCB7fSxcbiAgICAgICAgYm9keTogZmFpbHVyZVJlc3BvbnNlLmJvZHksXG4gICAgICAgIHJlc3BvbnNlVXJsOiB4aHIucmVzcG9uc2VVUkwsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogeGhyLnJlc3BvbnNlVHlwZVxuICAgICAgfTtcblxuICAgICAgdmFyIF91cGRhdGVkUGF5bG9hZCA9IGNyZWF0ZVhIUi5yZXNwb25zZUludGVyY2VwdG9yc1N0b3JhZ2UuZXhlY3V0ZShvcHRpb25zLnJlcXVlc3RUeXBlLCByZXNwb25zZUludGVyY2VwdG9yUGF5bG9hZCk7XG5cbiAgICAgIGZhaWx1cmVSZXNwb25zZS5ib2R5ID0gX3VwZGF0ZWRQYXlsb2FkLmJvZHk7XG4gICAgICBmYWlsdXJlUmVzcG9uc2UuaGVhZGVycyA9IF91cGRhdGVkUGF5bG9hZC5oZWFkZXJzO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhldnQsIGZhaWx1cmVSZXNwb25zZSk7XG4gIH0gLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuXG5cbiAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XG4gICAgaWYgKGFib3J0ZWQpIHJldHVybjtcbiAgICB2YXIgc3RhdHVzO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xuICAgIGNsZWFyVGltZW91dChvcHRpb25zLnJldHJ5VGltZW91dCk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvL0lFOCBDT1JTIEdFVCBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cyBmaWVsZCwgYnV0IGJvZHkgaXMgZmluZVxuICAgICAgc3RhdHVzID0gMjAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0dXMgPSB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cztcbiAgICB9XG5cbiAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2U7XG4gICAgdmFyIGVyciA9IG51bGw7XG5cbiAgICBpZiAoc3RhdHVzICE9PSAwKSB7XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgdXJsOiB1cmksXG4gICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgfTtcblxuICAgICAgaWYgKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIik7XG4gICAgfSAvLyBjYWxsIGFsbCByZWdpc3RlcmVkIHJlc3BvbnNlIGludGVyY2VwdG9ycyBmb3IgYSBnaXZlbiByZXF1ZXN0IHR5cGU6XG5cblxuICAgIGlmIChvcHRpb25zLnJlcXVlc3RUeXBlICYmIGNyZWF0ZVhIUi5yZXNwb25zZUludGVyY2VwdG9yc1N0b3JhZ2UuZ2V0SXNFbmFibGVkKCkpIHtcbiAgICAgIHZhciByZXNwb25zZUludGVyY2VwdG9yUGF5bG9hZCA9IHtcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyB8fCB7fSxcbiAgICAgICAgYm9keTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgcmVzcG9uc2VVcmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiB4aHIucmVzcG9uc2VUeXBlXG4gICAgICB9O1xuXG4gICAgICB2YXIgX3VwZGF0ZWRQYXlsb2FkMiA9IGNyZWF0ZVhIUi5yZXNwb25zZUludGVyY2VwdG9yc1N0b3JhZ2UuZXhlY3V0ZShvcHRpb25zLnJlcXVlc3RUeXBlLCByZXNwb25zZUludGVyY2VwdG9yUGF5bG9hZCk7XG5cbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBfdXBkYXRlZFBheWxvYWQyLmJvZHk7XG4gICAgICByZXNwb25zZS5oZWFkZXJzID0gX3VwZGF0ZWRQYXlsb2FkMi5oZWFkZXJzO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KTtcbiAgfVxuXG4gIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsO1xuXG4gIGlmICgheGhyKSB7XG4gICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGtleTtcbiAgdmFyIGFib3J0ZWQ7XG4gIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmw7XG4gIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIjtcbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhO1xuICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB2YXIgaXNKc29uID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0VGltZXI7XG4gIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgYm9keTogdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgdXJsOiB1cmksXG4gICAgcmF3UmVxdWVzdDogeGhyXG4gIH07XG5cbiAgaWYgKFwianNvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgIGlzSnNvbiA9IHRydWU7XG4gICAgaGVhZGVyc1tcImFjY2VwdFwiXSB8fCBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpOyAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuXG4gICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gfHwgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIik7IC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG5cbiAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24gPT09IHRydWUgPyBib2R5IDogb3B0aW9ucy5qc29uKTtcbiAgICB9XG4gIH1cblxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZTtcbiAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jO1xuICB4aHIub25lcnJvciA9IGVycm9yRnVuYzsgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cblxuICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHsvLyBJRSBtdXN0IGRpZVxuICB9O1xuXG4gIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgIGNsZWFyVGltZW91dChvcHRpb25zLnJldHJ5VGltZW91dCk7XG4gIH07XG5cbiAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuYztcbiAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKTsgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuXG4gIGlmICghc3luYykge1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xuICB9IC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuXG5cbiAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhYm9ydGVkKSByZXR1cm47XG4gICAgICBhYm9ydGVkID0gdHJ1ZTsgLy9JRTkgbWF5IHN0aWxsIGNhbGwgcmVhZHlzdGF0ZWNoYW5nZVxuXG4gICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCB0aW1lb3V0XCIpO1xuICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgIGVycm9yRnVuYyhlKTtcbiAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgZm9yIChrZXkgaW4gaGVhZGVycykge1xuICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKTtcbiAgfVxuXG4gIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gIH1cblxuICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKTtcbiAgfSAvLyBNaWNyb3NvZnQgRWRnZSBicm93c2VyIHNlbmRzIFwidW5kZWZpbmVkXCIgd2hlbiBzZW5kIGlzIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCB2YWx1ZS5cbiAgLy8gWE1MSHR0cFJlcXVlc3Qgc3BlYyBzYXlzIHRvIHBhc3MgbnVsbCBhcyBib2R5IHRvIGluZGljYXRlIG5vIGJvZHlcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXVndHVyL3hoci9pc3N1ZXMvMTAwLlxuXG5cbiAgeGhyLnNlbmQoYm9keSB8fCBudWxsKTtcbiAgcmV0dXJuIHhocjtcbn1cblxuZnVuY3Rpb24gZ2V0WG1sKHhocikge1xuICAvLyB4aHIucmVzcG9uc2VYTUwgd2lsbCB0aHJvdyBFeGNlcHRpb24gXCJJbnZhbGlkU3RhdGVFcnJvclwiIG9yIFwiRE9NRXhjZXB0aW9uXCJcbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZXNwb25zZVhNTC5cbiAgdHJ5IHtcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MO1xuICAgIH1cblxuICAgIHZhciBmaXJlZm94QnVnVGFrZW5FZmZlY3QgPSB4aHIucmVzcG9uc2VYTUwgJiYgeGhyLnJlc3BvbnNlWE1MLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXJzZXJlcnJvclwiO1xuXG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgJiYgIWZpcmVmb3hCdWdUYWtlbkVmZmVjdCkge1xuICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/interceptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/interceptors.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar InterceptorsStorage = /*#__PURE__*/function () {\n  function InterceptorsStorage() {\n    this.typeToInterceptorsMap_ = new Map();\n    this.enabled_ = false;\n  }\n\n  var _proto = InterceptorsStorage.prototype;\n\n  _proto.getIsEnabled = function getIsEnabled() {\n    return this.enabled_;\n  };\n\n  _proto.enable = function enable() {\n    this.enabled_ = true;\n  };\n\n  _proto.disable = function disable() {\n    this.enabled_ = false;\n  };\n\n  _proto.reset = function reset() {\n    this.typeToInterceptorsMap_ = new Map();\n    this.enabled_ = false;\n  };\n\n  _proto.addInterceptor = function addInterceptor(type, interceptor) {\n    if (!this.typeToInterceptorsMap_.has(type)) {\n      this.typeToInterceptorsMap_.set(type, new Set());\n    }\n\n    var interceptorsSet = this.typeToInterceptorsMap_.get(type);\n\n    if (interceptorsSet.has(interceptor)) {\n      // already have this interceptor\n      return false;\n    }\n\n    interceptorsSet.add(interceptor);\n    return true;\n  };\n\n  _proto.removeInterceptor = function removeInterceptor(type, interceptor) {\n    var interceptorsSet = this.typeToInterceptorsMap_.get(type);\n\n    if (interceptorsSet && interceptorsSet.has(interceptor)) {\n      interceptorsSet.delete(interceptor);\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.clearInterceptorsByType = function clearInterceptorsByType(type) {\n    var interceptorsSet = this.typeToInterceptorsMap_.get(type);\n\n    if (!interceptorsSet) {\n      return false;\n    }\n\n    this.typeToInterceptorsMap_.delete(type);\n    this.typeToInterceptorsMap_.set(type, new Set());\n    return true;\n  };\n\n  _proto.clear = function clear() {\n    if (!this.typeToInterceptorsMap_.size) {\n      return false;\n    }\n\n    this.typeToInterceptorsMap_ = new Map();\n    return true;\n  };\n\n  _proto.getForType = function getForType(type) {\n    return this.typeToInterceptorsMap_.get(type) || new Set();\n  };\n\n  _proto.execute = function execute(type, payload) {\n    var interceptors = this.getForType(type);\n\n    for (var _iterator = _createForOfIteratorHelperLoose(interceptors), _step; !(_step = _iterator()).done;) {\n      var interceptor = _step.value;\n\n      try {\n        payload = interceptor(payload);\n      } catch (e) {//ignore\n      }\n    }\n\n    return payload;\n  };\n\n  return InterceptorsStorage;\n}();\n\nmodule.exports = InterceptorsStorage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9pbnRlcmNlcHRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOERBQThELGlGQUFpRixnREFBZ0Qsd0hBQXdILGdCQUFnQixXQUFXLHFCQUFxQiw0QkFBNEIsY0FBYyxTQUFTLG1DQUFtQzs7QUFFN2Isa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFLDRCQUE0QjtBQUMzRzs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zbmFwc2hvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy94aHIvbGliL2ludGVyY2VwdG9ycy5qcz82MWRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIEludGVyY2VwdG9yc1N0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlcmNlcHRvcnNTdG9yYWdlKCkge1xuICAgIHRoaXMudHlwZVRvSW50ZXJjZXB0b3JzTWFwXyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW50ZXJjZXB0b3JzU3RvcmFnZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldElzRW5hYmxlZCA9IGZ1bmN0aW9uIGdldElzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkXztcbiAgfTtcblxuICBfcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uYWRkSW50ZXJjZXB0b3IgPSBmdW5jdGlvbiBhZGRJbnRlcmNlcHRvcih0eXBlLCBpbnRlcmNlcHRvcikge1xuICAgIGlmICghdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLmhhcyh0eXBlKSkge1xuICAgICAgdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIHZhciBpbnRlcmNlcHRvcnNTZXQgPSB0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8uZ2V0KHR5cGUpO1xuXG4gICAgaWYgKGludGVyY2VwdG9yc1NldC5oYXMoaW50ZXJjZXB0b3IpKSB7XG4gICAgICAvLyBhbHJlYWR5IGhhdmUgdGhpcyBpbnRlcmNlcHRvclxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGludGVyY2VwdG9yc1NldC5hZGQoaW50ZXJjZXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVJbnRlcmNlcHRvciA9IGZ1bmN0aW9uIHJlbW92ZUludGVyY2VwdG9yKHR5cGUsIGludGVyY2VwdG9yKSB7XG4gICAgdmFyIGludGVyY2VwdG9yc1NldCA9IHRoaXMudHlwZVRvSW50ZXJjZXB0b3JzTWFwXy5nZXQodHlwZSk7XG5cbiAgICBpZiAoaW50ZXJjZXB0b3JzU2V0ICYmIGludGVyY2VwdG9yc1NldC5oYXMoaW50ZXJjZXB0b3IpKSB7XG4gICAgICBpbnRlcmNlcHRvcnNTZXQuZGVsZXRlKGludGVyY2VwdG9yKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJJbnRlcmNlcHRvcnNCeVR5cGUgPSBmdW5jdGlvbiBjbGVhckludGVyY2VwdG9yc0J5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGludGVyY2VwdG9yc1NldCA9IHRoaXMudHlwZVRvSW50ZXJjZXB0b3JzTWFwXy5nZXQodHlwZSk7XG5cbiAgICBpZiAoIWludGVyY2VwdG9yc1NldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudHlwZVRvSW50ZXJjZXB0b3JzTWFwXy5kZWxldGUodHlwZSk7XG4gICAgdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmICghdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8gPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmdldEZvclR5cGUgPSBmdW5jdGlvbiBnZXRGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLmdldCh0eXBlKSB8fCBuZXcgU2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLmV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKHR5cGUsIHBheWxvYWQpIHtcbiAgICB2YXIgaW50ZXJjZXB0b3JzID0gdGhpcy5nZXRGb3JUeXBlKHR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShpbnRlcmNlcHRvcnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGludGVyY2VwdG9yID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBheWxvYWQgPSBpbnRlcmNlcHRvcihwYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsvL2lnbm9yZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcmNlcHRvcnNTdG9yYWdlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yc1N0b3JhZ2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/retry.js":
/*!************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/retry.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nvar RetryManager = /*#__PURE__*/function () {\n  function RetryManager() {\n    this.maxAttempts_ = 1;\n    this.delayFactor_ = 0.1;\n    this.fuzzFactor_ = 0.1;\n    this.initialDelay_ = 1000;\n    this.enabled_ = false;\n  }\n\n  var _proto = RetryManager.prototype;\n\n  _proto.getIsEnabled = function getIsEnabled() {\n    return this.enabled_;\n  };\n\n  _proto.enable = function enable() {\n    this.enabled_ = true;\n  };\n\n  _proto.disable = function disable() {\n    this.enabled_ = false;\n  };\n\n  _proto.reset = function reset() {\n    this.maxAttempts_ = 1;\n    this.delayFactor_ = 0.1;\n    this.fuzzFactor_ = 0.1;\n    this.initialDelay_ = 1000;\n    this.enabled_ = false;\n  };\n\n  _proto.getMaxAttempts = function getMaxAttempts() {\n    return this.maxAttempts_;\n  };\n\n  _proto.setMaxAttempts = function setMaxAttempts(maxAttempts) {\n    this.maxAttempts_ = maxAttempts;\n  };\n\n  _proto.getDelayFactor = function getDelayFactor() {\n    return this.delayFactor_;\n  };\n\n  _proto.setDelayFactor = function setDelayFactor(delayFactor) {\n    this.delayFactor_ = delayFactor;\n  };\n\n  _proto.getFuzzFactor = function getFuzzFactor() {\n    return this.fuzzFactor_;\n  };\n\n  _proto.setFuzzFactor = function setFuzzFactor(fuzzFactor) {\n    this.fuzzFactor_ = fuzzFactor;\n  };\n\n  _proto.getInitialDelay = function getInitialDelay() {\n    return this.initialDelay_;\n  };\n\n  _proto.setInitialDelay = function setInitialDelay(initialDelay) {\n    this.initialDelay_ = initialDelay;\n  };\n\n  _proto.createRetry = function createRetry(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        maxAttempts = _ref.maxAttempts,\n        delayFactor = _ref.delayFactor,\n        fuzzFactor = _ref.fuzzFactor,\n        initialDelay = _ref.initialDelay;\n\n    return new Retry({\n      maxAttempts: maxAttempts || this.maxAttempts_,\n      delayFactor: delayFactor || this.delayFactor_,\n      fuzzFactor: fuzzFactor || this.fuzzFactor_,\n      initialDelay: initialDelay || this.initialDelay_\n    });\n  };\n\n  return RetryManager;\n}();\n\nvar Retry = /*#__PURE__*/function () {\n  function Retry(options) {\n    this.maxAttempts_ = options.maxAttempts;\n    this.delayFactor_ = options.delayFactor;\n    this.fuzzFactor_ = options.fuzzFactor;\n    this.currentDelay_ = options.initialDelay;\n    this.currentAttempt_ = 1;\n  }\n\n  var _proto2 = Retry.prototype;\n\n  _proto2.moveToNextAttempt = function moveToNextAttempt() {\n    this.currentAttempt_++;\n    var delayDelta = this.currentDelay_ * this.delayFactor_;\n    this.currentDelay_ = this.currentDelay_ + delayDelta;\n  };\n\n  _proto2.shouldRetry = function shouldRetry() {\n    return this.currentAttempt_ < this.maxAttempts_;\n  };\n\n  _proto2.getCurrentDelay = function getCurrentDelay() {\n    return this.currentDelay_;\n  };\n\n  _proto2.getCurrentMinPossibleDelay = function getCurrentMinPossibleDelay() {\n    return (1 - this.fuzzFactor_) * this.currentDelay_;\n  };\n\n  _proto2.getCurrentMaxPossibleDelay = function getCurrentMaxPossibleDelay() {\n    return (1 + this.fuzzFactor_) * this.currentDelay_;\n  }\n  /**\n   * For example fuzzFactor is 0.1\n   * This means 10% deviation\n   * So if we have delay as 1000\n   * This function can generate any value from 900 to 1100\n   */\n  ;\n\n  _proto2.getCurrentFuzzedDelay = function getCurrentFuzzedDelay() {\n    var lowValue = this.getCurrentMinPossibleDelay();\n    var highValue = this.getCurrentMaxPossibleDelay();\n    return lowValue + Math.random() * (highValue - lowValue);\n  };\n\n  return Retry;\n}();\n\nmodule.exports = RetryManager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9yZXRyeS5qcz9kZjk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgUmV0cnlNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmV0cnlNYW5hZ2VyKCkge1xuICAgIHRoaXMubWF4QXR0ZW1wdHNfID0gMTtcbiAgICB0aGlzLmRlbGF5RmFjdG9yXyA9IDAuMTtcbiAgICB0aGlzLmZ1enpGYWN0b3JfID0gMC4xO1xuICAgIHRoaXMuaW5pdGlhbERlbGF5XyA9IDEwMDA7XG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJldHJ5TWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldElzRW5hYmxlZCA9IGZ1bmN0aW9uIGdldElzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkXztcbiAgfTtcblxuICBfcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5tYXhBdHRlbXB0c18gPSAxO1xuICAgIHRoaXMuZGVsYXlGYWN0b3JfID0gMC4xO1xuICAgIHRoaXMuZnV6ekZhY3Rvcl8gPSAwLjE7XG4gICAgdGhpcy5pbml0aWFsRGVsYXlfID0gMTAwMDtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmdldE1heEF0dGVtcHRzID0gZnVuY3Rpb24gZ2V0TWF4QXR0ZW1wdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QXR0ZW1wdHNfO1xuICB9O1xuXG4gIF9wcm90by5zZXRNYXhBdHRlbXB0cyA9IGZ1bmN0aW9uIHNldE1heEF0dGVtcHRzKG1heEF0dGVtcHRzKSB7XG4gICAgdGhpcy5tYXhBdHRlbXB0c18gPSBtYXhBdHRlbXB0cztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVsYXlGYWN0b3IgPSBmdW5jdGlvbiBnZXREZWxheUZhY3RvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxheUZhY3Rvcl87XG4gIH07XG5cbiAgX3Byb3RvLnNldERlbGF5RmFjdG9yID0gZnVuY3Rpb24gc2V0RGVsYXlGYWN0b3IoZGVsYXlGYWN0b3IpIHtcbiAgICB0aGlzLmRlbGF5RmFjdG9yXyA9IGRlbGF5RmFjdG9yO1xuICB9O1xuXG4gIF9wcm90by5nZXRGdXp6RmFjdG9yID0gZnVuY3Rpb24gZ2V0RnV6ekZhY3RvcigpIHtcbiAgICByZXR1cm4gdGhpcy5mdXp6RmFjdG9yXztcbiAgfTtcblxuICBfcHJvdG8uc2V0RnV6ekZhY3RvciA9IGZ1bmN0aW9uIHNldEZ1enpGYWN0b3IoZnV6ekZhY3Rvcikge1xuICAgIHRoaXMuZnV6ekZhY3Rvcl8gPSBmdXp6RmFjdG9yO1xuICB9O1xuXG4gIF9wcm90by5nZXRJbml0aWFsRGVsYXkgPSBmdW5jdGlvbiBnZXRJbml0aWFsRGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbERlbGF5XztcbiAgfTtcblxuICBfcHJvdG8uc2V0SW5pdGlhbERlbGF5ID0gZnVuY3Rpb24gc2V0SW5pdGlhbERlbGF5KGluaXRpYWxEZWxheSkge1xuICAgIHRoaXMuaW5pdGlhbERlbGF5XyA9IGluaXRpYWxEZWxheTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlUmV0cnkgPSBmdW5jdGlvbiBjcmVhdGVSZXRyeShfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIG1heEF0dGVtcHRzID0gX3JlZi5tYXhBdHRlbXB0cyxcbiAgICAgICAgZGVsYXlGYWN0b3IgPSBfcmVmLmRlbGF5RmFjdG9yLFxuICAgICAgICBmdXp6RmFjdG9yID0gX3JlZi5mdXp6RmFjdG9yLFxuICAgICAgICBpbml0aWFsRGVsYXkgPSBfcmVmLmluaXRpYWxEZWxheTtcblxuICAgIHJldHVybiBuZXcgUmV0cnkoe1xuICAgICAgbWF4QXR0ZW1wdHM6IG1heEF0dGVtcHRzIHx8IHRoaXMubWF4QXR0ZW1wdHNfLFxuICAgICAgZGVsYXlGYWN0b3I6IGRlbGF5RmFjdG9yIHx8IHRoaXMuZGVsYXlGYWN0b3JfLFxuICAgICAgZnV6ekZhY3RvcjogZnV6ekZhY3RvciB8fCB0aGlzLmZ1enpGYWN0b3JfLFxuICAgICAgaW5pdGlhbERlbGF5OiBpbml0aWFsRGVsYXkgfHwgdGhpcy5pbml0aWFsRGVsYXlfXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFJldHJ5TWFuYWdlcjtcbn0oKTtcblxudmFyIFJldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmV0cnkob3B0aW9ucykge1xuICAgIHRoaXMubWF4QXR0ZW1wdHNfID0gb3B0aW9ucy5tYXhBdHRlbXB0cztcbiAgICB0aGlzLmRlbGF5RmFjdG9yXyA9IG9wdGlvbnMuZGVsYXlGYWN0b3I7XG4gICAgdGhpcy5mdXp6RmFjdG9yXyA9IG9wdGlvbnMuZnV6ekZhY3RvcjtcbiAgICB0aGlzLmN1cnJlbnREZWxheV8gPSBvcHRpb25zLmluaXRpYWxEZWxheTtcbiAgICB0aGlzLmN1cnJlbnRBdHRlbXB0XyA9IDE7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFJldHJ5LnByb3RvdHlwZTtcblxuICBfcHJvdG8yLm1vdmVUb05leHRBdHRlbXB0ID0gZnVuY3Rpb24gbW92ZVRvTmV4dEF0dGVtcHQoKSB7XG4gICAgdGhpcy5jdXJyZW50QXR0ZW1wdF8rKztcbiAgICB2YXIgZGVsYXlEZWx0YSA9IHRoaXMuY3VycmVudERlbGF5XyAqIHRoaXMuZGVsYXlGYWN0b3JfO1xuICAgIHRoaXMuY3VycmVudERlbGF5XyA9IHRoaXMuY3VycmVudERlbGF5XyArIGRlbGF5RGVsdGE7XG4gIH07XG5cbiAgX3Byb3RvMi5zaG91bGRSZXRyeSA9IGZ1bmN0aW9uIHNob3VsZFJldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRBdHRlbXB0XyA8IHRoaXMubWF4QXR0ZW1wdHNfO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q3VycmVudERlbGF5ID0gZnVuY3Rpb24gZ2V0Q3VycmVudERlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREZWxheV87XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRDdXJyZW50TWluUG9zc2libGVEZWxheSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRNaW5Qb3NzaWJsZURlbGF5KCkge1xuICAgIHJldHVybiAoMSAtIHRoaXMuZnV6ekZhY3Rvcl8pICogdGhpcy5jdXJyZW50RGVsYXlfO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q3VycmVudE1heFBvc3NpYmxlRGVsYXkgPSBmdW5jdGlvbiBnZXRDdXJyZW50TWF4UG9zc2libGVEZWxheSgpIHtcbiAgICByZXR1cm4gKDEgKyB0aGlzLmZ1enpGYWN0b3JfKSAqIHRoaXMuY3VycmVudERlbGF5XztcbiAgfVxuICAvKipcbiAgICogRm9yIGV4YW1wbGUgZnV6ekZhY3RvciBpcyAwLjFcbiAgICogVGhpcyBtZWFucyDCsTEwJSBkZXZpYXRpb25cbiAgICogU28gaWYgd2UgaGF2ZSBkZWxheSBhcyAxMDAwXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGdlbmVyYXRlIGFueSB2YWx1ZSBmcm9tIDkwMCB0byAxMTAwXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi5nZXRDdXJyZW50RnV6emVkRGVsYXkgPSBmdW5jdGlvbiBnZXRDdXJyZW50RnV6emVkRGVsYXkoKSB7XG4gICAgdmFyIGxvd1ZhbHVlID0gdGhpcy5nZXRDdXJyZW50TWluUG9zc2libGVEZWxheSgpO1xuICAgIHZhciBoaWdoVmFsdWUgPSB0aGlzLmdldEN1cnJlbnRNYXhQb3NzaWJsZURlbGF5KCk7XG4gICAgcmV0dXJuIGxvd1ZhbHVlICsgTWF0aC5yYW5kb20oKSAqIChoaWdoVmFsdWUgLSBsb3dWYWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFJldHJ5O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5TWFuYWdlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/retry.js\n");

/***/ })

};
;