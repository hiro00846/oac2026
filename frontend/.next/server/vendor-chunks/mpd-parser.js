"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mpd-parser";
exports.ids = ["vendor-chunks/mpd-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mpd-parser/dist/mpd-parser.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/mpd-parser/dist/mpd-parser.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   addSidxSegmentsToPlaylist: () => (/* binding */ addSidxSegmentsToPlaylist$1),\n/* harmony export */   generateSidxKey: () => (/* binding */ generateSidxKey),\n/* harmony export */   inheritAttributes: () => (/* binding */ inheritAttributes),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseUTCTiming: () => (/* binding */ parseUTCTiming),\n/* harmony export */   stringToMpdXml: () => (/* binding */ stringToMpdXml),\n/* harmony export */   toM3u8: () => (/* binding */ toM3u8),\n/* harmony export */   toPlaylists: () => (/* binding */ toPlaylists)\n/* harmony export */ });\n/* harmony import */ var _videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @videojs/vhs-utils/es/resolve-url */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/resolve-url.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _videojs_vhs_utils_es_media_groups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @videojs/vhs-utils/es/media-groups */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/media-groups.js\");\n/* harmony import */ var _videojs_vhs_utils_es_decode_b64_to_uint8_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @videojs/vhs-utils/es/decode-b64-to-uint8-array */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js\");\n/* harmony import */ var _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/./node_modules/@xmldom/xmldom/lib/index.js\");\n/*! @name mpd-parser @version 1.3.1 @license Apache-2.0 */\n\n\n\n\n\n\nvar version = \"1.3.1\";\n\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\n\nconst merge = (...objects) => {\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nconst values = o => Object.keys(o).map(k => o[k]);\n\nconst range = (start, end) => {\n  const result = [];\n\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n\n  const result = [];\n\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  INVALID_NUMBER_OF_CONTENT_STEERING: 'INVALID_NUMBER_OF_CONTENT_STEERING',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = ({\n  baseUrl = '',\n  source = '',\n  range = '',\n  indexRange = ''\n}) => {\n  const segment = {\n    uri: source,\n    resolvedUri: (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = (global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt) ? global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = (global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt) ? global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    let length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(endRange) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(startRange) + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(byterange.offset) + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(byterange.length) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return `${byterange.offset}-${endRange}`;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(size) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, ({\n    timeline\n  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  (0,_videojs_vhs_utils_es_media_groups__WEBPACK_IMPORTED_MODULE_2__.forEachMediaGroup)(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nconst updateMediaSequenceForPlaylist = ({\n  playlist,\n  mediaSequence\n}) => {\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nconst updateSequenceNumbers = ({\n  oldPlaylists,\n  newPlaylists,\n  timelineStarts\n}) => {\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nconst positionManifestOnTimeline = ({\n  oldManifest,\n  newManifest\n}) => {\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n\nconst mergeDiscontiguousPlaylists = playlists => {\n  // Break out playlists into groups based on their baseUrl\n  const playlistsByBaseUrl = playlists.reduce(function (acc, cur) {\n    if (!acc[cur.attributes.baseUrl]) {\n      acc[cur.attributes.baseUrl] = [];\n    }\n\n    acc[cur.attributes.baseUrl].push(cur);\n    return acc;\n  }, {});\n  let allPlaylists = [];\n  Object.values(playlistsByBaseUrl).forEach(playlistGroup => {\n    const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {\n      // assuming playlist IDs are the same across periods\n      // TODO: handle multiperiod where representation sets are not the same\n      // across periods\n      const name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n      if (!acc[name]) {\n        // First Period\n        acc[name] = playlist;\n        acc[name].attributes.timelineStarts = [];\n      } else {\n        // Subsequent Periods\n        if (playlist.segments) {\n          // first segment of subsequent periods signal a discontinuity\n          if (playlist.segments[0]) {\n            playlist.segments[0].discontinuity = true;\n          }\n\n          acc[name].segments.push(...playlist.segments);\n        } // bubble up contentProtection, this assumes all DRM content\n        // has the same contentProtection\n\n\n        if (playlist.attributes.contentProtection) {\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n        }\n      }\n\n      acc[name].attributes.timelineStarts.push({\n        // Although they represent the same number, it's important to have both to make it\n        // compatible with HLS potentially having a similar attribute.\n        start: playlist.attributes.periodStart,\n        timeline: playlist.attributes.periodStart\n      });\n      return acc;\n    }, {}));\n    allPlaylists = allPlaylists.concat(mergedPlaylists);\n  });\n  return allPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nconst addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nconst formatAudioPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  mediaSequence,\n  discontinuitySequence,\n  discontinuityStarts\n}, isAudioOnly) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nconst formatVttPlaylist = ({\n  attributes,\n  segments,\n  mediaSequence,\n  discontinuityStarts,\n  discontinuitySequence\n}) => {\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  const vttPlaylist = {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.serviceLocation) {\n    vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  return vttPlaylist;\n};\nconst organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nconst organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.label || playlist.attributes.lang || 'text';\n    const language = playlist.attributes.lang || 'und';\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\n\nconst formatVideoPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  discontinuityStarts\n}) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nconst videoOnly = ({\n  attributes\n}) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n\nconst audioOnly = ({\n  attributes\n}) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n\nconst vttOnly = ({\n  attributes\n}) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nconst toM3u8 = ({\n  dashPlaylists,\n  locations,\n  contentSteering,\n  sidxMapping = {},\n  previousManifest,\n  eventStream\n}) => {\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (contentSteering) {\n    manifest.contentSteering = contentSteering;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  if (eventStream && eventStream.length > 0) {\n    manifest.eventStream = eventStream;\n  }\n\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(({\n    timelineStarts\n  }) => timelineStarts);\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    let count;\n\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n\n  const value = '' + values[identifier];\n\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n\n  if (value.length >= width) {\n    return value;\n  }\n\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(segment => segment);\n  return segments;\n};\n\nconst generateSegments = ({\n  attributes,\n  segmentInfo\n}) => {\n  let segmentAttributes;\n  let segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  const segmentsInfo = {\n    attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nconst toPlaylists = representations => representations.map(generateSegments);\n\nconst findChildren = (element, name) => from(element.childNodes).filter(({\n  tagName\n}) => tagName === name);\nconst getContent = element => element.textContent.trim();\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\n\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTime.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTime\n   */\n  presentationTime(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime',\n  // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme\n  'urn:mpeg:dash:mp4protection:2011': 'mp4protection'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {Object[]} references\n *        List of objects containing the reference URL as well as its attributes\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {Object[]}\n *         List of objects with resolved urls and attributes\n */\n\nconst buildBaseUrls = (references, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return references;\n  }\n\n  return flatten(references.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      const initialBaseUrl = getContent(baseUrlElement);\n      const resolvedBaseUrl = (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(reference.baseUrl, initialBaseUrl);\n      const finalBaseUrl = merge(parseAttributes(baseUrlElement), {\n        baseUrl: resolvedBaseUrl\n      }); // If the URL is resolved, we want to get the serviceLocation from the reference\n      // assuming there is no serviceLocation on the initialBaseUrl\n\n      if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {\n        finalBaseUrl.serviceLocation = reference.serviceLocation;\n      }\n\n      return finalBaseUrl;\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {Object[]} adaptationSetBaseUrls\n *        List of objects containing resolved base URLs and attributes\n *        inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, baseUrl)\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && (0,_videojs_vhs_utils_es_decode_b64_to_uint8_array__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * A map callback that will parse all event stream data for a collection of periods\n * DASH ISO_IEC_23009 5.10.2.2\n * https://dashif-documents.azurewebsites.net/Events/master/event.html#mpd-event-timing\n *\n * @param {PeriodInformation} period object containing necessary period information\n * @return a collection of parsed eventstream event objects\n */\n\nconst toEventStream = period => {\n  // get and flatten all EventStreams tags and parse attributes and children\n  return flatten(findChildren(period.node, 'EventStream').map(eventStream => {\n    const eventStreamAttributes = parseAttributes(eventStream);\n    const schemeIdUri = eventStreamAttributes.schemeIdUri; // find all Events per EventStream tag and map to return objects\n\n    return findChildren(eventStream, 'Event').map(event => {\n      const eventAttributes = parseAttributes(event);\n      const presentationTime = eventAttributes.presentationTime || 0;\n      const timescale = eventStreamAttributes.timescale || 1;\n      const duration = eventAttributes.duration || 0;\n      const start = presentationTime / timescale + period.attributes.start;\n      return {\n        schemeIdUri,\n        value: eventStreamAttributes.value,\n        id: eventAttributes.id,\n        start,\n        end: start + duration / timescale,\n        messageData: getContent(event) || eventAttributes.messageData,\n        contentEncoding: eventStreamAttributes.contentEncoding,\n        presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0\n      };\n    });\n  }));\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {Object[]} periodBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n\n  const label = findChildren(adaptationSet, 'Label')[0];\n\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n  * @param {Object[]} mpdBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Tranforms an array of content steering nodes into an object\n * containing CDN content steering information from the MPD manifest.\n *\n * For more information on the DASH spec for Content Steering parsing, see:\n * https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n *\n * @param {Node[]} contentSteeringNodes\n *        Content steering nodes\n * @param {Function} eventHandler\n *        The event handler passed into the parser options to handle warnings\n * @return {Object}\n *        Object containing content steering data\n */\n\nconst generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {\n  // If there are more than one ContentSteering tags, throw an error\n  if (contentSteeringNodes.length > 1) {\n    eventHandler({\n      type: 'warn',\n      message: 'The MPD manifest should contain no more than one ContentSteering tag'\n    });\n  } // Return a null value if there are no ContentSteering tags\n\n\n  if (!contentSteeringNodes.length) {\n    return null;\n  }\n\n  const infoFromContentSteeringTag = merge({\n    serverURL: getContent(contentSteeringNodes[0])\n  }, parseAttributes(contentSteeringNodes[0])); // Converts `queryBeforeStart` to a boolean, as well as setting the default value\n  // to `false` if it doesn't exist\n\n  infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === 'true';\n  return infoFromContentSteeringTag;\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nconst getPeriodStart = ({\n  attributes,\n  priorPeriodAttributes,\n  mpdType\n}) => {\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nconst inheritAttributes = (mpd, options = {}) => {\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0,\n    // TODO: For now, we are expecting an eventHandler callback function\n    // to be passed into the mpd parser as an option.\n    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.\n    // This will support new features including a standardized event handler.\n    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.\n    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9\n    eventHandler = function () {}\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([{\n    baseUrl: manifestUri\n  }], findChildren(mpd, 'BaseURL'));\n  const contentSteeringNodes = findChildren(mpd, 'ContentSteering'); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),\n    // TODO: There are occurences where this `representationInfo` array contains undesired\n    // duplicates. This generally occurs when there are multiple BaseURL nodes that are\n    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the\n    // parent BaseURL and a child BaseURL, and the value does not resolve,\n    // we end up returning the child BaseURL multiple times.\n    // We need to determine a way to remove these duplicates in a safe way.\n    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),\n    eventStream: flatten(periods.map(toEventStream))\n  };\n};\n\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  const parser = new _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n  let xml;\n  let mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throws on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  const attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = (manifestString, options = {}) => {\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    contentSteering: parsedManifestInfo.contentSteeringInfo,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest,\n    eventStream: parsedManifestInfo.eventStream\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBkLXBhcnNlci9kaXN0L21wZC1wYXJzZXIuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMkQ7QUFDeEI7QUFDb0M7QUFDYTtBQUN6Qzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFD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QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztB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O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFEQUFTO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxXQUFXO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7O0FBRTZLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc25hcHNob3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbXBkLXBhcnNlci9kaXN0L21wZC1wYXJzZXIuZXMuanM/MzRjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQG5hbWUgbXBkLXBhcnNlciBAdmVyc2lvbiAxLjMuMSBAbGljZW5zZSBBcGFjaGUtMi4wICovXG5pbXBvcnQgcmVzb2x2ZVVybCBmcm9tICdAdmlkZW9qcy92aHMtdXRpbHMvZXMvcmVzb2x2ZS11cmwnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB7IGZvckVhY2hNZWRpYUdyb3VwIH0gZnJvbSAnQHZpZGVvanMvdmhzLXV0aWxzL2VzL21lZGlhLWdyb3Vwcyc7XG5pbXBvcnQgZGVjb2RlQjY0VG9VaW50OEFycmF5IGZyb20gJ0B2aWRlb2pzL3Zocy11dGlscy9lcy9kZWNvZGUtYjY0LXRvLXVpbnQ4LWFycmF5JztcbmltcG9ydCB7IERPTVBhcnNlciB9IGZyb20gJ0B4bWxkb20veG1sZG9tJztcblxudmFyIHZlcnNpb24gPSBcIjEuMy4xXCI7XG5cbmNvbnN0IGlzT2JqZWN0ID0gb2JqID0+IHtcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufTtcblxuY29uc3QgbWVyZ2UgPSAoLi4ub2JqZWN0cykgPT4ge1xuICByZXR1cm4gb2JqZWN0cy5yZWR1Y2UoKHJlc3VsdCwgc291cmNlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pICYmIEFycmF5LmlzQXJyYXkoc291cmNlW2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gcmVzdWx0W2tleV0uY29uY2F0KHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocmVzdWx0W2tleV0pICYmIGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn07XG5jb25zdCB2YWx1ZXMgPSBvID0+IE9iamVjdC5rZXlzKG8pLm1hcChrID0+IG9ba10pO1xuXG5jb25zdCByYW5nZSA9IChzdGFydCwgZW5kKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goaSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGZsYXR0ZW4gPSBsaXN0cyA9PiBsaXN0cy5yZWR1Y2UoKHgsIHkpID0+IHguY29uY2F0KHkpLCBbXSk7XG5jb25zdCBmcm9tID0gbGlzdCA9PiB7XG4gIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChsaXN0W2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZmluZEluZGV4ZXMgPSAobCwga2V5KSA9PiBsLnJlZHVjZSgoYSwgZSwgaSkgPT4ge1xuICBpZiAoZVtrZXldKSB7XG4gICAgYS5wdXNoKGkpO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LCBbXSk7XG4vKipcbiAqIFJldHVybnMgYSB1bmlvbiBvZiB0aGUgaW5jbHVkZWQgbGlzdHMgcHJvdmlkZWQgZWFjaCBlbGVtZW50IGNhbiBiZSBpZGVudGlmaWVkIGJ5IGEga2V5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgLSBsaXN0IG9mIGxpc3RzIHRvIGdldCB0aGUgdW5pb24gb2ZcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleUZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIHVzZSBhcyBhIGtleSBmb3IgZWFjaCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7QXJyYXl9IHRoZSB1bmlvbiBvZiB0aGUgYXJyYXlzXG4gKi9cblxuY29uc3QgdW5pb24gPSAobGlzdHMsIGtleUZ1bmN0aW9uKSA9PiB7XG4gIHJldHVybiB2YWx1ZXMobGlzdHMucmVkdWNlKChhY2MsIGxpc3QpID0+IHtcbiAgICBsaXN0LmZvckVhY2goZWwgPT4ge1xuICAgICAgYWNjW2tleUZ1bmN0aW9uKGVsKV0gPSBlbDtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSkpO1xufTtcblxudmFyIGVycm9ycyA9IHtcbiAgSU5WQUxJRF9OVU1CRVJfT0ZfUEVSSU9EOiAnSU5WQUxJRF9OVU1CRVJfT0ZfUEVSSU9EJyxcbiAgSU5WQUxJRF9OVU1CRVJfT0ZfQ09OVEVOVF9TVEVFUklORzogJ0lOVkFMSURfTlVNQkVSX09GX0NPTlRFTlRfU1RFRVJJTkcnLFxuICBEQVNIX0VNUFRZX01BTklGRVNUOiAnREFTSF9FTVBUWV9NQU5JRkVTVCcsXG4gIERBU0hfSU5WQUxJRF9YTUw6ICdEQVNIX0lOVkFMSURfWE1MJyxcbiAgTk9fQkFTRV9VUkw6ICdOT19CQVNFX1VSTCcsXG4gIE1JU1NJTkdfU0VHTUVOVF9JTkZPUk1BVElPTjogJ01JU1NJTkdfU0VHTUVOVF9JTkZPUk1BVElPTicsXG4gIFNFR01FTlRfVElNRV9VTlNQRUNJRklFRDogJ1NFR01FTlRfVElNRV9VTlNQRUNJRklFRCcsXG4gIFVOU1VQUE9SVEVEX1VUQ19USU1JTkdfU0NIRU1FOiAnVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUUnXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbmdsZVVyaVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVyaSAtIHJlbGF0aXZlIGxvY2F0aW9uIG9mIHNlZ21lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNvbHZlZFVyaSAtIHJlc29sdmVkIGxvY2F0aW9uIG9mIHNlZ21lbnRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBieXRlcmFuZ2UgLSBPYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gbWFrZSBieXRlIHJhbmdlXG4gKiAgIHJlcXVlc3RzIGZvbGxvd2luZyBieXRlLXJhbmdlLXNwZWMgcGVyIFJGQzI2MTYuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gYnl0ZXJhbmdlLmxlbmd0aCAtIGxlbmd0aCBvZiByYW5nZSByZXF1ZXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gYnl0ZXJhbmdlLm9mZnNldCAtIGJ5dGUgb2Zmc2V0IG9mIHJhbmdlIHJlcXVlc3RcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzE0Lmh0bWwjc2VjMTQuMzUuMVxuICovXG5cbi8qKlxuICogQ29udmVydHMgYSBVUkxUeXBlIG5vZGUgKDUuMy45LjIuMyBUYWJsZSAxMykgdG8gYSBzZWdtZW50IG9iamVjdFxuICogdGhhdCBjb25mb3JtcyB0byBob3cgbTN1OC1wYXJzZXIgaXMgc3RydWN0dXJlZFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvbTN1OC1wYXJzZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybCAtIGJhc2VVcmwgcHJvdmlkZWQgYnkgPEJhc2VVcmw+IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gc291cmNlIHVybCBmb3Igc2VnbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHJhbmdlIC0gb3B0aW9uYWwgcmFuZ2UgdXNlZCBmb3IgcmFuZ2UgY2FsbHMsXG4gKiAgIGZvbGxvd3MgIFJGQyAyNjE2LCBDbGF1c2UgMTQuMzUuMVxuICogQHJldHVybiB7U2luZ2xlVXJpfSBmdWxsIHNlZ21lbnQgaW5mb3JtYXRpb24gdHJhbnNmb3JtZWQgaW50byBhIGZvcm1hdCBzaW1pbGFyXG4gKiAgIHRvIG0zdTgtcGFyc2VyXG4gKi9cblxuY29uc3QgdXJsVHlwZVRvU2VnbWVudCA9ICh7XG4gIGJhc2VVcmwgPSAnJyxcbiAgc291cmNlID0gJycsXG4gIHJhbmdlID0gJycsXG4gIGluZGV4UmFuZ2UgPSAnJ1xufSkgPT4ge1xuICBjb25zdCBzZWdtZW50ID0ge1xuICAgIHVyaTogc291cmNlLFxuICAgIHJlc29sdmVkVXJpOiByZXNvbHZlVXJsKGJhc2VVcmwgfHwgJycsIHNvdXJjZSlcbiAgfTtcblxuICBpZiAocmFuZ2UgfHwgaW5kZXhSYW5nZSkge1xuICAgIGNvbnN0IHJhbmdlU3RyID0gcmFuZ2UgPyByYW5nZSA6IGluZGV4UmFuZ2U7XG4gICAgY29uc3QgcmFuZ2VzID0gcmFuZ2VTdHIuc3BsaXQoJy0nKTsgLy8gZGVmYXVsdCB0byBwYXJzaW5nIHRoaXMgYXMgYSBCaWdJbnQgaWYgcG9zc2libGVcblxuICAgIGxldCBzdGFydFJhbmdlID0gd2luZG93LkJpZ0ludCA/IHdpbmRvdy5CaWdJbnQocmFuZ2VzWzBdKSA6IHBhcnNlSW50KHJhbmdlc1swXSwgMTApO1xuICAgIGxldCBlbmRSYW5nZSA9IHdpbmRvdy5CaWdJbnQgPyB3aW5kb3cuQmlnSW50KHJhbmdlc1sxXSkgOiBwYXJzZUludChyYW5nZXNbMV0sIDEwKTsgLy8gY29udmVydCBiYWNrIHRvIGEgbnVtYmVyIGlmIGxlc3MgdGhhbiBNQVhfU0FGRV9JTlRFR0VSXG5cbiAgICBpZiAoc3RhcnRSYW5nZSA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHR5cGVvZiBzdGFydFJhbmdlID09PSAnYmlnaW50Jykge1xuICAgICAgc3RhcnRSYW5nZSA9IE51bWJlcihzdGFydFJhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kUmFuZ2UgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB0eXBlb2YgZW5kUmFuZ2UgPT09ICdiaWdpbnQnKSB7XG4gICAgICBlbmRSYW5nZSA9IE51bWJlcihlbmRSYW5nZSk7XG4gICAgfVxuXG4gICAgbGV0IGxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZW5kUmFuZ2UgPT09ICdiaWdpbnQnIHx8IHR5cGVvZiBzdGFydFJhbmdlID09PSAnYmlnaW50Jykge1xuICAgICAgbGVuZ3RoID0gd2luZG93LkJpZ0ludChlbmRSYW5nZSkgLSB3aW5kb3cuQmlnSW50KHN0YXJ0UmFuZ2UpICsgd2luZG93LkJpZ0ludCgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gZW5kUmFuZ2UgLSBzdGFydFJhbmdlICsgMTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2JpZ2ludCcgJiYgbGVuZ3RoIDwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIH0gLy8gYnl0ZXJhbmdlIHNob3VsZCBiZSBpbmNsdXNpdmUgYWNjb3JkaW5nIHRvXG4gICAgLy8gUkZDIDI2MTYsIENsYXVzZSAxNC4zNS4xXG5cblxuICAgIHNlZ21lbnQuYnl0ZXJhbmdlID0ge1xuICAgICAgbGVuZ3RoLFxuICAgICAgb2Zmc2V0OiBzdGFydFJhbmdlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufTtcbmNvbnN0IGJ5dGVSYW5nZVRvU3RyaW5nID0gYnl0ZXJhbmdlID0+IHtcbiAgLy8gYGVuZFJhbmdlYCBpcyBvbmUgbGVzcyB0aGFuIGBvZmZzZXQgKyBsZW5ndGhgIGJlY2F1c2UgdGhlIEhUVFAgcmFuZ2VcbiAgLy8gaGVhZGVyIHVzZXMgaW5jbHVzaXZlIHJhbmdlc1xuICBsZXQgZW5kUmFuZ2U7XG5cbiAgaWYgKHR5cGVvZiBieXRlcmFuZ2Uub2Zmc2V0ID09PSAnYmlnaW50JyB8fCB0eXBlb2YgYnl0ZXJhbmdlLmxlbmd0aCA9PT0gJ2JpZ2ludCcpIHtcbiAgICBlbmRSYW5nZSA9IHdpbmRvdy5CaWdJbnQoYnl0ZXJhbmdlLm9mZnNldCkgKyB3aW5kb3cuQmlnSW50KGJ5dGVyYW5nZS5sZW5ndGgpIC0gd2luZG93LkJpZ0ludCgxKTtcbiAgfSBlbHNlIHtcbiAgICBlbmRSYW5nZSA9IGJ5dGVyYW5nZS5vZmZzZXQgKyBieXRlcmFuZ2UubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIHJldHVybiBgJHtieXRlcmFuZ2Uub2Zmc2V0fS0ke2VuZFJhbmdlfWA7XG59O1xuXG4vKipcbiAqIHBhcnNlIHRoZSBlbmQgbnVtYmVyIGF0dHJpYnVlIHRoYXQgY2FuIGJlIGEgc3RyaW5nXG4gKiBudW1iZXIsIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8dW5kZWZpbmVkfSBlbmROdW1iZXJcbiAqICAgICAgICBUaGUgZW5kIG51bWJlciBhdHRyaWJ1dGUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKiAgICAgICAgICBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIGVuZCBudW1iZXIuXG4gKi9cblxuY29uc3QgcGFyc2VFbmROdW1iZXIgPSBlbmROdW1iZXIgPT4ge1xuICBpZiAoZW5kTnVtYmVyICYmIHR5cGVvZiBlbmROdW1iZXIgIT09ICdudW1iZXInKSB7XG4gICAgZW5kTnVtYmVyID0gcGFyc2VJbnQoZW5kTnVtYmVyLCAxMCk7XG4gIH1cblxuICBpZiAoaXNOYU4oZW5kTnVtYmVyKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVuZE51bWJlcjtcbn07XG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgY2FsY3VsYXRpbmcgdGhlIHJhbmdlIG9mIGF2YWlsYWJsZSBzZWdtZW50cyBpbiBzdGF0aWMgYW5kIGR5bmFtaWNcbiAqIG1hbmlmZXN0cy5cbiAqL1xuXG5cbmNvbnN0IHNlZ21lbnRSYW5nZSA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVudGlyZSByYW5nZSBvZiBhdmFpbGFibGUgc2VnbWVudHMgZm9yIGEgc3RhdGljIE1QRFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICAgKiAgICAgICAgSW5oZXJpdGllZCBNUEQgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJuIHt7IHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyIH19XG4gICAqICAgICAgICAgVGhlIHN0YXJ0IGFuZCBlbmQgbnVtYmVycyBmb3IgYXZhaWxhYmxlIHNlZ21lbnRzXG4gICAqL1xuICBzdGF0aWMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltZXNjYWxlID0gMSxcbiAgICAgIHNvdXJjZUR1cmF0aW9uLFxuICAgICAgcGVyaW9kRHVyYXRpb25cbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICBjb25zdCBlbmROdW1iZXIgPSBwYXJzZUVuZE51bWJlcihhdHRyaWJ1dGVzLmVuZE51bWJlcik7XG4gICAgY29uc3Qgc2VnbWVudER1cmF0aW9uID0gZHVyYXRpb24gLyB0aW1lc2NhbGU7XG5cbiAgICBpZiAodHlwZW9mIGVuZE51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IGVuZE51bWJlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBlcmlvZER1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcGVyaW9kRHVyYXRpb24gLyBzZWdtZW50RHVyYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiBzb3VyY2VEdXJhdGlvbiAvIHNlZ21lbnREdXJhdGlvblxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGl2ZSB3aW5kb3cgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNlZ21lbnRzIGZvciBhIGR5bmFtaWMgTVBEXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqICAgICAgICBJbmhlcml0aWVkIE1QRCBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3sgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIgfX1cbiAgICogICAgICAgICBUaGUgc3RhcnQgYW5kIGVuZCBudW1iZXJzIGZvciBhdmFpbGFibGUgc2VnbWVudHNcbiAgICovXG4gIGR5bmFtaWMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIE5PVyxcbiAgICAgIGNsaWVudE9mZnNldCxcbiAgICAgIGF2YWlsYWJpbGl0eVN0YXJ0VGltZSxcbiAgICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHBlcmlvZFN0YXJ0ID0gMCxcbiAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSAwLFxuICAgICAgdGltZVNoaWZ0QnVmZmVyRGVwdGggPSBJbmZpbml0eVxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGVuZE51bWJlciA9IHBhcnNlRW5kTnVtYmVyKGF0dHJpYnV0ZXMuZW5kTnVtYmVyKTsgLy8gY2xpZW50T2Zmc2V0IGlzIHBhc3NlZCBpbiBhdCB0aGUgdG9wIGxldmVsIG9mIG1wZC1wYXJzZXIgYW5kIGlzIGFuIG9mZnNldCBjYWxjdWxhdGVkXG4gICAgLy8gYWZ0ZXIgcmV0cmlldmluZyBVVEMgc2VydmVyIHRpbWUuXG5cbiAgICBjb25zdCBub3cgPSAoTk9XICsgY2xpZW50T2Zmc2V0KSAvIDEwMDA7IC8vIFdDIHN0YW5kcyBmb3IgV2FsbCBDbG9jay5cbiAgICAvLyBDb252ZXJ0IHRoZSBwZXJpb2Qgc3RhcnQgdGltZSB0byBFUE9DSC5cblxuICAgIGNvbnN0IHBlcmlvZFN0YXJ0V0MgPSBhdmFpbGFiaWxpdHlTdGFydFRpbWUgKyBwZXJpb2RTdGFydDsgLy8gUGVyaW9kIGVuZCBpbiBFUE9DSCBpcyBtYW5pZmVzdCdzIHJldHJpZXZhbCB0aW1lICsgdGltZSB1bnRpbCBuZXh0IHVwZGF0ZS5cblxuICAgIGNvbnN0IHBlcmlvZEVuZFdDID0gbm93ICsgbWluaW11bVVwZGF0ZVBlcmlvZDtcbiAgICBjb25zdCBwZXJpb2REdXJhdGlvbiA9IHBlcmlvZEVuZFdDIC0gcGVyaW9kU3RhcnRXQztcbiAgICBjb25zdCBzZWdtZW50Q291bnQgPSBNYXRoLmNlaWwocGVyaW9kRHVyYXRpb24gKiB0aW1lc2NhbGUgLyBkdXJhdGlvbik7XG4gICAgY29uc3QgYXZhaWxhYmxlU3RhcnQgPSBNYXRoLmZsb29yKChub3cgLSBwZXJpb2RTdGFydFdDIC0gdGltZVNoaWZ0QnVmZmVyRGVwdGgpICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIGNvbnN0IGF2YWlsYWJsZUVuZCA9IE1hdGguZmxvb3IoKG5vdyAtIHBlcmlvZFN0YXJ0V0MpICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogTWF0aC5tYXgoMCwgYXZhaWxhYmxlU3RhcnQpLFxuICAgICAgZW5kOiB0eXBlb2YgZW5kTnVtYmVyID09PSAnbnVtYmVyJyA/IGVuZE51bWJlciA6IE1hdGgubWluKHNlZ21lbnRDb3VudCwgYXZhaWxhYmxlRW5kKVxuICAgIH07XG4gIH1cblxufTtcbi8qKlxuICogTWFwcyBhIHJhbmdlIG9mIG51bWJlcnMgdG8gb2JqZWN0cyB3aXRoIGluZm9ybWF0aW9uIG5lZWRlZCB0byBidWlsZCB0aGUgY29ycmVzcG9uZGluZ1xuICogc2VnbWVudCBsaXN0XG4gKlxuICogQG5hbWUgdG9TZWdtZW50c0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogICAgICAgIEluZGV4IG9mIHRoZSBudW1iZXIgaW4gdGhlIHJhbmdlIGxpc3RcbiAqIEByZXR1cm4ge3sgbnVtYmVyOiBOdW1iZXIsIGR1cmF0aW9uOiBOdW1iZXIsIHRpbWVsaW5lOiBOdW1iZXIsIHRpbWU6IE51bWJlciB9fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIGEgcmFuZ2Ugb2YgbnVtYmVycyB0b1xuICogaW5mb3JtYXRpb24gbmVlZGVkIHRvIGJ1aWxkIHRoZSBzZWdtZW50IGxpc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBJbmhlcml0ZWQgTVBEIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge3RvU2VnbWVudHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cblxuY29uc3QgdG9TZWdtZW50cyA9IGF0dHJpYnV0ZXMgPT4gbnVtYmVyID0+IHtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uLFxuICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgcGVyaW9kU3RhcnQsXG4gICAgc3RhcnROdW1iZXIgPSAxXG4gIH0gPSBhdHRyaWJ1dGVzO1xuICByZXR1cm4ge1xuICAgIG51bWJlcjogc3RhcnROdW1iZXIgKyBudW1iZXIsXG4gICAgZHVyYXRpb246IGR1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgIHRpbWVsaW5lOiBwZXJpb2RTdGFydCxcbiAgICB0aW1lOiBudW1iZXIgKiBkdXJhdGlvblxuICB9O1xufTtcbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvIHVzZWQgZm9yXG4gKiBidWlsZGluZyB0aGUgbGlzdCBvZiBzZWdtZW50cy4gVGhpcyB1c2VzIHRoZSBAZHVyYXRpb24gYXR0cmlidXRlIHNwZWNpZmllZFxuICogaW4gdGhlIE1QRCBtYW5pZmVzdCB0byBkZXJpdmUgdGhlIHJhbmdlIG9mIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgSW5oZXJpdGVkIE1QRCBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHt7bnVtYmVyOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIHRpbWU6IG51bWJlciwgdGltZWxpbmU6IG51bWJlcn1bXX1cbiAqICAgICAgICAgTGlzdCBvZiBPYmplY3RzIHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG5jb25zdCBwYXJzZUJ5RHVyYXRpb24gPSBhdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZHVyYXRpb24sXG4gICAgdGltZXNjYWxlID0gMSxcbiAgICBwZXJpb2REdXJhdGlvbixcbiAgICBzb3VyY2VEdXJhdGlvblxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3Qge1xuICAgIHN0YXJ0LFxuICAgIGVuZFxuICB9ID0gc2VnbWVudFJhbmdlW3R5cGVdKGF0dHJpYnV0ZXMpO1xuICBjb25zdCBzZWdtZW50cyA9IHJhbmdlKHN0YXJ0LCBlbmQpLm1hcCh0b1NlZ21lbnRzKGF0dHJpYnV0ZXMpKTtcblxuICBpZiAodHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICBjb25zdCBpbmRleCA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7IC8vIHNlY3Rpb24gaXMgZWl0aGVyIGEgcGVyaW9kIG9yIHRoZSBmdWxsIHNvdXJjZVxuXG4gICAgY29uc3Qgc2VjdGlvbkR1cmF0aW9uID0gdHlwZW9mIHBlcmlvZER1cmF0aW9uID09PSAnbnVtYmVyJyA/IHBlcmlvZER1cmF0aW9uIDogc291cmNlRHVyYXRpb247IC8vIGZpbmFsIHNlZ21lbnQgbWF5IGJlIGxlc3MgdGhhbiBmdWxsIHNlZ21lbnQgZHVyYXRpb25cblxuICAgIHNlZ21lbnRzW2luZGV4XS5kdXJhdGlvbiA9IHNlY3Rpb25EdXJhdGlvbiAtIGR1cmF0aW9uIC8gdGltZXNjYWxlICogaW5kZXg7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgU2VnbWVudEJhc2UgaW50byBhIHNldCBvZiBzZWdtZW50cy5cbiAqIChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG5cbmNvbnN0IHNlZ21lbnRzRnJvbUJhc2UgPSBhdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwsXG4gICAgaW5pdGlhbGl6YXRpb24gPSB7fSxcbiAgICBzb3VyY2VEdXJhdGlvbixcbiAgICBpbmRleFJhbmdlID0gJycsXG4gICAgcGVyaW9kU3RhcnQsXG4gICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICBudW1iZXIgPSAwLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBhdHRyaWJ1dGVzOyAvLyBiYXNlIHVybCBpcyByZXF1aXJlZCBmb3IgU2VnbWVudEJhc2UgdG8gd29yaywgcGVyIHNwZWMgKFNlY3Rpb24gNS4zLjkuMi4xKVxuXG4gIGlmICghYmFzZVVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuTk9fQkFTRV9VUkwpO1xuICB9XG5cbiAgY29uc3QgaW5pdFNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsLFxuICAgIHNvdXJjZTogaW5pdGlhbGl6YXRpb24uc291cmNlVVJMLFxuICAgIHJhbmdlOiBpbml0aWFsaXphdGlvbi5yYW5nZVxuICB9KTtcbiAgY29uc3Qgc2VnbWVudCA9IHVybFR5cGVUb1NlZ21lbnQoe1xuICAgIGJhc2VVcmwsXG4gICAgc291cmNlOiBiYXNlVXJsLFxuICAgIGluZGV4UmFuZ2VcbiAgfSk7XG4gIHNlZ21lbnQubWFwID0gaW5pdFNlZ21lbnQ7IC8vIElmIHRoZXJlIGlzIGEgZHVyYXRpb24sIHVzZSBpdCwgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW4gZHVyYXRpb24gb2YgdGhlIHNvdXJjZVxuICAvLyAoc2luY2UgU2VnbWVudEJhc2UgaXMgb25seSBmb3Igb25lIHRvdGFsIHNlZ21lbnQpXG5cbiAgaWYgKGR1cmF0aW9uKSB7XG4gICAgY29uc3Qgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHNlZ21lbnRUaW1lSW5mby5sZW5ndGgpIHtcbiAgICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzZWdtZW50VGltZUluZm9bMF0uZHVyYXRpb247XG4gICAgICBzZWdtZW50LnRpbWVsaW5lID0gc2VnbWVudFRpbWVJbmZvWzBdLnRpbWVsaW5lO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VEdXJhdGlvbikge1xuICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzb3VyY2VEdXJhdGlvbjtcbiAgICBzZWdtZW50LnRpbWVsaW5lID0gcGVyaW9kU3RhcnQ7XG4gIH0gLy8gSWYgcHJlc2VudGF0aW9uIHRpbWUgaXMgcHJvdmlkZWQsIHRoZXNlIHNlZ21lbnRzIGFyZSBiZWluZyBnZW5lcmF0ZWQgYnkgU0lEWFxuICAvLyByZWZlcmVuY2VzLCBhbmQgc2hvdWxkIHVzZSB0aGUgdGltZSBwcm92aWRlZC4gRm9yIHRoZSBnZW5lcmFsIGNhc2Ugb2YgU2VnbWVudEJhc2UsXG4gIC8vIHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBzZWdtZW50IGluIHRoZSBwZXJpb2QsIHNvIGl0cyBwcmVzZW50YXRpb24gdGltZSBpcyB0aGUgc2FtZVxuICAvLyBhcyBpdHMgcGVyaW9kIHN0YXJ0LlxuXG5cbiAgc2VnbWVudC5wcmVzZW50YXRpb25UaW1lID0gcHJlc2VudGF0aW9uVGltZSB8fCBwZXJpb2RTdGFydDtcbiAgc2VnbWVudC5udW1iZXIgPSBudW1iZXI7XG4gIHJldHVybiBbc2VnbWVudF07XG59O1xuLyoqXG4gKiBHaXZlbiBhIHBsYXlsaXN0LCBhIHNpZHggYm94LCBhbmQgYSBiYXNlVXJsLCB1cGRhdGUgdGhlIHNlZ21lbnQgbGlzdCBvZiB0aGUgcGxheWxpc3RcbiAqIGFjY29yZGluZyB0byB0aGUgc2lkeCBpbmZvcm1hdGlvbiBnaXZlbi5cbiAqXG4gKiBwbGF5bGlzdC5zaWR4IGhhcyBtZXRhZGFkYXRhIGFib3V0IHRoZSBzaWR4IHdoZXJlLWFzIHRoZSBzaWR4IHBhcmFtXG4gKiBpcyB0aGUgcGFyc2VkIHNpZHggYm94IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIHBsYXlsaXN0IHRvIHVwZGF0ZSB0aGUgc2lkeCBpbmZvcm1hdGlvbiBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWR4IHRoZSBwYXJzZWQgc2lkeCBib3hcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBsYXlsaXN0IG9iamVjdCB3aXRoIHRoZSB1cGRhdGVkIHNpZHggaW5mb3JtYXRpb25cbiAqL1xuXG5jb25zdCBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0JDEgPSAocGxheWxpc3QsIHNpZHgsIGJhc2VVcmwpID0+IHtcbiAgLy8gUmV0YWluIGluaXQgc2VnbWVudCBpbmZvcm1hdGlvblxuICBjb25zdCBpbml0U2VnbWVudCA9IHBsYXlsaXN0LnNpZHgubWFwID8gcGxheWxpc3Quc2lkeC5tYXAgOiBudWxsOyAvLyBSZXRhaW4gc291cmNlIGR1cmF0aW9uIGZyb20gaW5pdGlhbCBtYWluIG1hbmlmZXN0IHBhcnNpbmdcblxuICBjb25zdCBzb3VyY2VEdXJhdGlvbiA9IHBsYXlsaXN0LnNpZHguZHVyYXRpb247IC8vIFJldGFpbiBzb3VyY2UgdGltZWxpbmVcblxuICBjb25zdCB0aW1lbGluZSA9IHBsYXlsaXN0LnRpbWVsaW5lIHx8IDA7XG4gIGNvbnN0IHNpZHhCeXRlUmFuZ2UgPSBwbGF5bGlzdC5zaWR4LmJ5dGVyYW5nZTtcbiAgY29uc3Qgc2lkeEVuZCA9IHNpZHhCeXRlUmFuZ2Uub2Zmc2V0ICsgc2lkeEJ5dGVSYW5nZS5sZW5ndGg7IC8vIFJldGFpbiB0aW1lc2NhbGUgb2YgdGhlIHBhcnNlZCBzaWR4XG5cbiAgY29uc3QgdGltZXNjYWxlID0gc2lkeC50aW1lc2NhbGU7IC8vIHJlZmVyZW5jZVR5cGUgMSByZWZlcnMgdG8gb3RoZXIgc2lkeCBib3hlc1xuXG4gIGNvbnN0IG1lZGlhUmVmZXJlbmNlcyA9IHNpZHgucmVmZXJlbmNlcy5maWx0ZXIociA9PiByLnJlZmVyZW5jZVR5cGUgIT09IDEpO1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBjb25zdCB0eXBlID0gcGxheWxpc3QuZW5kTGlzdCA/ICdzdGF0aWMnIDogJ2R5bmFtaWMnO1xuICBjb25zdCBwZXJpb2RTdGFydCA9IHBsYXlsaXN0LnNpZHgudGltZWxpbmU7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lID0gcGVyaW9kU3RhcnQ7XG4gIGxldCBudW1iZXIgPSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlIHx8IDA7IC8vIGZpcnN0T2Zmc2V0IGlzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzaWR4IGJveFxuXG4gIGxldCBzdGFydEluZGV4OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICBpZiAodHlwZW9mIHNpZHguZmlyc3RPZmZzZXQgPT09ICdiaWdpbnQnKSB7XG4gICAgc3RhcnRJbmRleCA9IHdpbmRvdy5CaWdJbnQoc2lkeEVuZCkgKyBzaWR4LmZpcnN0T2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0SW5kZXggPSBzaWR4RW5kICsgc2lkeC5maXJzdE9mZnNldDtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWFSZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlID0gc2lkeC5yZWZlcmVuY2VzW2ldOyAvLyBzaXplIG9mIHRoZSByZWZlcmVuY2VkIChzdWIpc2VnbWVudFxuXG4gICAgY29uc3Qgc2l6ZSA9IHJlZmVyZW5jZS5yZWZlcmVuY2VkU2l6ZTsgLy8gZHVyYXRpb24gb2YgdGhlIHJlZmVyZW5jZWQgKHN1YilzZWdtZW50LCBpbiAgdGhlICB0aW1lc2NhbGVcbiAgICAvLyB0aGlzIHdpbGwgYmUgY29udmVydGVkIHRvIHNlY29uZHMgd2hlbiBnZW5lcmF0aW5nIHNlZ21lbnRzXG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IHJlZmVyZW5jZS5zdWJzZWdtZW50RHVyYXRpb247IC8vIHNob3VsZCBiZSBhbiBpbmNsdXNpdmUgcmFuZ2VcblxuICAgIGxldCBlbmRJbmRleDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICdiaWdpbnQnKSB7XG4gICAgICBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyB3aW5kb3cuQmlnSW50KHNpemUpIC0gd2luZG93LkJpZ0ludCgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgc2l6ZSAtIDE7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhSYW5nZSA9IGAke3N0YXJ0SW5kZXh9LSR7ZW5kSW5kZXh9YDtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgYmFzZVVybCxcbiAgICAgIHRpbWVzY2FsZSxcbiAgICAgIHRpbWVsaW5lLFxuICAgICAgcGVyaW9kU3RhcnQsXG4gICAgICBwcmVzZW50YXRpb25UaW1lLFxuICAgICAgbnVtYmVyLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBzb3VyY2VEdXJhdGlvbixcbiAgICAgIGluZGV4UmFuZ2UsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNGcm9tQmFzZShhdHRyaWJ1dGVzKVswXTtcblxuICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgc2VnbWVudC5tYXAgPSBpbml0U2VnbWVudDtcbiAgICB9XG5cbiAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAnYmlnaW50Jykge1xuICAgICAgc3RhcnRJbmRleCArPSB3aW5kb3cuQmlnSW50KHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydEluZGV4ICs9IHNpemU7XG4gICAgfVxuXG4gICAgcHJlc2VudGF0aW9uVGltZSArPSBkdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICBudW1iZXIrKztcbiAgfVxuXG4gIHBsYXlsaXN0LnNlZ21lbnRzID0gc2VnbWVudHM7XG4gIHJldHVybiBwbGF5bGlzdDtcbn07XG5cbmNvbnN0IFNVUFBPUlRFRF9NRURJQV9UWVBFUyA9IFsnQVVESU8nLCAnU1VCVElUTEVTJ107IC8vIGFsbG93IG9uZSA2MGZwcyBmcmFtZSBhcyBsZW5pZW5jeSAoYXJiaXRyYXJpbHkgY2hvc2VuKVxuXG5jb25zdCBUSU1FX0ZVREdFID0gMSAvIDYwO1xuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgdGltZWxpbmVTdGFydHMsIGNvbWJpbmVzLCBkZWR1cGVzLCBhbmQgc29ydHMgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge1RpbWVsaW5lU3RhcnRbXX0gdGltZWxpbmVTdGFydHMgLSBsaXN0IG9mIHRpbWVsaW5lIHN0YXJ0c1xuICpcbiAqIEByZXR1cm4ge1RpbWVsaW5lU3RhcnRbXX0gdGhlIGNvbWJpbmVkIGFuZCBkZWR1cGVkIHRpbWVsaW5lIHN0YXJ0c1xuICovXG5cbmNvbnN0IGdldFVuaXF1ZVRpbWVsaW5lU3RhcnRzID0gdGltZWxpbmVTdGFydHMgPT4ge1xuICByZXR1cm4gdW5pb24odGltZWxpbmVTdGFydHMsICh7XG4gICAgdGltZWxpbmVcbiAgfSkgPT4gdGltZWxpbmUpLnNvcnQoKGEsIGIpID0+IGEudGltZWxpbmUgPiBiLnRpbWVsaW5lID8gMSA6IC0xKTtcbn07XG4vKipcbiAqIEZpbmRzIHRoZSBwbGF5bGlzdCB3aXRoIHRoZSBtYXRjaGluZyBOQU1FIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwbGF5bGlzdHMgLSBwbGF5bGlzdHMgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIE5BTUUgYXR0cmlidXRlIHRvIHNlYXJjaCBmb3JcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIG1hdGNoaW5nIHBsYXlsaXN0IG9iamVjdCwgb3IgbnVsbFxuICovXG5cbmNvbnN0IGZpbmRQbGF5bGlzdFdpdGhOYW1lID0gKHBsYXlsaXN0cywgbmFtZSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYXlsaXN0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwbGF5bGlzdHNbaV0uYXR0cmlidXRlcy5OQU1FID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gcGxheWxpc3RzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogR2V0cyBhIGZsYXR0ZW5lZCBhcnJheSBvZiBtZWRpYSBncm91cCBwbGF5bGlzdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hbmlmZXN0IC0gdGhlIG1haW4gbWFuaWZlc3Qgb2JqZWN0XG4gKlxuICogQHJldHVybiB7QXJyYXl9IHRoZSBtZWRpYSBncm91cCBwbGF5bGlzdHNcbiAqL1xuXG5jb25zdCBnZXRNZWRpYUdyb3VwUGxheWxpc3RzID0gbWFuaWZlc3QgPT4ge1xuICBsZXQgbWVkaWFHcm91cFBsYXlsaXN0cyA9IFtdO1xuICBmb3JFYWNoTWVkaWFHcm91cChtYW5pZmVzdCwgU1VQUE9SVEVEX01FRElBX1RZUEVTLCAocHJvcGVydGllcywgdHlwZSwgZ3JvdXAsIGxhYmVsKSA9PiB7XG4gICAgbWVkaWFHcm91cFBsYXlsaXN0cyA9IG1lZGlhR3JvdXBQbGF5bGlzdHMuY29uY2F0KHByb3BlcnRpZXMucGxheWxpc3RzIHx8IFtdKTtcbiAgfSk7XG4gIHJldHVybiBtZWRpYUdyb3VwUGxheWxpc3RzO1xufTtcbi8qKlxuICogVXBkYXRlcyB0aGUgcGxheWxpc3QncyBtZWRpYSBzZXF1ZW5jZSBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5wbGF5bGlzdCAtIHRoZSBwbGF5bGlzdCB0byB1cGRhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcubWVkaWFTZXF1ZW5jZSAtIHRoZSBtZWRpYVNlcXVlbmNlIG51bWJlciB0byBzdGFydCB3aXRoXG4gKi9cblxuY29uc3QgdXBkYXRlTWVkaWFTZXF1ZW5jZUZvclBsYXlsaXN0ID0gKHtcbiAgcGxheWxpc3QsXG4gIG1lZGlhU2VxdWVuY2Vcbn0pID0+IHtcbiAgcGxheWxpc3QubWVkaWFTZXF1ZW5jZSA9IG1lZGlhU2VxdWVuY2U7XG4gIHBsYXlsaXN0LnNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgc2VnbWVudC5udW1iZXIgPSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlICsgaW5kZXg7XG4gIH0pO1xufTtcbi8qKlxuICogVXBkYXRlcyB0aGUgbWVkaWEgYW5kIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbnVtYmVycyBvZiBuZXdQbGF5bGlzdHMgZ2l2ZW4gb2xkUGxheWxpc3RzXG4gKiBhbmQgYSBjb21wbGV0ZSBsaXN0IG9mIHRpbWVsaW5lIHN0YXJ0cy5cbiAqXG4gKiBJZiBubyBtYXRjaGluZyBwbGF5bGlzdCBpcyBmb3VuZCwgb25seSB0aGUgZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIHBsYXlsaXN0XG4gKiB3aWxsIGJlIHVwZGF0ZWQuXG4gKlxuICogU2luY2UgZWFybHkgYXZhaWxhYmxlIHRpbWVsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCwgYXQgbGVhc3Qgb25lIHNlZ21lbnQgbXVzdCBiZSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3RbXX0gb2xkUGxheWxpc3RzIC0gdGhlIG9sZCBwbGF5bGlzdHMgdG8gdXNlIGFzIGEgcmVmZXJlbmNlXG4gKiBAcGFyYW0ge09iamVjdFtdfSBuZXdQbGF5bGlzdHMgLSB0aGUgbmV3IHBsYXlsaXN0cyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aW1lbGluZVN0YXJ0cyAtIGFsbCB0aW1lbGluZVN0YXJ0cyBzZWVuIGluIHRoZSBzdHJlYW0gdG8gdGhpcyBwb2ludFxuICovXG5cbmNvbnN0IHVwZGF0ZVNlcXVlbmNlTnVtYmVycyA9ICh7XG4gIG9sZFBsYXlsaXN0cyxcbiAgbmV3UGxheWxpc3RzLFxuICB0aW1lbGluZVN0YXJ0c1xufSkgPT4ge1xuICBuZXdQbGF5bGlzdHMuZm9yRWFjaChwbGF5bGlzdCA9PiB7XG4gICAgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlID0gdGltZWxpbmVTdGFydHMuZmluZEluZGV4KGZ1bmN0aW9uICh7XG4gICAgICB0aW1lbGluZVxuICAgIH0pIHtcbiAgICAgIHJldHVybiB0aW1lbGluZSA9PT0gcGxheWxpc3QudGltZWxpbmU7XG4gICAgfSk7IC8vIFBsYXlsaXN0cyBOQU1FcyBjb21lIGZyb20gREFTSCBSZXByZXNlbnRhdGlvbiBJRHMsIHdoaWNoIGFyZSBtYW5kYXRvcnlcbiAgICAvLyAoc2VlIElTT18yMzAwOS0xLTIwMTIgNS4zLjUuMikuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgc2FtZSBSZXByZXNlbnRhdGlvbiBleGlzdGVkIGluIGEgcHJpb3IgUGVyaW9kLCBpdCB3aWxsIHJldGFpbiB0aGUgc2FtZSBOQU1FLlxuXG4gICAgY29uc3Qgb2xkUGxheWxpc3QgPSBmaW5kUGxheWxpc3RXaXRoTmFtZShvbGRQbGF5bGlzdHMsIHBsYXlsaXN0LmF0dHJpYnV0ZXMuTkFNRSk7XG5cbiAgICBpZiAoIW9sZFBsYXlsaXN0KSB7XG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgbmV3IHBsYXlsaXN0LCB0aGUgbWVkaWEgc2VxdWVuY2UgdmFsdWVzIGNhbiBzdGFydCBmcm9tIDAgd2l0aG91dFxuICAgICAgLy8gY29uc2VxdWVuY2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUT0RPIGJldHRlciBzdXBwb3J0IGZvciBsaXZlIFNJRFhcbiAgICAvL1xuICAgIC8vIEFzIG9mIHRoaXMgd3JpdGluZywgbXBkLXBhcnNlciBkb2VzIG5vdCBzdXBwb3J0IG11bHRpcGVyaW9kIFNJRFggKGluIGxpdmUgb3IgVk9EKS5cbiAgICAvLyBUaGlzIGlzIGV2aWRlbnQgYnkgYSBwbGF5bGlzdCBvbmx5IGhhdmluZyBhIHNpbmdsZSBTSURYIHJlZmVyZW5jZS4gSW4gYSBtdWx0aXBlcmlvZFxuICAgIC8vIHBsYXlsaXN0IHRoZXJlIHdvdWxkIG5lZWQgdG8gYmUgbXVsdGlwbGUgU0lEWCByZWZlcmVuY2VzLiBJbiBhZGRpdGlvbiwgbGl2ZSBTSURYIGlzXG4gICAgLy8gbm90IHN1cHBvcnRlZCB3aGVuIHRoZSBTSURYIHByb3BlcnRpZXMgY2hhbmdlIG9uIHJlZnJlc2hlcy5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBmdXR1cmUsIGlmIHN1cHBvcnQgbmVlZHMgdG8gYmUgYWRkZWQsIHRoZSBtZXJnaW5nIGxvZ2ljIGhlcmUgY2FuIGJlIGNhbGxlZFxuICAgIC8vIGFmdGVyIFNJRFggcmVmZXJlbmNlcyBhcmUgcmVzb2x2ZWQuIEZvciBub3csIGV4aXQgZWFybHkgdG8gcHJldmVudCBleGNlcHRpb25zIGJlaW5nXG4gICAgLy8gdGhyb3duIGR1ZSB0byB1bmRlZmluZWQgcmVmZXJlbmNlcy5cblxuXG4gICAgaWYgKHBsYXlsaXN0LnNpZHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNpbmNlIHdlIGRvbid0IHlldCBzdXBwb3J0IGVhcmx5IGF2YWlsYWJsZSB0aW1lbGluZXMsIHdlIGRvbid0IG5lZWQgdG8gc3VwcG9ydFxuICAgIC8vIHBsYXlsaXN0cyB3aXRoIG5vIHNlZ21lbnRzLlxuXG5cbiAgICBjb25zdCBmaXJzdE5ld1NlZ21lbnQgPSBwbGF5bGlzdC5zZWdtZW50c1swXTtcbiAgICBjb25zdCBvbGRNYXRjaGluZ1NlZ21lbnRJbmRleCA9IG9sZFBsYXlsaXN0LnNlZ21lbnRzLmZpbmRJbmRleChmdW5jdGlvbiAob2xkU2VnbWVudCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKG9sZFNlZ21lbnQucHJlc2VudGF0aW9uVGltZSAtIGZpcnN0TmV3U2VnbWVudC5wcmVzZW50YXRpb25UaW1lKSA8IFRJTUVfRlVER0U7XG4gICAgfSk7IC8vIE5vIG1hdGNoaW5nIHNlZ21lbnQgZnJvbSB0aGUgb2xkIHBsYXlsaXN0IG1lYW5zIHRoZSBlbnRpcmUgcGxheWxpc3Qgd2FzIHJlZnJlc2hlZC5cbiAgICAvLyBJbiB0aGlzIGNhc2UgdGhlIG1lZGlhIHNlcXVlbmNlIHNob3VsZCBhY2NvdW50IGZvciB0aGlzIHVwZGF0ZSwgYW5kIHRoZSBuZXcgc2VnbWVudHNcbiAgICAvLyBzaG91bGQgYmUgbWFya2VkIGFzIGRpc2NvbnRpbnVvdXMgZnJvbSB0aGUgcHJpb3IgY29udGVudCwgc2luY2UgdGhlIGxhc3QgcHJpb3JcbiAgICAvLyB0aW1lbGluZSB3YXMgcmVtb3ZlZC5cblxuICAgIGlmIChvbGRNYXRjaGluZ1NlZ21lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHVwZGF0ZU1lZGlhU2VxdWVuY2VGb3JQbGF5bGlzdCh7XG4gICAgICAgIHBsYXlsaXN0LFxuICAgICAgICBtZWRpYVNlcXVlbmNlOiBvbGRQbGF5bGlzdC5tZWRpYVNlcXVlbmNlICsgb2xkUGxheWxpc3Quc2VnbWVudHMubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHBsYXlsaXN0LnNlZ21lbnRzWzBdLmRpc2NvbnRpbnVpdHkgPSB0cnVlO1xuICAgICAgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy51bnNoaWZ0KDApOyAvLyBObyBtYXRjaGluZyBzZWdtZW50IGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhlcmUncyBtaXNzaW5nIGNvbnRlbnQuXG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIG5ldyBwbGF5bGlzdCdzIHRpbWVsaW5lIGlzIHRoZSBzYW1lIGFzIHRoZSBsYXN0IHNlZW4gc2VnbWVudCdzIHRpbWVsaW5lLFxuICAgICAgLy8gdGhlbiBhIGRpc2NvbnRpbnVpdHkgY2FuIGJlIGFkZGVkIHRvIGlkZW50aWZ5IHRoYXQgdGhlcmUncyBwb3RlbnRpYWxseSBtaXNzaW5nXG4gICAgICAvLyBjb250ZW50LiBJZiB0aGVyZSdzIG5vIG1pc3NpbmcgY29udGVudCwgdGhlIGRpc2NvbnRpbnVpdHkgc2hvdWxkIHN0aWxsIGJlIHJhdGhlclxuICAgICAgLy8gaGFybWxlc3MuIEl0J3MgcG9zc2libGUgdGhhdCBpZiBzZWdtZW50IGR1cmF0aW9ucyBhcmUgYWNjdXJhdGUgZW5vdWdoLCB0aGF0IHRoZVxuICAgICAgLy8gZXhpc3RlbmNlIG9mIGEgZ2FwIGNhbiBiZSBkZXRlcm1pbmVkIHVzaW5nIHRoZSBwcmVzZW50YXRpb24gdGltZXMgYW5kIGR1cmF0aW9ucyxcbiAgICAgIC8vIGJ1dCBpZiB0aGUgc2VnbWVudCB0aW1pbmcgaW5mbyBpcyBvZmYsIGl0IG1heSBpbnRyb2R1Y2UgbW9yZSBwcm9ibGVtcyB0aGFuIHNpbXBseVxuICAgICAgLy8gYWRkaW5nIHRoZSBkaXNjb250aW51aXR5LlxuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBuZXcgcGxheWxpc3QncyB0aW1lbGluZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCBzZWVuIHNlZ21lbnQncyB0aW1lbGluZSxcbiAgICAgIC8vIHRoZW4gYSBkaXNjb250aW51aXR5IGNhbiBiZSBhZGRlZCB0byBpZGVudGlmeSB0aGF0IHRoaXMgaXMgdGhlIGZpcnN0IHNlZW4gc2VnbWVudFxuICAgICAgLy8gb2YgYSBuZXcgdGltZWxpbmUuIEhvd2V2ZXIsIHRoZSBsb2dpYyBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvbiB0aGF0XG4gICAgICAvLyBkZXRlcm1pbmVkIHRoZSBkaXNjb25pbnVpdHkgc2VxdWVuY2UgYnkgdGltZWxpbmUgaW5kZXggaXMgbm93IG9mZiBieSBvbmUgKHRoZVxuICAgICAgLy8gZGlzY29udGludWl0eSBvZiB0aGUgbmV3ZXN0IHRpbWVsaW5lIGhhc24ndCB5ZXQgZmFsbGVuIG9mZiB0aGUgbWFuaWZlc3QuLi5zaW5jZVxuICAgICAgLy8gd2UgYWRkZWQgaXQpLCBzbyB0aGUgZGlzY29uaW51aXR5IHNlcXVlbmNlIG11c3QgYmUgZGVjcmVtZW50ZWQuXG4gICAgICAvL1xuICAgICAgLy8gQSBwZXJpb2QgbWF5IGFsc28gaGF2ZSBhIGR1cmF0aW9uIG9mIHplcm8sIHNvIHRoZSBjYXNlIG9mIG5vIHNlZ21lbnRzIGlzIGhhbmRsZWRcbiAgICAgIC8vIGhlcmUgZXZlbiB0aG91Z2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQgZWFybHkgYXZhaWxhYmxlIHBlcmlvZHMuXG5cbiAgICAgIGlmICghb2xkUGxheWxpc3Quc2VnbWVudHMubGVuZ3RoICYmIHBsYXlsaXN0LnRpbWVsaW5lID4gb2xkUGxheWxpc3QudGltZWxpbmUgfHwgb2xkUGxheWxpc3Quc2VnbWVudHMubGVuZ3RoICYmIHBsYXlsaXN0LnRpbWVsaW5lID4gb2xkUGxheWxpc3Quc2VnbWVudHNbb2xkUGxheWxpc3Quc2VnbWVudHMubGVuZ3RoIC0gMV0udGltZWxpbmUpIHtcbiAgICAgICAgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZSBmaXJzdCBzZWdtZW50IG1hdGNoZWQgd2l0aCBhIHByaW9yIHNlZ21lbnQgb24gYSBkaXNjb250aW51aXR5IChpdCdzIG1hdGNoaW5nXG4gICAgLy8gb24gdGhlIGZpcnN0IHNlZ21lbnQgb2YgYSBwZXJpb2QpLCB0aGVuIHRoZSBkaXNjb250aW51aXR5U2VxdWVuY2Ugc2hvdWxkbid0IGJlIHRoZVxuICAgIC8vIHRpbWVsaW5lJ3MgbWF0Y2hpbmcgb25lLCBidXQgaW5zdGVhZCBzaG91bGQgYmUgdGhlIG9uZSBwcmlvciwgYW5kIHRoZSBmaXJzdCBzZWdtZW50XG4gICAgLy8gb2YgdGhlIG5ldyBtYW5pZmVzdCBzaG91bGQgYmUgbWFya2VkIHdpdGggYSBkaXNjb250aW51aXR5LlxuICAgIC8vXG4gICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBzcGVjaWFsIGNhc2UgaXMgdGhhdCBkaXNjb250aW51aXR5IHNlcXVlbmNlIHNob3dzIGhvdyBtYW55XG4gICAgLy8gZGlzY29udGludWl0aWVzIGhhdmUgZmFsbGVuIG9mZiBvZiB0aGUgcGxheWxpc3QsIGFuZCBkaXNjb250aW51aXRpZXMgYXJlIG1hcmtlZCBvblxuICAgIC8vIHRoZSBmaXJzdCBzZWdtZW50IG9mIGEgbmV3IFwidGltZWxpbmUuXCIgQmVjYXVzZSBvZiB0aGlzLCB3aGlsZSBEQVNIIHdpbGwgcmV0YWluIHRoYXRcbiAgICAvLyBQZXJpb2Qgd2hpbGUgdGhlIFwidGltZWxpbmVcIiBleGlzdHMsIEhMUyBrZWVwcyB0cmFjayBvZiBpdCB2aWEgdGhlIGRpc2NvbnRpbnVpdHlcbiAgICAvLyBzZXF1ZW5jZSwgYW5kIHRoYXQgZmlyc3Qgc2VnbWVudCBpcyBhbiBpbmRpY2F0b3IsIGJ1dCBjYW4gYmUgcmVtb3ZlZCBiZWZvcmUgdGhhdFxuICAgIC8vIHRpbWVsaW5lIGlzIGdvbmUuXG5cblxuICAgIGNvbnN0IG9sZE1hdGNoaW5nU2VnbWVudCA9IG9sZFBsYXlsaXN0LnNlZ21lbnRzW29sZE1hdGNoaW5nU2VnbWVudEluZGV4XTtcblxuICAgIGlmIChvbGRNYXRjaGluZ1NlZ21lbnQuZGlzY29udGludWl0eSAmJiAhZmlyc3ROZXdTZWdtZW50LmRpc2NvbnRpbnVpdHkpIHtcbiAgICAgIGZpcnN0TmV3U2VnbWVudC5kaXNjb250aW51aXR5ID0gdHJ1ZTtcbiAgICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMudW5zaGlmdCgwKTtcbiAgICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZS0tO1xuICAgIH1cblxuICAgIHVwZGF0ZU1lZGlhU2VxdWVuY2VGb3JQbGF5bGlzdCh7XG4gICAgICBwbGF5bGlzdCxcbiAgICAgIG1lZGlhU2VxdWVuY2U6IG9sZFBsYXlsaXN0LnNlZ21lbnRzW29sZE1hdGNoaW5nU2VnbWVudEluZGV4XS5udW1iZXJcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhbiBvbGQgcGFyc2VkIG1hbmlmZXN0IG9iamVjdCBhbmQgYSBuZXcgcGFyc2VkIG1hbmlmZXN0IG9iamVjdCwgdXBkYXRlcyB0aGVcbiAqIHNlcXVlbmNlIGFuZCB0aW1pbmcgdmFsdWVzIHdpdGhpbiB0aGUgbmV3IG1hbmlmZXN0IHRvIGVuc3VyZSB0aGF0IGl0IGxpbmVzIHVwIHdpdGggdGhlXG4gKiBvbGQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb2xkTWFuaWZlc3QgLSB0aGUgb2xkIG1haW4gbWFuaWZlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBuZXdNYW5pZmVzdCAtIHRoZSBuZXcgbWFpbiBtYW5pZmVzdCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB1cGRhdGVkIG5ldyBtYW5pZmVzdCBvYmplY3RcbiAqL1xuXG5jb25zdCBwb3NpdGlvbk1hbmlmZXN0T25UaW1lbGluZSA9ICh7XG4gIG9sZE1hbmlmZXN0LFxuICBuZXdNYW5pZmVzdFxufSkgPT4ge1xuICAvLyBTdGFydGluZyBmcm9tIHY0LjEuMiBvZiB0aGUgSU9QLCBzZWN0aW9uIDQuNC4zLjMgc3RhdGVzOlxuICAvL1xuICAvLyBcIk1QREBhdmFpbGFiaWxpdHlTdGFydFRpbWUgYW5kIFBlcmlvZEBzdGFydCBzaGFsbCBub3QgYmUgY2hhbmdlZCBvdmVyIE1QRCB1cGRhdGVzLlwiXG4gIC8vXG4gIC8vIFRoaXMgd2FzIGFkZGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vREFTSC1JRi1JT1AvaXNzdWVzLzE2MFxuICAvL1xuICAvLyBCZWNhdXNlIG9mIHRoaXMgY2hhbmdlLCBhbmQgdGhlIGRpZmZpY3VsdHkgb2Ygc3VwcG9ydGluZyBwZXJpb2RzIHdpdGggY2hhbmdpbmcgc3RhcnRcbiAgLy8gdGltZXMsIHBlcmlvZHMgd2l0aCBjaGFuZ2luZyBzdGFydCB0aW1lcyBhcmUgbm90IHN1cHBvcnRlZC4gVGhpcyBtYWtlcyB0aGUgbG9naWMgbXVjaFxuICAvLyBzaW1wbGVyLCBzaW5jZSBwZXJpb2RzIHdpdGggdGhlIHNhbWUgc3RhcnQgdGltZSBjYW4gYmUgY29uc2lkZXJyZWQgdGhlIHNhbWUgcGVyaW9kXG4gIC8vIGFjcm9zcyByZWZyZXNoZXMuXG4gIC8vXG4gIC8vIFRvIGdpdmUgYW4gZXhhbXBsZSBhcyB0byB0aGUgZGlmZmljdWx0eSBvZiBoYW5kbGluZyBwZXJpb2RzIHdoZXJlIHRoZSBzdGFydCB0aW1lIG1heVxuICAvLyBjaGFuZ2UsIGlmIGEgc2luZ2xlIHBlcmlvZCBtYW5pZmVzdCBpcyByZWZyZXNoZWQgd2l0aCBhbm90aGVyIG1hbmlmZXN0IHdpdGggYSBzaW5nbGVcbiAgLy8gcGVyaW9kLCBhbmQgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lcyBhcmUgaW5jcmVhc2VkLCB0aGVuIHRoZSBvbmx5IHdheSB0byBkZXRlcm1pbmVcbiAgLy8gaWYgaXQncyBhIG5ldyBwZXJpb2Qgb3IgYW4gb2xkIG9uZSB0aGF0IGhhcyBjaGFuZ2VkIGlzIHRvIGxvb2sgdGhyb3VnaCB0aGUgc2VnbWVudHMgb2ZcbiAgLy8gZWFjaCBwbGF5bGlzdCBhbmQgZGV0ZXJtaW5lIHRoZSBwcmVzZW50YXRpb24gdGltZSBib3VuZHMgdG8gZmluZCBhIG1hdGNoLiBJbiBhZGRpdGlvbixcbiAgLy8gaWYgdGhlIHBlcmlvZCBzdGFydCBjaGFuZ2VkIHRvIGV4Y2VlZCB0aGUgb2xkIHBlcmlvZCBlbmQsIHRoZW4gdGhlcmUgd291bGQgYmUgbm9cbiAgLy8gbWF0Y2gsIGFuZCBpdCB3b3VsZCBub3QgYmUgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHJlZnJlc2hlZCBwZXJpb2QgaXMgYSBuZXdcbiAgLy8gb25lIG9yIHRoZSBvbGQgb25lLlxuICBjb25zdCBvbGRQbGF5bGlzdHMgPSBvbGRNYW5pZmVzdC5wbGF5bGlzdHMuY29uY2F0KGdldE1lZGlhR3JvdXBQbGF5bGlzdHMob2xkTWFuaWZlc3QpKTtcbiAgY29uc3QgbmV3UGxheWxpc3RzID0gbmV3TWFuaWZlc3QucGxheWxpc3RzLmNvbmNhdChnZXRNZWRpYUdyb3VwUGxheWxpc3RzKG5ld01hbmlmZXN0KSk7IC8vIFNhdmUgYWxsIHNlZW4gdGltZWxpbmVTdGFydHMgdG8gdGhlIG5ldyBtYW5pZmVzdC4gQWx0aG91Z2ggdGhpcyBwb3RlbnRpYWxseSBtZWFucyB0aGF0XG4gIC8vIHRoZXJlJ3MgYSBcIm1lbW9yeSBsZWFrXCIgaW4gdGhhdCBpdCB3aWxsIG5ldmVyIHN0b3AgZ3Jvd2luZywgaW4gcmVhbGl0eSwgb25seSBhIGNvdXBsZVxuICAvLyBvZiBwcm9wZXJ0aWVzIGFyZSBzYXZlZCBmb3IgZWFjaCBzZWVuIFBlcmlvZC4gRXZlbiBsb25nIHJ1bm5pbmcgbGl2ZSBzdHJlYW1zIHdvbid0XG4gIC8vIGdlbmVyYXRlIHRvbyBtYW55IFBlcmlvZHMsIHVubGVzcyB0aGUgc3RyZWFtIGlzIHdhdGNoZWQgZm9yIGRlY2FkZXMuIEluIHRoZSBmdXR1cmUsXG4gIC8vIHRoaXMgY2FuIGJlIG9wdGltaXplZCBieSBtYXBwaW5nIHRvIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbnVtYmVycyBmb3IgZWFjaCB0aW1lbGluZSxcbiAgLy8gYnV0IGl0IG1heSBub3QgYmVjb21lIGFuIGlzc3VlLCBhbmQgdGhlIGFkZGl0aW9uYWwgaW5mbyBjYW4gYmUgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG5cbiAgbmV3TWFuaWZlc3QudGltZWxpbmVTdGFydHMgPSBnZXRVbmlxdWVUaW1lbGluZVN0YXJ0cyhbb2xkTWFuaWZlc3QudGltZWxpbmVTdGFydHMsIG5ld01hbmlmZXN0LnRpbWVsaW5lU3RhcnRzXSk7XG4gIHVwZGF0ZVNlcXVlbmNlTnVtYmVycyh7XG4gICAgb2xkUGxheWxpc3RzLFxuICAgIG5ld1BsYXlsaXN0cyxcbiAgICB0aW1lbGluZVN0YXJ0czogbmV3TWFuaWZlc3QudGltZWxpbmVTdGFydHNcbiAgfSk7XG4gIHJldHVybiBuZXdNYW5pZmVzdDtcbn07XG5cbmNvbnN0IGdlbmVyYXRlU2lkeEtleSA9IHNpZHggPT4gc2lkeCAmJiBzaWR4LnVyaSArICctJyArIGJ5dGVSYW5nZVRvU3RyaW5nKHNpZHguYnl0ZXJhbmdlKTtcblxuY29uc3QgbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzID0gcGxheWxpc3RzID0+IHtcbiAgLy8gQnJlYWsgb3V0IHBsYXlsaXN0cyBpbnRvIGdyb3VwcyBiYXNlZCBvbiB0aGVpciBiYXNlVXJsXG4gIGNvbnN0IHBsYXlsaXN0c0J5QmFzZVVybCA9IHBsYXlsaXN0cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyKSB7XG4gICAgaWYgKCFhY2NbY3VyLmF0dHJpYnV0ZXMuYmFzZVVybF0pIHtcbiAgICAgIGFjY1tjdXIuYXR0cmlidXRlcy5iYXNlVXJsXSA9IFtdO1xuICAgIH1cblxuICAgIGFjY1tjdXIuYXR0cmlidXRlcy5iYXNlVXJsXS5wdXNoKGN1cik7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICBsZXQgYWxsUGxheWxpc3RzID0gW107XG4gIE9iamVjdC52YWx1ZXMocGxheWxpc3RzQnlCYXNlVXJsKS5mb3JFYWNoKHBsYXlsaXN0R3JvdXAgPT4ge1xuICAgIGNvbnN0IG1lcmdlZFBsYXlsaXN0cyA9IHZhbHVlcyhwbGF5bGlzdEdyb3VwLnJlZHVjZSgoYWNjLCBwbGF5bGlzdCkgPT4ge1xuICAgICAgLy8gYXNzdW1pbmcgcGxheWxpc3QgSURzIGFyZSB0aGUgc2FtZSBhY3Jvc3MgcGVyaW9kc1xuICAgICAgLy8gVE9ETzogaGFuZGxlIG11bHRpcGVyaW9kIHdoZXJlIHJlcHJlc2VudGF0aW9uIHNldHMgYXJlIG5vdCB0aGUgc2FtZVxuICAgICAgLy8gYWNyb3NzIHBlcmlvZHNcbiAgICAgIGNvbnN0IG5hbWUgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmlkICsgKHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFuZyB8fCAnJyk7XG5cbiAgICAgIGlmICghYWNjW25hbWVdKSB7XG4gICAgICAgIC8vIEZpcnN0IFBlcmlvZFxuICAgICAgICBhY2NbbmFtZV0gPSBwbGF5bGlzdDtcbiAgICAgICAgYWNjW25hbWVdLmF0dHJpYnV0ZXMudGltZWxpbmVTdGFydHMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN1YnNlcXVlbnQgUGVyaW9kc1xuICAgICAgICBpZiAocGxheWxpc3Quc2VnbWVudHMpIHtcbiAgICAgICAgICAvLyBmaXJzdCBzZWdtZW50IG9mIHN1YnNlcXVlbnQgcGVyaW9kcyBzaWduYWwgYSBkaXNjb250aW51aXR5XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LnNlZ21lbnRzWzBdKSB7XG4gICAgICAgICAgICBwbGF5bGlzdC5zZWdtZW50c1swXS5kaXNjb250aW51aXR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY2NbbmFtZV0uc2VnbWVudHMucHVzaCguLi5wbGF5bGlzdC5zZWdtZW50cyk7XG4gICAgICAgIH0gLy8gYnViYmxlIHVwIGNvbnRlbnRQcm90ZWN0aW9uLCB0aGlzIGFzc3VtZXMgYWxsIERSTSBjb250ZW50XG4gICAgICAgIC8vIGhhcyB0aGUgc2FtZSBjb250ZW50UHJvdGVjdGlvblxuXG5cbiAgICAgICAgaWYgKHBsYXlsaXN0LmF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb24pIHtcbiAgICAgICAgICBhY2NbbmFtZV0uYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbiA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWNjW25hbWVdLmF0dHJpYnV0ZXMudGltZWxpbmVTdGFydHMucHVzaCh7XG4gICAgICAgIC8vIEFsdGhvdWdoIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG51bWJlciwgaXQncyBpbXBvcnRhbnQgdG8gaGF2ZSBib3RoIHRvIG1ha2UgaXRcbiAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIEhMUyBwb3RlbnRpYWxseSBoYXZpbmcgYSBzaW1pbGFyIGF0dHJpYnV0ZS5cbiAgICAgICAgc3RhcnQ6IHBsYXlsaXN0LmF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgICAgIHRpbWVsaW5lOiBwbGF5bGlzdC5hdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pKTtcbiAgICBhbGxQbGF5bGlzdHMgPSBhbGxQbGF5bGlzdHMuY29uY2F0KG1lcmdlZFBsYXlsaXN0cyk7XG4gIH0pO1xuICByZXR1cm4gYWxsUGxheWxpc3RzLm1hcChwbGF5bGlzdCA9PiB7XG4gICAgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cyA9IGZpbmRJbmRleGVzKHBsYXlsaXN0LnNlZ21lbnRzIHx8IFtdLCAnZGlzY29udGludWl0eScpO1xuICAgIHJldHVybiBwbGF5bGlzdDtcbiAgfSk7XG59O1xuXG5jb25zdCBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0ID0gKHBsYXlsaXN0LCBzaWR4TWFwcGluZykgPT4ge1xuICBjb25zdCBzaWR4S2V5ID0gZ2VuZXJhdGVTaWR4S2V5KHBsYXlsaXN0LnNpZHgpO1xuICBjb25zdCBzaWR4TWF0Y2ggPSBzaWR4S2V5ICYmIHNpZHhNYXBwaW5nW3NpZHhLZXldICYmIHNpZHhNYXBwaW5nW3NpZHhLZXldLnNpZHg7XG5cbiAgaWYgKHNpZHhNYXRjaCkge1xuICAgIGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QkMShwbGF5bGlzdCwgc2lkeE1hdGNoLCBwbGF5bGlzdC5zaWR4LnJlc29sdmVkVXJpKTtcbiAgfVxuXG4gIHJldHVybiBwbGF5bGlzdDtcbn07XG5jb25zdCBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0cyA9IChwbGF5bGlzdHMsIHNpZHhNYXBwaW5nID0ge30pID0+IHtcbiAgaWYgKCFPYmplY3Qua2V5cyhzaWR4TWFwcGluZykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBsYXlsaXN0cztcbiAgfVxuXG4gIGZvciAoY29uc3QgaSBpbiBwbGF5bGlzdHMpIHtcbiAgICBwbGF5bGlzdHNbaV0gPSBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0KHBsYXlsaXN0c1tpXSwgc2lkeE1hcHBpbmcpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0cztcbn07XG5jb25zdCBmb3JtYXRBdWRpb1BsYXlsaXN0ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgc2VnbWVudHMsXG4gIHNpZHgsXG4gIG1lZGlhU2VxdWVuY2UsXG4gIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZSxcbiAgZGlzY29udGludWl0eVN0YXJ0c1xufSwgaXNBdWRpb09ubHkpID0+IHtcbiAgY29uc3QgcGxheWxpc3QgPSB7XG4gICAgYXR0cmlidXRlczoge1xuICAgICAgTkFNRTogYXR0cmlidXRlcy5pZCxcbiAgICAgIEJBTkRXSURUSDogYXR0cmlidXRlcy5iYW5kd2lkdGgsXG4gICAgICBDT0RFQ1M6IGF0dHJpYnV0ZXMuY29kZWNzLFxuICAgICAgWydQUk9HUkFNLUlEJ106IDFcbiAgICB9LFxuICAgIHVyaTogJycsXG4gICAgZW5kTGlzdDogYXR0cmlidXRlcy50eXBlID09PSAnc3RhdGljJyxcbiAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICByZXNvbHZlZFVyaTogYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLFxuICAgIHRhcmdldER1cmF0aW9uOiBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZSxcbiAgICBkaXNjb250aW51aXR5U3RhcnRzLFxuICAgIHRpbWVsaW5lU3RhcnRzOiBhdHRyaWJ1dGVzLnRpbWVsaW5lU3RhcnRzLFxuICAgIG1lZGlhU2VxdWVuY2UsXG4gICAgc2VnbWVudHNcbiAgfTtcblxuICBpZiAoYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbikge1xuICAgIHBsYXlsaXN0LmNvbnRlbnRQcm90ZWN0aW9uID0gYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbjtcbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbikge1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uID0gYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb247XG4gIH1cblxuICBpZiAoc2lkeCkge1xuICAgIHBsYXlsaXN0LnNpZHggPSBzaWR4O1xuICB9XG5cbiAgaWYgKGlzQXVkaW9Pbmx5KSB7XG4gICAgcGxheWxpc3QuYXR0cmlidXRlcy5BVURJTyA9ICdhdWRpbyc7XG4gICAgcGxheWxpc3QuYXR0cmlidXRlcy5TVUJUSVRMRVMgPSAnc3Vicyc7XG4gIH1cblxuICByZXR1cm4gcGxheWxpc3Q7XG59O1xuY29uc3QgZm9ybWF0VnR0UGxheWxpc3QgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBzZWdtZW50cyxcbiAgbWVkaWFTZXF1ZW5jZSxcbiAgZGlzY29udGludWl0eVN0YXJ0cyxcbiAgZGlzY29udGludWl0eVNlcXVlbmNlXG59KSA9PiB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gdnR0IHRyYWNrcyBtYXkgdXNlIHNpbmdsZSBmaWxlIGluIEJhc2VVUkxcbiAgICBzZWdtZW50cyA9IFt7XG4gICAgICB1cmk6IGF0dHJpYnV0ZXMuYmFzZVVybCxcbiAgICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgICAgcmVzb2x2ZWRVcmk6IGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJyxcbiAgICAgIGR1cmF0aW9uOiBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uLFxuICAgICAgbnVtYmVyOiAwXG4gICAgfV07IC8vIHRhcmdldER1cmF0aW9uIHNob3VsZCBiZSB0aGUgc2FtZSBkdXJhdGlvbiBhcyB0aGUgb25seSBzZWdtZW50XG5cbiAgICBhdHRyaWJ1dGVzLmR1cmF0aW9uID0gYXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbjtcbiAgfVxuXG4gIGNvbnN0IG0zdThBdHRyaWJ1dGVzID0ge1xuICAgIE5BTUU6IGF0dHJpYnV0ZXMuaWQsXG4gICAgQkFORFdJRFRIOiBhdHRyaWJ1dGVzLmJhbmR3aWR0aCxcbiAgICBbJ1BST0dSQU0tSUQnXTogMVxuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLmNvZGVjcykge1xuICAgIG0zdThBdHRyaWJ1dGVzLkNPREVDUyA9IGF0dHJpYnV0ZXMuY29kZWNzO1xuICB9XG5cbiAgY29uc3QgdnR0UGxheWxpc3QgPSB7XG4gICAgYXR0cmlidXRlczogbTN1OEF0dHJpYnV0ZXMsXG4gICAgdXJpOiAnJyxcbiAgICBlbmRMaXN0OiBhdHRyaWJ1dGVzLnR5cGUgPT09ICdzdGF0aWMnLFxuICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgIHJlc29sdmVkVXJpOiBhdHRyaWJ1dGVzLmJhc2VVcmwgfHwgJycsXG4gICAgdGFyZ2V0RHVyYXRpb246IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgdGltZWxpbmVTdGFydHM6IGF0dHJpYnV0ZXMudGltZWxpbmVTdGFydHMsXG4gICAgZGlzY29udGludWl0eVN0YXJ0cyxcbiAgICBkaXNjb250aW51aXR5U2VxdWVuY2UsXG4gICAgbWVkaWFTZXF1ZW5jZSxcbiAgICBzZWdtZW50c1xuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbikge1xuICAgIHZ0dFBsYXlsaXN0LmF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uID0gYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gdnR0UGxheWxpc3Q7XG59O1xuY29uc3Qgb3JnYW5pemVBdWRpb1BsYXlsaXN0cyA9IChwbGF5bGlzdHMsIHNpZHhNYXBwaW5nID0ge30sIGlzQXVkaW9Pbmx5ID0gZmFsc2UpID0+IHtcbiAgbGV0IG1haW5QbGF5bGlzdDtcbiAgY29uc3QgZm9ybWF0dGVkUGxheWxpc3RzID0gcGxheWxpc3RzLnJlZHVjZSgoYSwgcGxheWxpc3QpID0+IHtcbiAgICBjb25zdCByb2xlID0gcGxheWxpc3QuYXR0cmlidXRlcy5yb2xlICYmIHBsYXlsaXN0LmF0dHJpYnV0ZXMucm9sZS52YWx1ZSB8fCAnJztcbiAgICBjb25zdCBsYW5ndWFnZSA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFuZyB8fCAnJztcbiAgICBsZXQgbGFiZWwgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhYmVsIHx8ICdtYWluJztcblxuICAgIGlmIChsYW5ndWFnZSAmJiAhcGxheWxpc3QuYXR0cmlidXRlcy5sYWJlbCkge1xuICAgICAgY29uc3Qgcm9sZUxhYmVsID0gcm9sZSA/IGAgKCR7cm9sZX0pYCA6ICcnO1xuICAgICAgbGFiZWwgPSBgJHtwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmd9JHtyb2xlTGFiZWx9YDtcbiAgICB9XG5cbiAgICBpZiAoIWFbbGFiZWxdKSB7XG4gICAgICBhW2xhYmVsXSA9IHtcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIGF1dG9zZWxlY3Q6IHRydWUsXG4gICAgICAgIGRlZmF1bHQ6IHJvbGUgPT09ICdtYWluJyxcbiAgICAgICAgcGxheWxpc3RzOiBbXSxcbiAgICAgICAgdXJpOiAnJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0KGZvcm1hdEF1ZGlvUGxheWxpc3QocGxheWxpc3QsIGlzQXVkaW9Pbmx5KSwgc2lkeE1hcHBpbmcpO1xuICAgIGFbbGFiZWxdLnBsYXlsaXN0cy5wdXNoKGZvcm1hdHRlZCk7XG5cbiAgICBpZiAodHlwZW9mIG1haW5QbGF5bGlzdCA9PT0gJ3VuZGVmaW5lZCcgJiYgcm9sZSA9PT0gJ21haW4nKSB7XG4gICAgICBtYWluUGxheWxpc3QgPSBwbGF5bGlzdDtcbiAgICAgIG1haW5QbGF5bGlzdC5kZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfSwge30pOyAvLyBpZiBubyBwbGF5bGlzdHMgaGF2ZSByb2xlIFwibWFpblwiLCBtYXJrIHRoZSBmaXJzdCBhcyBtYWluXG5cbiAgaWYgKCFtYWluUGxheWxpc3QpIHtcbiAgICBjb25zdCBmaXJzdExhYmVsID0gT2JqZWN0LmtleXMoZm9ybWF0dGVkUGxheWxpc3RzKVswXTtcbiAgICBmb3JtYXR0ZWRQbGF5bGlzdHNbZmlyc3RMYWJlbF0uZGVmYXVsdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0dGVkUGxheWxpc3RzO1xufTtcbmNvbnN0IG9yZ2FuaXplVnR0UGxheWxpc3RzID0gKHBsYXlsaXN0cywgc2lkeE1hcHBpbmcgPSB7fSkgPT4ge1xuICByZXR1cm4gcGxheWxpc3RzLnJlZHVjZSgoYSwgcGxheWxpc3QpID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFiZWwgfHwgcGxheWxpc3QuYXR0cmlidXRlcy5sYW5nIHx8ICd0ZXh0JztcbiAgICBjb25zdCBsYW5ndWFnZSA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFuZyB8fCAndW5kJztcblxuICAgIGlmICghYVtsYWJlbF0pIHtcbiAgICAgIGFbbGFiZWxdID0ge1xuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICBwbGF5bGlzdHM6IFtdLFxuICAgICAgICB1cmk6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFbbGFiZWxdLnBsYXlsaXN0cy5wdXNoKGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QoZm9ybWF0VnR0UGxheWxpc3QocGxheWxpc3QpLCBzaWR4TWFwcGluZykpO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59O1xuXG5jb25zdCBvcmdhbml6ZUNhcHRpb25TZXJ2aWNlcyA9IGNhcHRpb25TZXJ2aWNlcyA9PiBjYXB0aW9uU2VydmljZXMucmVkdWNlKChzdmNPYmosIHN2YykgPT4ge1xuICBpZiAoIXN2Yykge1xuICAgIHJldHVybiBzdmNPYmo7XG4gIH1cblxuICBzdmMuZm9yRWFjaChzZXJ2aWNlID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjaGFubmVsLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9ID0gc2VydmljZTtcbiAgICBzdmNPYmpbbGFuZ3VhZ2VdID0ge1xuICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGluc3RyZWFtSWQ6IGNoYW5uZWwsXG4gICAgICBsYW5ndWFnZVxuICAgIH07XG5cbiAgICBpZiAoc2VydmljZS5oYXNPd25Qcm9wZXJ0eSgnYXNwZWN0UmF0aW8nKSkge1xuICAgICAgc3ZjT2JqW2xhbmd1YWdlXS5hc3BlY3RSYXRpbyA9IHNlcnZpY2UuYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKHNlcnZpY2UuaGFzT3duUHJvcGVydHkoJ2Vhc3lSZWFkZXInKSkge1xuICAgICAgc3ZjT2JqW2xhbmd1YWdlXS5lYXN5UmVhZGVyID0gc2VydmljZS5lYXN5UmVhZGVyO1xuICAgIH1cblxuICAgIGlmIChzZXJ2aWNlLmhhc093blByb3BlcnR5KCczRCcpKSB7XG4gICAgICBzdmNPYmpbbGFuZ3VhZ2VdWyczRCddID0gc2VydmljZVsnM0QnXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3ZjT2JqO1xufSwge30pO1xuXG5jb25zdCBmb3JtYXRWaWRlb1BsYXlsaXN0ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgc2VnbWVudHMsXG4gIHNpZHgsXG4gIGRpc2NvbnRpbnVpdHlTdGFydHNcbn0pID0+IHtcbiAgY29uc3QgcGxheWxpc3QgPSB7XG4gICAgYXR0cmlidXRlczoge1xuICAgICAgTkFNRTogYXR0cmlidXRlcy5pZCxcbiAgICAgIEFVRElPOiAnYXVkaW8nLFxuICAgICAgU1VCVElUTEVTOiAnc3VicycsXG4gICAgICBSRVNPTFVUSU9OOiB7XG4gICAgICAgIHdpZHRoOiBhdHRyaWJ1dGVzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGF0dHJpYnV0ZXMuaGVpZ2h0XG4gICAgICB9LFxuICAgICAgQ09ERUNTOiBhdHRyaWJ1dGVzLmNvZGVjcyxcbiAgICAgIEJBTkRXSURUSDogYXR0cmlidXRlcy5iYW5kd2lkdGgsXG4gICAgICBbJ1BST0dSQU0tSUQnXTogMVxuICAgIH0sXG4gICAgdXJpOiAnJyxcbiAgICBlbmRMaXN0OiBhdHRyaWJ1dGVzLnR5cGUgPT09ICdzdGF0aWMnLFxuICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgIHJlc29sdmVkVXJpOiBhdHRyaWJ1dGVzLmJhc2VVcmwgfHwgJycsXG4gICAgdGFyZ2V0RHVyYXRpb246IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgZGlzY29udGludWl0eVN0YXJ0cyxcbiAgICB0aW1lbGluZVN0YXJ0czogYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyxcbiAgICBzZWdtZW50c1xuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLmZyYW1lUmF0ZSkge1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXNbJ0ZSQU1FLVJBVEUnXSA9IGF0dHJpYnV0ZXMuZnJhbWVSYXRlO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb24pIHtcbiAgICBwbGF5bGlzdC5jb250ZW50UHJvdGVjdGlvbiA9IGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb247XG4gIH1cblxuICBpZiAoYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb24pIHtcbiAgICBwbGF5bGlzdC5hdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbiA9IGF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uO1xuICB9XG5cbiAgaWYgKHNpZHgpIHtcbiAgICBwbGF5bGlzdC5zaWR4ID0gc2lkeDtcbiAgfVxuXG4gIHJldHVybiBwbGF5bGlzdDtcbn07XG5cbmNvbnN0IHZpZGVvT25seSA9ICh7XG4gIGF0dHJpYnV0ZXNcbn0pID0+IGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICd2aWRlby9tcDQnIHx8IGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICd2aWRlby93ZWJtJyB8fCBhdHRyaWJ1dGVzLmNvbnRlbnRUeXBlID09PSAndmlkZW8nO1xuXG5jb25zdCBhdWRpb09ubHkgPSAoe1xuICBhdHRyaWJ1dGVzXG59KSA9PiBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAnYXVkaW8vbXA0JyB8fCBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAnYXVkaW8vd2VibScgfHwgYXR0cmlidXRlcy5jb250ZW50VHlwZSA9PT0gJ2F1ZGlvJztcblxuY29uc3QgdnR0T25seSA9ICh7XG4gIGF0dHJpYnV0ZXNcbn0pID0+IGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICd0ZXh0L3Z0dCcgfHwgYXR0cmlidXRlcy5jb250ZW50VHlwZSA9PT0gJ3RleHQnO1xuLyoqXG4gKiBDb250YWlucyBzdGFydCBhbmQgdGltZWxpbmUgcHJvcGVydGllcyBkZW5vdGluZyBhIHRpbWVsaW5lIHN0YXJ0LiBGb3IgREFTSCwgdGhlc2Ugd2lsbFxuICogYmUgdGhlIHNhbWUgbnVtYmVyLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVsaW5lU3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydCAtIHRoZSBzdGFydCB0aW1lIG9mIHRoZSB0aW1lbGluZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVsaW5lIC0gdGhlIHRpbWVsaW5lIG51bWJlclxuICovXG5cbi8qKlxuICogQWRkcyBhcHByb3ByaWF0ZSBtZWRpYSBhbmQgZGlzY29udGludWl0eSBzZXF1ZW5jZSB2YWx1ZXMgdG8gdGhlIHNlZ21lbnRzIGFuZCBwbGF5bGlzdHMuXG4gKlxuICogVGhyb3VnaG91dCBtcGQtcGFyc2VyLCB0aGUgYG51bWJlcmAgYXR0cmlidXRlIGlzIHVzZWQgaW4gcmVsYXRpb24gdG8gYHN0YXJ0TnVtYmVyYCwgYVxuICogREFTSCBzcGVjaWZpYyBhdHRyaWJ1dGUgdXNlZCBpbiBjb25zdHJ1Y3Rpbmcgc2VnbWVudCBVUkkncyBmcm9tIHRlbXBsYXRlcy4gSG93ZXZlciwgZnJvbVxuICogYW4gSExTIHBlcnNwZWN0aXZlLCB0aGUgYG51bWJlcmAgYXR0cmlidXRlIG9uIGEgc2VnbWVudCB3b3VsZCBiZSBpdHMgYG1lZGlhU2VxdWVuY2VgXG4gKiB2YWx1ZSwgd2hpY2ggc2hvdWxkIHN0YXJ0IGF0IHRoZSBvcmlnaW5hbCBtZWRpYSBzZXF1ZW5jZSB2YWx1ZSAob3IgMCkgYW5kIGluY3JlbWVudCBieSAxXG4gKiBmb3IgZWFjaCBzZWdtZW50IHRoZXJlYWZ0ZXIuIFNpbmNlIERBU0gncyBgc3RhcnROdW1iZXJgIHZhbHVlcyBhcmUgaW5kZXBlbmRlbnQgcGVyXG4gKiBwZXJpb2QsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byB1c2UgaXQgZm9yIGBudW1iZXJgLiBJbnN0ZWFkLCBhc3N1bWUgZXZlcnl0aGluZyBzdGFydHNcbiAqIGZyb20gYSAwIG1lZGlhU2VxdWVuY2UgdmFsdWUgYW5kIGluY3JlbWVudCBmcm9tIHRoZXJlLlxuICpcbiAqIE5vdGUgdGhhdCBWSFMgY3VycmVudGx5IGRvZXNuJ3QgdXNlIHRoZSBgbnVtYmVyYCBwcm9wZXJ0eSwgYnV0IGl0IGNhbiBiZSBoZWxwZnVsIGZvclxuICogZGVidWdnaW5nIGFuZCBtYWtpbmcgc2Vuc2Ugb2YgdGhlIG1hbmlmZXN0LlxuICpcbiAqIEZvciBsaXZlIHBsYXlsaXN0cywgdG8gYWNjb3VudCBmb3IgdmFsdWVzIGluY3JlYXNpbmcgaW4gbWFuaWZlc3RzIHdoZW4gcGVyaW9kcyBhcmVcbiAqIHJlbW92ZWQgb24gcmVmcmVzaGVzLCBtZXJnaW5nIGxvZ2ljIHNob3VsZCBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgbnVtYmVycyB0byB0aGVpclxuICogYXBwcm9wcmlhdGUgdmFsdWVzICh0byBlbnN1cmUgdGhleSdyZSBzZXF1ZW50aWFsIGFuZCBpbmNyZWFzaW5nKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBwbGF5bGlzdHMgLSB0aGUgcGxheWxpc3RzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtUaW1lbGluZVN0YXJ0W119IHRpbWVsaW5lU3RhcnRzIC0gdGhlIHRpbWVsaW5lIHN0YXJ0cyBmb3IgdGhlIG1hbmlmZXN0XG4gKi9cblxuXG5jb25zdCBhZGRNZWRpYVNlcXVlbmNlVmFsdWVzID0gKHBsYXlsaXN0cywgdGltZWxpbmVTdGFydHMpID0+IHtcbiAgLy8gaW5jcmVtZW50IGFsbCBzZWdtZW50cyBzZXF1ZW50aWFsbHlcbiAgcGxheWxpc3RzLmZvckVhY2gocGxheWxpc3QgPT4ge1xuICAgIHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgPSAwO1xuICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSA9IHRpbWVsaW5lU3RhcnRzLmZpbmRJbmRleChmdW5jdGlvbiAoe1xuICAgICAgdGltZWxpbmVcbiAgICB9KSB7XG4gICAgICByZXR1cm4gdGltZWxpbmUgPT09IHBsYXlsaXN0LnRpbWVsaW5lO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwbGF5bGlzdC5zZWdtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsYXlsaXN0LnNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICBzZWdtZW50Lm51bWJlciA9IGluZGV4O1xuICAgIH0pO1xuICB9KTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbWVkaWEgZ3JvdXAgb2JqZWN0LCBmbGF0dGVucyBhbGwgcGxheWxpc3RzIHdpdGhpbiB0aGUgbWVkaWEgZ3JvdXAgaW50byBhIHNpbmdsZVxuICogYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lZGlhR3JvdXBPYmplY3QgLSB0aGUgbWVkaWEgZ3JvdXAgb2JqZWN0XG4gKlxuICogQHJldHVybiB7T2JqZWN0W119XG4gKiAgICAgICAgIFRoZSBtZWRpYSBncm91cCBwbGF5bGlzdHNcbiAqL1xuXG5jb25zdCBmbGF0dGVuTWVkaWFHcm91cFBsYXlsaXN0cyA9IG1lZGlhR3JvdXBPYmplY3QgPT4ge1xuICBpZiAoIW1lZGlhR3JvdXBPYmplY3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVkaWFHcm91cE9iamVjdCkucmVkdWNlKChhY2MsIGxhYmVsKSA9PiB7XG4gICAgY29uc3QgbGFiZWxDb250ZW50cyA9IG1lZGlhR3JvdXBPYmplY3RbbGFiZWxdO1xuICAgIHJldHVybiBhY2MuY29uY2F0KGxhYmVsQ29udGVudHMucGxheWxpc3RzKTtcbiAgfSwgW10pO1xufTtcbmNvbnN0IHRvTTN1OCA9ICh7XG4gIGRhc2hQbGF5bGlzdHMsXG4gIGxvY2F0aW9ucyxcbiAgY29udGVudFN0ZWVyaW5nLFxuICBzaWR4TWFwcGluZyA9IHt9LFxuICBwcmV2aW91c01hbmlmZXN0LFxuICBldmVudFN0cmVhbVxufSkgPT4ge1xuICBpZiAoIWRhc2hQbGF5bGlzdHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9IC8vIGdyYWIgYWxsIG1haW4gbWFuaWZlc3QgYXR0cmlidXRlc1xuXG5cbiAgY29uc3Qge1xuICAgIHNvdXJjZUR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICB0eXBlLFxuICAgIHN1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5LFxuICAgIG1pbmltdW1VcGRhdGVQZXJpb2RcbiAgfSA9IGRhc2hQbGF5bGlzdHNbMF0uYXR0cmlidXRlcztcbiAgY29uc3QgdmlkZW9QbGF5bGlzdHMgPSBtZXJnZURpc2NvbnRpZ3VvdXNQbGF5bGlzdHMoZGFzaFBsYXlsaXN0cy5maWx0ZXIodmlkZW9Pbmx5KSkubWFwKGZvcm1hdFZpZGVvUGxheWxpc3QpO1xuICBjb25zdCBhdWRpb1BsYXlsaXN0cyA9IG1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyhkYXNoUGxheWxpc3RzLmZpbHRlcihhdWRpb09ubHkpKTtcbiAgY29uc3QgdnR0UGxheWxpc3RzID0gbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzKGRhc2hQbGF5bGlzdHMuZmlsdGVyKHZ0dE9ubHkpKTtcbiAgY29uc3QgY2FwdGlvbnMgPSBkYXNoUGxheWxpc3RzLm1hcChwbGF5bGlzdCA9PiBwbGF5bGlzdC5hdHRyaWJ1dGVzLmNhcHRpb25TZXJ2aWNlcykuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBtYW5pZmVzdCA9IHtcbiAgICBhbGxvd0NhY2hlOiB0cnVlLFxuICAgIGRpc2NvbnRpbnVpdHlTdGFydHM6IFtdLFxuICAgIHNlZ21lbnRzOiBbXSxcbiAgICBlbmRMaXN0OiB0cnVlLFxuICAgIG1lZGlhR3JvdXBzOiB7XG4gICAgICBBVURJTzoge30sXG4gICAgICBWSURFTzoge30sXG4gICAgICBbJ0NMT1NFRC1DQVBUSU9OUyddOiB7fSxcbiAgICAgIFNVQlRJVExFUzoge31cbiAgICB9LFxuICAgIHVyaTogJycsXG4gICAgZHVyYXRpb24sXG4gICAgcGxheWxpc3RzOiBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0cyh2aWRlb1BsYXlsaXN0cywgc2lkeE1hcHBpbmcpXG4gIH07XG5cbiAgaWYgKG1pbmltdW1VcGRhdGVQZXJpb2QgPj0gMCkge1xuICAgIG1hbmlmZXN0Lm1pbmltdW1VcGRhdGVQZXJpb2QgPSBtaW5pbXVtVXBkYXRlUGVyaW9kICogMTAwMDtcbiAgfVxuXG4gIGlmIChsb2NhdGlvbnMpIHtcbiAgICBtYW5pZmVzdC5sb2NhdGlvbnMgPSBsb2NhdGlvbnM7XG4gIH1cblxuICBpZiAoY29udGVudFN0ZWVyaW5nKSB7XG4gICAgbWFuaWZlc3QuY29udGVudFN0ZWVyaW5nID0gY29udGVudFN0ZWVyaW5nO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdkeW5hbWljJykge1xuICAgIG1hbmlmZXN0LnN1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5ID0gc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXk7XG4gIH1cblxuICBpZiAoZXZlbnRTdHJlYW0gJiYgZXZlbnRTdHJlYW0ubGVuZ3RoID4gMCkge1xuICAgIG1hbmlmZXN0LmV2ZW50U3RyZWFtID0gZXZlbnRTdHJlYW07XG4gIH1cblxuICBjb25zdCBpc0F1ZGlvT25seSA9IG1hbmlmZXN0LnBsYXlsaXN0cy5sZW5ndGggPT09IDA7XG4gIGNvbnN0IG9yZ2FuaXplZEF1ZGlvR3JvdXAgPSBhdWRpb1BsYXlsaXN0cy5sZW5ndGggPyBvcmdhbml6ZUF1ZGlvUGxheWxpc3RzKGF1ZGlvUGxheWxpc3RzLCBzaWR4TWFwcGluZywgaXNBdWRpb09ubHkpIDogbnVsbDtcbiAgY29uc3Qgb3JnYW5pemVkVnR0R3JvdXAgPSB2dHRQbGF5bGlzdHMubGVuZ3RoID8gb3JnYW5pemVWdHRQbGF5bGlzdHModnR0UGxheWxpc3RzLCBzaWR4TWFwcGluZykgOiBudWxsO1xuICBjb25zdCBmb3JtYXR0ZWRQbGF5bGlzdHMgPSB2aWRlb1BsYXlsaXN0cy5jb25jYXQoZmxhdHRlbk1lZGlhR3JvdXBQbGF5bGlzdHMob3JnYW5pemVkQXVkaW9Hcm91cCksIGZsYXR0ZW5NZWRpYUdyb3VwUGxheWxpc3RzKG9yZ2FuaXplZFZ0dEdyb3VwKSk7XG4gIGNvbnN0IHBsYXlsaXN0VGltZWxpbmVTdGFydHMgPSBmb3JtYXR0ZWRQbGF5bGlzdHMubWFwKCh7XG4gICAgdGltZWxpbmVTdGFydHNcbiAgfSkgPT4gdGltZWxpbmVTdGFydHMpO1xuICBtYW5pZmVzdC50aW1lbGluZVN0YXJ0cyA9IGdldFVuaXF1ZVRpbWVsaW5lU3RhcnRzKHBsYXlsaXN0VGltZWxpbmVTdGFydHMpO1xuICBhZGRNZWRpYVNlcXVlbmNlVmFsdWVzKGZvcm1hdHRlZFBsYXlsaXN0cywgbWFuaWZlc3QudGltZWxpbmVTdGFydHMpO1xuXG4gIGlmIChvcmdhbml6ZWRBdWRpb0dyb3VwKSB7XG4gICAgbWFuaWZlc3QubWVkaWFHcm91cHMuQVVESU8uYXVkaW8gPSBvcmdhbml6ZWRBdWRpb0dyb3VwO1xuICB9XG5cbiAgaWYgKG9yZ2FuaXplZFZ0dEdyb3VwKSB7XG4gICAgbWFuaWZlc3QubWVkaWFHcm91cHMuU1VCVElUTEVTLnN1YnMgPSBvcmdhbml6ZWRWdHRHcm91cDtcbiAgfVxuXG4gIGlmIChjYXB0aW9ucy5sZW5ndGgpIHtcbiAgICBtYW5pZmVzdC5tZWRpYUdyb3Vwc1snQ0xPU0VELUNBUFRJT05TJ10uY2MgPSBvcmdhbml6ZUNhcHRpb25TZXJ2aWNlcyhjYXB0aW9ucyk7XG4gIH1cblxuICBpZiAocHJldmlvdXNNYW5pZmVzdCkge1xuICAgIHJldHVybiBwb3NpdGlvbk1hbmlmZXN0T25UaW1lbGluZSh7XG4gICAgICBvbGRNYW5pZmVzdDogcHJldmlvdXNNYW5pZmVzdCxcbiAgICAgIG5ld01hbmlmZXN0OiBtYW5pZmVzdFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hbmlmZXN0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBSIChyZXBldGl0aW9uKSB2YWx1ZSBmb3IgYSBsaXZlIHN0cmVhbSAoZm9yIHRoZSBmaW5hbCBzZWdtZW50XG4gKiBpbiBhIG1hbmlmZXN0IHdoZXJlIHRoZSByIHZhbHVlIGlzIG5lZ2F0aXZlIDEpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogICAgICAgIGN1cnJlbnQgdGltZSAodHlwaWNhbGx5IHRoZSB0b3RhbCB0aW1lIHVwIHVudGlsIHRoZSBmaW5hbCBzZWdtZW50KVxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiAgICAgICAgZHVyYXRpb24gcHJvcGVydHkgZm9yIHRoZSBnaXZlbiA8UyAvPlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICBSIHZhbHVlIHRvIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHBlcmlvZFxuICovXG5jb25zdCBnZXRMaXZlUlZhbHVlID0gKGF0dHJpYnV0ZXMsIHRpbWUsIGR1cmF0aW9uKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBOT1csXG4gICAgY2xpZW50T2Zmc2V0LFxuICAgIGF2YWlsYWJpbGl0eVN0YXJ0VGltZSxcbiAgICB0aW1lc2NhbGUgPSAxLFxuICAgIHBlcmlvZFN0YXJ0ID0gMCxcbiAgICBtaW5pbXVtVXBkYXRlUGVyaW9kID0gMFxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3Qgbm93ID0gKE5PVyArIGNsaWVudE9mZnNldCkgLyAxMDAwO1xuICBjb25zdCBwZXJpb2RTdGFydFdDID0gYXZhaWxhYmlsaXR5U3RhcnRUaW1lICsgcGVyaW9kU3RhcnQ7XG4gIGNvbnN0IHBlcmlvZEVuZFdDID0gbm93ICsgbWluaW11bVVwZGF0ZVBlcmlvZDtcbiAgY29uc3QgcGVyaW9kRHVyYXRpb24gPSBwZXJpb2RFbmRXQyAtIHBlcmlvZFN0YXJ0V0M7XG4gIHJldHVybiBNYXRoLmNlaWwoKHBlcmlvZER1cmF0aW9uICogdGltZXNjYWxlIC0gdGltZSkgLyBkdXJhdGlvbik7XG59O1xuLyoqXG4gKiBVc2VzIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IFNlZ21lbnRUZW1wbGF0ZS5TZWdtZW50VGltZWxpbmUgdG8gZGV0ZXJtaW5lIHNlZ21lbnRcbiAqIHRpbWluZyBhbmQgZHVyYXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICAgICAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0W119IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgIExpc3Qgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBTIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpblxuICpcbiAqIEByZXR1cm4ge3tudW1iZXI6IG51bWJlciwgZHVyYXRpb246IG51bWJlciwgdGltZTogbnVtYmVyLCB0aW1lbGluZTogbnVtYmVyfVtdfVxuICogICAgICAgICBMaXN0IG9mIE9iamVjdHMgd2l0aCBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb1xuICovXG5cblxuY29uc3QgcGFyc2VCeVRpbWVsaW5lID0gKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSkgPT4ge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBtaW5pbXVtVXBkYXRlUGVyaW9kID0gMCxcbiAgICBtZWRpYSA9ICcnLFxuICAgIHNvdXJjZUR1cmF0aW9uLFxuICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgc3RhcnROdW1iZXIgPSAxLFxuICAgIHBlcmlvZFN0YXJ0OiB0aW1lbGluZVxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgbGV0IHRpbWUgPSAtMTtcblxuICBmb3IgKGxldCBzSW5kZXggPSAwOyBzSW5kZXggPCBzZWdtZW50VGltZWxpbmUubGVuZ3RoOyBzSW5kZXgrKykge1xuICAgIGNvbnN0IFMgPSBzZWdtZW50VGltZWxpbmVbc0luZGV4XTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IFMuZDtcbiAgICBjb25zdCByZXBlYXQgPSBTLnIgfHwgMDtcbiAgICBjb25zdCBzZWdtZW50VGltZSA9IFMudCB8fCAwO1xuXG4gICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICAvLyBmaXJzdCBzZWdtZW50XG4gICAgICB0aW1lID0gc2VnbWVudFRpbWU7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRUaW1lICYmIHNlZ21lbnRUaW1lID4gdGltZSkge1xuICAgICAgLy8gZGlzY29udGludWl0eVxuICAgICAgLy8gVE9ETzogSG93IHRvIGhhbmRsZSB0aGlzIHR5cGUgb2YgZGlzY29udGludWl0eVxuICAgICAgLy8gdGltZWxpbmUrKyBoZXJlIHdvdWxkIHRyZWF0IGl0IGxpa2UgSExTIGRpc2NvbnR1aXR5IGFuZCBjb250ZW50IHdvdWxkXG4gICAgICAvLyBnZXQgYXBwZW5kZWQgd2l0aG91dCBnYXBcbiAgICAgIC8vIEUuRy5cbiAgICAgIC8vICA8UyB0PVwiMFwiIGQ9XCIxXCIgLz5cbiAgICAgIC8vICA8UyBkPVwiMVwiIC8+XG4gICAgICAvLyAgPFMgZD1cIjFcIiAvPlxuICAgICAgLy8gIDxTIHQ9XCI1XCIgZD1cIjFcIiAvPlxuICAgICAgLy8gd291bGQgaGF2ZSAkVGltZSQgdmFsdWVzIG9mIFswLCAxLCAyLCA1XVxuICAgICAgLy8gc2hvdWxkIHRoaXMgYmUgYXBwZW5lZCBhdCB0aW1lIHBvc2l0aW9ucyBbMCwgMSwgMiwgM10sKCNFWFQtWC1ESVNDT05USU5VSVRZKVxuICAgICAgLy8gb3IgWzAsIDEsIDIsIGdhcCwgZ2FwLCA1XT8gKCNFWFQtWC1HQVApXG4gICAgICAvLyBkb2VzIHRoZSB2YWx1ZSBvZiBzb3VyY2VEdXJhdGlvbiBjb25zaWRlciB0aGlzIHdoZW4gY2FsY3VsYXRpbmcgYXJiaXRyYXJ5XG4gICAgICAvLyBuZWdhdGl2ZSBAciByZXBlYXQgdmFsdWU/XG4gICAgICAvLyBFLkcuIFNhbWUgZWxlbWVudHMgYXMgYWJvdmUgd2l0aCB0aGlzIGFkZGVkIGF0IHRoZSBlbmRcbiAgICAgIC8vICA8UyBkPVwiMVwiIHI9XCItMVwiIC8+XG4gICAgICAvLyAgd2l0aCBhIHNvdXJjZUR1cmF0aW9uIG9mIDEwXG4gICAgICAvLyBXb3VsZCB0aGUgMiBnYXBzIGJlIGluY2x1ZGVkIGluIHRoZSB0aW1lIGR1cmF0aW9uIGNhbGN1bGF0aW9ucyByZXN1bHRpbmcgaW5cbiAgICAgIC8vIDggc2VnbWVudHMgd2l0aCAkVGltZSQgdmFsdWVzIG9mIFswLCAxLCAyLCA1LCA2LCA3LCA4LCA5XSBvciAxMCBzZWdtZW50c1xuICAgICAgLy8gd2l0aCAkVGltZSQgdmFsdWVzIG9mIFswLCAxLCAyLCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdID9cbiAgICAgIHRpbWUgPSBzZWdtZW50VGltZTtcbiAgICB9XG5cbiAgICBsZXQgY291bnQ7XG5cbiAgICBpZiAocmVwZWF0IDwgMCkge1xuICAgICAgY29uc3QgbmV4dFMgPSBzSW5kZXggKyAxO1xuXG4gICAgICBpZiAobmV4dFMgPT09IHNlZ21lbnRUaW1lbGluZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGFzdCBzZWdtZW50XG4gICAgICAgIGlmICh0eXBlID09PSAnZHluYW1pYycgJiYgbWluaW11bVVwZGF0ZVBlcmlvZCA+IDAgJiYgbWVkaWEuaW5kZXhPZignJE51bWJlciQnKSA+IDApIHtcbiAgICAgICAgICBjb3VudCA9IGdldExpdmVSVmFsdWUoYXR0cmlidXRlcywgdGltZSwgZHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE86IFRoaXMgbWF5IGJlIGluY29ycmVjdCBkZXBlbmRpbmcgb24gY29uY2x1c2lvbiBvZiBUT0RPIGFib3ZlXG4gICAgICAgICAgY291bnQgPSAoc291cmNlRHVyYXRpb24gKiB0aW1lc2NhbGUgLSB0aW1lKSAvIGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCA9IChzZWdtZW50VGltZWxpbmVbbmV4dFNdLnQgLSB0aW1lKSAvIGR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHJlcGVhdCArIDE7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kID0gc3RhcnROdW1iZXIgKyBzZWdtZW50cy5sZW5ndGggKyBjb3VudDtcbiAgICBsZXQgbnVtYmVyID0gc3RhcnROdW1iZXIgKyBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobnVtYmVyIDwgZW5kKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIHRpbWVsaW5lXG4gICAgICB9KTtcbiAgICAgIHRpbWUgKz0gZHVyYXRpb247XG4gICAgICBudW1iZXIrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG5jb25zdCBpZGVudGlmaWVyUGF0dGVybiA9IC9cXCQoW0Etel0qKSg/OiglMCkoWzAtOV0rKWQpP1xcJC9nO1xuLyoqXG4gKiBSZXBsYWNlcyB0ZW1wbGF0ZSBpZGVudGlmaWVycyB3aXRoIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBUbyBiZSB1c2VkIGFzIHRoZSBjYWxsYmFja1xuICogZm9yIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICpcbiAqIEBuYW1lIHJlcGxhY2VDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hcbiAqICAgICAgICBFbnRpcmUgbWF0Y2ggb2YgaWRlbnRpZmllclxuICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXJcbiAqICAgICAgICBOYW1lIG9mIG1hdGNoZWQgaWRlbnRpZmllclxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFxuICogICAgICAgIEZvcm1hdCB0YWcgc3RyaW5nLiBJdHMgcHJlc2VuY2UgaW5kaWNhdGVzIHRoYXQgcGFkZGluZyBpcyBleHBlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoXG4gKiAgICAgICAgRGVzaXJlZCBsZW5ndGggb2YgdGhlIHJlcGxhY2VkIHZhbHVlLiBWYWx1ZXMgbGVzcyB0aGFuIHRoaXMgd2lkdGggc2hhbGwgYmUgbGVmdFxuICogICAgICAgIHplcm8gcGFkZGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFJlcGxhY2VtZW50IGZvciB0aGUgbWF0Y2hlZCBpZGVudGlmaWVyXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBhcyBhIGNhbGxiYWNrIGZvciBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UgdG8gcmVwbGFjZVxuICogdGVtcGxhdGUgaWRlbnRpZmllcnNcbiAqXG4gKiBAcGFyYW0ge09iZWN0fSB2YWx1ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyB2YWx1ZXMgdGhhdCBzaGFsbCBiZSB1c2VkIHRvIHJlcGxhY2Uga25vd24gaWRlbnRpZmllcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuUmVwcmVzZW50YXRpb25JRFxuICogICAgICAgIFZhbHVlIG9mIHRoZSBSZXByZXNlbnRhdGlvbkBpZCBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuTnVtYmVyXG4gKiAgICAgICAgTnVtYmVyIG9mIHRoZSBjb3JyZXNwb25kaW5nIHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuQmFuZHdpZHRoXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGJhbmR3aWR0aCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLlRpbWVcbiAqICAgICAgICBUaW1lc3RhbXAgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHJldHVybiB7cmVwbGFjZUNhbGxiYWNrfVxuICogICAgICAgICBDYWxsYmFjayB0byBiZSB1c2VkIHdpdGggU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIHRvIHJlcGxhY2UgaWRlbnRpZmllcnNcbiAqL1xuXG5jb25zdCBpZGVudGlmaWVyUmVwbGFjZW1lbnQgPSB2YWx1ZXMgPT4gKG1hdGNoLCBpZGVudGlmaWVyLCBmb3JtYXQsIHdpZHRoKSA9PiB7XG4gIGlmIChtYXRjaCA9PT0gJyQkJykge1xuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZVxuICAgIHJldHVybiAnJCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlc1tpZGVudGlmaWVyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9ICcnICsgdmFsdWVzW2lkZW50aWZpZXJdO1xuXG4gIGlmIChpZGVudGlmaWVyID09PSAnUmVwcmVzZW50YXRpb25JRCcpIHtcbiAgICAvLyBGb3JtYXQgdGFnIHNoYWxsIG5vdCBiZSBwcmVzZW50IHdpdGggUmVwcmVzZW50YXRpb25JRFxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICghZm9ybWF0KSB7XG4gICAgd2lkdGggPSAxO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gcGFyc2VJbnQod2lkdGgsIDEwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5sZW5ndGggPj0gd2lkdGgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYCR7bmV3IEFycmF5KHdpZHRoIC0gdmFsdWUubGVuZ3RoICsgMSkuam9pbignMCcpfSR7dmFsdWV9YDtcbn07XG4vKipcbiAqIENvbnN0cnVjdHMgYSBzZWdtZW50IHVybCBmcm9tIGEgdGVtcGxhdGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogICAgICAgIFRlbXBsYXRlIHN0cmluZyB0byBjb25zdHJ1Y3QgdXJsIGZyb21cbiAqIEBwYXJhbSB7T2JlY3R9IHZhbHVlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHZhbHVlcyB0aGF0IHNoYWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBrbm93biBpZGVudGlmaWVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5SZXByZXNlbnRhdGlvbklEXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGlkIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5OdW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5CYW5kd2lkdGhcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AYmFuZHdpZHRoIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuVGltZVxuICogICAgICAgIFRpbWVzdGFtcCB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFNlZ21lbnQgdXJsIHdpdGggaWRlbnRpZmllcnMgcmVwbGFjZWRcbiAqL1xuXG5jb25zdCBjb25zdHJ1Y3RUZW1wbGF0ZVVybCA9ICh1cmwsIHZhbHVlcykgPT4gdXJsLnJlcGxhY2UoaWRlbnRpZmllclBhdHRlcm4sIGlkZW50aWZpZXJSZXBsYWNlbWVudCh2YWx1ZXMpKTtcbi8qKlxuICogR2VuZXJhdGVzIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvcm1hdGlvbiBhYm91dCBlYWNoXG4gKiBzZWdtZW50IG5lZWRlZCB0byBnZW5lcmF0ZSBzZWdtZW50IHVyaXMgYW5kIHRoZSBjb21wbGV0ZSBzZWdtZW50IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgICAgICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgIExpc3Qgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBTIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpblxuICogICAgICAgIHRoZSBTZWdtZW50VGltZWxpbmUgZWxlbWVudFxuICogQHJldHVybiB7e251bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHRpbWVsaW5lOiBudW1iZXJ9W119XG4gKiAgICAgICAgIExpc3Qgb2YgT2JqZWN0cyB3aXRoIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvXG4gKi9cblxuY29uc3QgcGFyc2VUZW1wbGF0ZUluZm8gPSAoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSA9PiB7XG4gIGlmICghYXR0cmlidXRlcy5kdXJhdGlvbiAmJiAhc2VnbWVudFRpbWVsaW5lKSB7XG4gICAgLy8gaWYgbmVpdGhlciBAZHVyYXRpb24gb3IgU2VnbWVudFRpbWVsaW5lIGFyZSBwcmVzZW50LCB0aGVuIHRoZXJlIHNoYWxsIGJlIGV4YWN0bHlcbiAgICAvLyBvbmUgbWVkaWEgc2VnbWVudFxuICAgIHJldHVybiBbe1xuICAgICAgbnVtYmVyOiBhdHRyaWJ1dGVzLnN0YXJ0TnVtYmVyIHx8IDEsXG4gICAgICBkdXJhdGlvbjogYXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbixcbiAgICAgIHRpbWU6IDAsXG4gICAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydFxuICAgIH1dO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuZHVyYXRpb24pIHtcbiAgICByZXR1cm4gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQnlUaW1lbGluZShhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgbGlzdCBvZiBzZWdtZW50cyB1c2luZyBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSB0aGUgU2VnbWVudFRlbXBsYXRlIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICAgICAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0W118dW5kZWZpbmVkfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqICAgICAgICB0aGUgU2VnbWVudFRpbWVsaW5lIGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICogICAgICAgICBMaXN0IG9mIHNlZ21lbnQgb2JqZWN0c1xuICovXG5cbmNvbnN0IHNlZ21lbnRzRnJvbVRlbXBsYXRlID0gKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSkgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZVZhbHVlcyA9IHtcbiAgICBSZXByZXNlbnRhdGlvbklEOiBhdHRyaWJ1dGVzLmlkLFxuICAgIEJhbmR3aWR0aDogYXR0cmlidXRlcy5iYW5kd2lkdGggfHwgMFxuICB9O1xuICBjb25zdCB7XG4gICAgaW5pdGlhbGl6YXRpb24gPSB7XG4gICAgICBzb3VyY2VVUkw6ICcnLFxuICAgICAgcmFuZ2U6ICcnXG4gICAgfVxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgbWFwU2VnbWVudCA9IHVybFR5cGVUb1NlZ21lbnQoe1xuICAgIGJhc2VVcmw6IGF0dHJpYnV0ZXMuYmFzZVVybCxcbiAgICBzb3VyY2U6IGNvbnN0cnVjdFRlbXBsYXRlVXJsKGluaXRpYWxpemF0aW9uLnNvdXJjZVVSTCwgdGVtcGxhdGVWYWx1ZXMpLFxuICAgIHJhbmdlOiBpbml0aWFsaXphdGlvbi5yYW5nZVxuICB9KTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXJzZVRlbXBsYXRlSW5mbyhhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xuICByZXR1cm4gc2VnbWVudHMubWFwKHNlZ21lbnQgPT4ge1xuICAgIHRlbXBsYXRlVmFsdWVzLk51bWJlciA9IHNlZ21lbnQubnVtYmVyO1xuICAgIHRlbXBsYXRlVmFsdWVzLlRpbWUgPSBzZWdtZW50LnRpbWU7XG4gICAgY29uc3QgdXJpID0gY29uc3RydWN0VGVtcGxhdGVVcmwoYXR0cmlidXRlcy5tZWRpYSB8fCAnJywgdGVtcGxhdGVWYWx1ZXMpOyAvLyBTZWUgREFTSCBzcGVjIHNlY3Rpb24gNS4zLjkuMi4yXG4gICAgLy8gLSBpZiB0aW1lc2NhbGUgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMS5cblxuICAgIGNvbnN0IHRpbWVzY2FsZSA9IGF0dHJpYnV0ZXMudGltZXNjYWxlIHx8IDE7IC8vIC0gaWYgcHJlc2VudGF0aW9uVGltZU9mZnNldCBpc24ndCBwcmVzZW50IG9uIGFueSBsZXZlbCwgZGVmYXVsdCB0byAwXG5cbiAgICBjb25zdCBwcmVzZW50YXRpb25UaW1lT2Zmc2V0ID0gYXR0cmlidXRlcy5wcmVzZW50YXRpb25UaW1lT2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgcHJlc2VudGF0aW9uVGltZSA9IC8vIEV2ZW4gaWYgdGhlIEB0IGF0dHJpYnV0ZSBpcyBub3Qgc3BlY2lmaWVkIGZvciB0aGUgc2VnbWVudCwgc2VnbWVudC50aW1lIGlzXG4gICAgLy8gY2FsY3VsYXRlZCBpbiBtcGQtcGFyc2VyIHByaW9yIHRvIHRoaXMsIHNvIGl0J3MgYXNzdW1lZCB0byBiZSBhdmFpbGFibGUuXG4gICAgYXR0cmlidXRlcy5wZXJpb2RTdGFydCArIChzZWdtZW50LnRpbWUgLSBwcmVzZW50YXRpb25UaW1lT2Zmc2V0KSAvIHRpbWVzY2FsZTtcbiAgICBjb25zdCBtYXAgPSB7XG4gICAgICB1cmksXG4gICAgICB0aW1lbGluZTogc2VnbWVudC50aW1lbGluZSxcbiAgICAgIGR1cmF0aW9uOiBzZWdtZW50LmR1cmF0aW9uLFxuICAgICAgcmVzb2x2ZWRVcmk6IHJlc29sdmVVcmwoYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLCB1cmkpLFxuICAgICAgbWFwOiBtYXBTZWdtZW50LFxuICAgICAgbnVtYmVyOiBzZWdtZW50Lm51bWJlcixcbiAgICAgIHByZXNlbnRhdGlvblRpbWVcbiAgICB9O1xuICAgIHJldHVybiBtYXA7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIDxTZWdtZW50VXJsPiAob2YgdHlwZSBVUkxUeXBlIGZyb20gdGhlIERBU0ggc3BlYyA1LjMuOS4yIFRhYmxlIDE0KVxuICogdG8gYW4gb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgb3V0cHV0IG9mIGEgc2VnbWVudCBpbiB2aWRlb2pzL21wZC1wYXJzZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRVcmxcbiAqICAgPFNlZ21lbnRVUkw+IG5vZGUgdG8gdHJhbnNsYXRlIGludG8gYSBzZWdtZW50IG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSB0cmFuc2xhdGVkIHNlZ21lbnQgb2JqZWN0XG4gKi9cblxuY29uc3QgU2VnbWVudFVSTFRvU2VnbWVudE9iamVjdCA9IChhdHRyaWJ1dGVzLCBzZWdtZW50VXJsKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsLFxuICAgIGluaXRpYWxpemF0aW9uID0ge31cbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IGluaXRTZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybCxcbiAgICBzb3VyY2U6IGluaXRpYWxpemF0aW9uLnNvdXJjZVVSTCxcbiAgICByYW5nZTogaW5pdGlhbGl6YXRpb24ucmFuZ2VcbiAgfSk7XG4gIGNvbnN0IHNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsLFxuICAgIHNvdXJjZTogc2VnbWVudFVybC5tZWRpYSxcbiAgICByYW5nZTogc2VnbWVudFVybC5tZWRpYVJhbmdlXG4gIH0pO1xuICBzZWdtZW50Lm1hcCA9IGluaXRTZWdtZW50O1xuICByZXR1cm4gc2VnbWVudDtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygc2VnbWVudHMgdXNpbmcgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgdGhlIFNlZ21lbnRMaXN0IGVsZW1lbnRcbiAqIFNlZ21lbnRMaXN0IChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKiAgICAgICAgdGhlIFNlZ21lbnRUaW1lbGluZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG5cblxuY29uc3Qgc2VnbWVudHNGcm9tTGlzdCA9IChhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpID0+IHtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uLFxuICAgIHNlZ21lbnRVcmxzID0gW10sXG4gICAgcGVyaW9kU3RhcnRcbiAgfSA9IGF0dHJpYnV0ZXM7IC8vIFBlciBzcGVjICg1LjMuOS4yLjEpIG5vIHdheSB0byBkZXRlcm1pbmUgc2VnbWVudCBkdXJhdGlvbiBPUlxuICAvLyBpZiBib3RoIFNlZ21lbnRUaW1lbGluZSBhbmQgQGR1cmF0aW9uIGFyZSBkZWZpbmVkLCBpdCBpcyBvdXRzaWRlIG9mIHNwZWMuXG5cbiAgaWYgKCFkdXJhdGlvbiAmJiAhc2VnbWVudFRpbWVsaW5lIHx8IGR1cmF0aW9uICYmIHNlZ21lbnRUaW1lbGluZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEKTtcbiAgfVxuXG4gIGNvbnN0IHNlZ21lbnRVcmxNYXAgPSBzZWdtZW50VXJscy5tYXAoc2VnbWVudFVybE9iamVjdCA9PiBTZWdtZW50VVJMVG9TZWdtZW50T2JqZWN0KGF0dHJpYnV0ZXMsIHNlZ21lbnRVcmxPYmplY3QpKTtcbiAgbGV0IHNlZ21lbnRUaW1lSW5mbztcblxuICBpZiAoZHVyYXRpb24pIHtcbiAgICBzZWdtZW50VGltZUluZm8gPSBwYXJzZUJ5RHVyYXRpb24oYXR0cmlidXRlcyk7XG4gIH1cblxuICBpZiAoc2VnbWVudFRpbWVsaW5lKSB7XG4gICAgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeVRpbWVsaW5lKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50cyA9IHNlZ21lbnRUaW1lSW5mby5tYXAoKHNlZ21lbnRUaW1lLCBpbmRleCkgPT4ge1xuICAgIGlmIChzZWdtZW50VXJsTWFwW2luZGV4XSkge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRVcmxNYXBbaW5kZXhdOyAvLyBTZWUgREFTSCBzcGVjIHNlY3Rpb24gNS4zLjkuMi4yXG4gICAgICAvLyAtIGlmIHRpbWVzY2FsZSBpc24ndCBwcmVzZW50IG9uIGFueSBsZXZlbCwgZGVmYXVsdCB0byAxLlxuXG4gICAgICBjb25zdCB0aW1lc2NhbGUgPSBhdHRyaWJ1dGVzLnRpbWVzY2FsZSB8fCAxOyAvLyAtIGlmIHByZXNlbnRhdGlvblRpbWVPZmZzZXQgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMFxuXG4gICAgICBjb25zdCBwcmVzZW50YXRpb25UaW1lT2Zmc2V0ID0gYXR0cmlidXRlcy5wcmVzZW50YXRpb25UaW1lT2Zmc2V0IHx8IDA7XG4gICAgICBzZWdtZW50LnRpbWVsaW5lID0gc2VnbWVudFRpbWUudGltZWxpbmU7XG4gICAgICBzZWdtZW50LmR1cmF0aW9uID0gc2VnbWVudFRpbWUuZHVyYXRpb247XG4gICAgICBzZWdtZW50Lm51bWJlciA9IHNlZ21lbnRUaW1lLm51bWJlcjtcbiAgICAgIHNlZ21lbnQucHJlc2VudGF0aW9uVGltZSA9IHBlcmlvZFN0YXJ0ICsgKHNlZ21lbnRUaW1lLnRpbWUgLSBwcmVzZW50YXRpb25UaW1lT2Zmc2V0KSAvIHRpbWVzY2FsZTtcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH0gLy8gU2luY2Ugd2UncmUgbWFwcGluZyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiBhbnkgYmxhbmsgc2VnbWVudHMgKGluIGNhc2VcbiAgICAvLyB0aGUgZ2l2ZW4gU2VnbWVudFRpbWVsaW5lIGlzIGhhbmRsaW5nIGZvciBtb3JlIGVsZW1lbnRzIHRoYW4gd2UgaGF2ZVxuICAgIC8vIFNlZ21lbnRVUkxzIGZvcikuXG5cbiAgfSkuZmlsdGVyKHNlZ21lbnQgPT4gc2VnbWVudCk7XG4gIHJldHVybiBzZWdtZW50cztcbn07XG5cbmNvbnN0IGdlbmVyYXRlU2VnbWVudHMgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBzZWdtZW50SW5mb1xufSkgPT4ge1xuICBsZXQgc2VnbWVudEF0dHJpYnV0ZXM7XG4gIGxldCBzZWdtZW50c0ZuO1xuXG4gIGlmIChzZWdtZW50SW5mby50ZW1wbGF0ZSkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21UZW1wbGF0ZTtcbiAgICBzZWdtZW50QXR0cmlidXRlcyA9IG1lcmdlKGF0dHJpYnV0ZXMsIHNlZ21lbnRJbmZvLnRlbXBsYXRlKTtcbiAgfSBlbHNlIGlmIChzZWdtZW50SW5mby5iYXNlKSB7XG4gICAgc2VnbWVudHNGbiA9IHNlZ21lbnRzRnJvbUJhc2U7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby5iYXNlKTtcbiAgfSBlbHNlIGlmIChzZWdtZW50SW5mby5saXN0KSB7XG4gICAgc2VnbWVudHNGbiA9IHNlZ21lbnRzRnJvbUxpc3Q7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby5saXN0KTtcbiAgfVxuXG4gIGNvbnN0IHNlZ21lbnRzSW5mbyA9IHtcbiAgICBhdHRyaWJ1dGVzXG4gIH07XG5cbiAgaWYgKCFzZWdtZW50c0ZuKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzSW5mbztcbiAgfVxuXG4gIGNvbnN0IHNlZ21lbnRzID0gc2VnbWVudHNGbihzZWdtZW50QXR0cmlidXRlcywgc2VnbWVudEluZm8uc2VnbWVudFRpbWVsaW5lKTsgLy8gVGhlIEBkdXJhdGlvbiBhdHRyaWJ1dGUgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluIHRoZSBwbGF5bGlzdCdzIHRhcmdldER1cmF0aW9uIHdoaWNoXG4gIC8vIG11c3QgYmUgaW4gc2Vjb25kcy4gU2luY2Ugd2UndmUgZ2VuZXJhdGVkIHRoZSBzZWdtZW50IGxpc3QsIHdlIG5vIGxvbmdlciBuZWVkXG4gIC8vIEBkdXJhdGlvbiB0byBiZSBpbiBAdGltZXNjYWxlIHVuaXRzLCBzbyB3ZSBjYW4gY29udmVydCBpdCBoZXJlLlxuXG4gIGlmIChzZWdtZW50QXR0cmlidXRlcy5kdXJhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltZXNjYWxlID0gMVxuICAgIH0gPSBzZWdtZW50QXR0cmlidXRlcztcbiAgICBzZWdtZW50QXR0cmlidXRlcy5kdXJhdGlvbiA9IGR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICB9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIEBkdXJhdGlvbiBhdHRyaWJ1dGUsIHVzZSB0aGUgbGFyZ2VzdCBzZWdtZW50IGR1cmF0aW9uIGFzXG4gICAgLy8gYXMgdGFyZ2V0IGR1cmF0aW9uXG4gICAgc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24gPSBzZWdtZW50cy5yZWR1Y2UoKG1heCwgc2VnbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgTWF0aC5jZWlsKHNlZ21lbnQuZHVyYXRpb24pKTtcbiAgICB9LCAwKTtcbiAgfSBlbHNlIHtcbiAgICBzZWdtZW50QXR0cmlidXRlcy5kdXJhdGlvbiA9IDA7XG4gIH1cblxuICBzZWdtZW50c0luZm8uYXR0cmlidXRlcyA9IHNlZ21lbnRBdHRyaWJ1dGVzO1xuICBzZWdtZW50c0luZm8uc2VnbWVudHMgPSBzZWdtZW50czsgLy8gVGhpcyBpcyBhIHNpZHggYm94IHdpdGhvdXQgYWN0dWFsIHNlZ21lbnQgaW5mb3JtYXRpb25cblxuICBpZiAoc2VnbWVudEluZm8uYmFzZSAmJiBzZWdtZW50QXR0cmlidXRlcy5pbmRleFJhbmdlKSB7XG4gICAgc2VnbWVudHNJbmZvLnNpZHggPSBzZWdtZW50c1swXTtcbiAgICBzZWdtZW50c0luZm8uc2VnbWVudHMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c0luZm87XG59O1xuY29uc3QgdG9QbGF5bGlzdHMgPSByZXByZXNlbnRhdGlvbnMgPT4gcmVwcmVzZW50YXRpb25zLm1hcChnZW5lcmF0ZVNlZ21lbnRzKTtcblxuY29uc3QgZmluZENoaWxkcmVuID0gKGVsZW1lbnQsIG5hbWUpID0+IGZyb20oZWxlbWVudC5jaGlsZE5vZGVzKS5maWx0ZXIoKHtcbiAgdGFnTmFtZVxufSkgPT4gdGFnTmFtZSA9PT0gbmFtZSk7XG5jb25zdCBnZXRDb250ZW50ID0gZWxlbWVudCA9PiBlbGVtZW50LnRleHRDb250ZW50LnRyaW0oKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBkaXZpc2lvbiBvcGVyYXRpb24gdG8gYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHByb3ZpZGVkIHN0cmluZyB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHBhcnNlZCBzdHJpbmcgdmFsdWVcbiAqL1xuY29uc3QgcGFyc2VEaXZpc2lvblZhbHVlID0gdmFsdWUgPT4ge1xuICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5zcGxpdCgnLycpLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4gcHJldiAvIGN1cnJlbnQpKTtcbn07XG5cbmNvbnN0IHBhcnNlRHVyYXRpb24gPSBzdHIgPT4ge1xuICBjb25zdCBTRUNPTkRTX0lOX1lFQVIgPSAzNjUgKiAyNCAqIDYwICogNjA7XG4gIGNvbnN0IFNFQ09ORFNfSU5fTU9OVEggPSAzMCAqIDI0ICogNjAgKiA2MDtcbiAgY29uc3QgU0VDT05EU19JTl9EQVkgPSAyNCAqIDYwICogNjA7XG4gIGNvbnN0IFNFQ09ORFNfSU5fSE9VUiA9IDYwICogNjA7XG4gIGNvbnN0IFNFQ09ORFNfSU5fTUlOID0gNjA7IC8vIFAxMFkxME0xMERUMTBIMTBNMTAuMVNcblxuICBjb25zdCBkdXJhdGlvblJlZ2V4ID0gL1AoPzooXFxkKilZKT8oPzooXFxkKilNKT8oPzooXFxkKilEKT8oPzpUKD86KFxcZCopSCk/KD86KFxcZCopTSk/KD86KFtcXGQuXSopUyk/KT8vO1xuICBjb25zdCBtYXRjaCA9IGR1cmF0aW9uUmVnZXguZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBtYXRjaC5zbGljZSgxKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoeWVhciB8fCAwKSAqIFNFQ09ORFNfSU5fWUVBUiArIHBhcnNlRmxvYXQobW9udGggfHwgMCkgKiBTRUNPTkRTX0lOX01PTlRIICsgcGFyc2VGbG9hdChkYXkgfHwgMCkgKiBTRUNPTkRTX0lOX0RBWSArIHBhcnNlRmxvYXQoaG91ciB8fCAwKSAqIFNFQ09ORFNfSU5fSE9VUiArIHBhcnNlRmxvYXQobWludXRlIHx8IDApICogU0VDT05EU19JTl9NSU4gKyBwYXJzZUZsb2F0KHNlY29uZCB8fCAwKTtcbn07XG5jb25zdCBwYXJzZURhdGUgPSBzdHIgPT4ge1xuICAvLyBEYXRlIGZvcm1hdCB3aXRob3V0IHRpbWV6b25lIGFjY29yZGluZyB0byBJU08gODYwMVxuICAvLyBZWVktTU0tRERUaGg6bW06c3Muc3Nzc3NzXG4gIGNvbnN0IGRhdGVSZWdleCA9IC9eXFxkKy1cXGQrLVxcZCtUXFxkKzpcXGQrOlxcZCsoXFwuXFxkKyk/JC87IC8vIElmIHRoZSBkYXRlIHN0cmluZyBkb2VzIG5vdCBzcGVjaWZpeSBhIHRpbWV6b25lLCB3ZSBtdXN0IHNwZWNpZml5IFVUQy4gVGhpcyBpc1xuICAvLyBleHByZXNzZWQgYnkgZW5kaW5nIHdpdGggJ1onXG5cbiAgaWYgKGRhdGVSZWdleC50ZXN0KHN0cikpIHtcbiAgICBzdHIgKz0gJ1onO1xuICB9XG5cbiAgcmV0dXJuIERhdGUucGFyc2Uoc3RyKTtcbn07XG5cbmNvbnN0IHBhcnNlcnMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBlbnRpcmUgTWVkaWEgUHJlc2VudGF0aW9uLiBGb3JtYXQgaXMgYSBkdXJhdGlvbiBzdHJpbmdcbiAgICogYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgbWVkaWFQcmVzZW50YXRpb25EdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBTZWdtZW50IGF2YWlsYWJpbGl0eSBzdGFydCB0aW1lIGZvciBhbGwgU2VnbWVudHMgcmVmZXJyZWQgdG8gaW4gdGhpc1xuICAgKiBNUEQuIEZvciBhIGR5bmFtaWMgbWFuaWZlc3QsIGl0IHNwZWNpZmllcyB0aGUgYW5jaG9yIGZvciB0aGUgZWFybGllc3QgYXZhaWxhYmlsaXR5XG4gICAqIHRpbWUuIEZvcm1hdCBpcyBhIGRhdGUgc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRhdGUgYXMgc2Vjb25kcyBmcm9tIHVuaXggZXBvY2hcbiAgICovXG4gIGF2YWlsYWJpbGl0eVN0YXJ0VGltZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZURhdGUodmFsdWUpIC8gMTAwMDtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBzbWFsbGVzdCBwZXJpb2QgYmV0d2VlbiBwb3RlbnRpYWwgY2hhbmdlcyB0byB0aGUgTVBELiBGb3JtYXQgaXMgYVxuICAgKiBkdXJhdGlvbiBzdHJpbmcgYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgbWluaW11bVVwZGF0ZVBlcmlvZCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBzdWdnZXN0ZWQgcHJlc2VudGF0aW9uIGRlbGF5LiBGb3JtYXQgaXMgYVxuICAgKiBkdXJhdGlvbiBzdHJpbmcgYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXkodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNwZWNpZmljZXMgdGhlIHR5cGUgb2YgbXBkLiBDYW4gYmUgZWl0aGVyIFwic3RhdGljXCIgb3IgXCJkeW5hbWljXCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB0eXBlIGFzIGEgc3RyaW5nXG4gICAqL1xuICB0eXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBzbWFsbGVzdCB0aW1lIHNoaWZ0aW5nIGJ1ZmZlciBmb3IgYW55IFJlcHJlc2VudGF0aW9uXG4gICAqIGluIHRoZSBNUEQuIEZvcm1hdCBpcyBhIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICB0aW1lU2hpZnRCdWZmZXJEZXB0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBQZXJpb2RTdGFydCB0aW1lIG9mIHRoZSBQZXJpb2QgcmVsYXRpdmUgdG8gdGhlIGF2YWlsYWJpbGl0eVN0YXJ0dGltZS5cbiAgICogRm9ybWF0IGlzIGEgZHVyYXRpb24gc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIHN0YXJ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHdpZHRoIG9mIHRoZSB2aXN1YWwgcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIHdpZHRoXG4gICAqL1xuICB3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGhlaWdodCBvZiB0aGUgdmlzdWFsIHByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBoZWlnaHRcbiAgICovXG4gIGhlaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGJpdHJhdGUgb2YgdGhlIHJlcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGJhbmR3aWR0aFxuICAgKi9cbiAgYmFuZHdpZHRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZnJhbWUgcmF0ZSBvZiB0aGUgcmVwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgZnJhbWUgcmF0ZVxuICAgKi9cbiAgZnJhbWVSYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRGl2aXNpb25WYWx1ZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRoZSBmaXJzdCBNZWRpYSBTZWdtZW50IGluIHRoaXMgUmVwcmVzZW50YXRpb24gaW4gdGhlIFBlcmlvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBudW1iZXJcbiAgICovXG4gIHN0YXJ0TnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgdGltZXNjYWxlIGluIHVuaXRzIHBlciBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIHRpbWVzY2FsZVxuICAgKi9cbiAgdGltZXNjYWxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgcHJlc2VudGF0aW9uVGltZU9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIHByZXNlbnRhdGlvblRpbWVPZmZzZXRcbiAgICovXG4gIHByZXNlbnRhdGlvblRpbWVPZmZzZXQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBjb25zdGFudCBhcHByb3hpbWF0ZSBTZWdtZW50IGR1cmF0aW9uXG4gICAqIE5PVEU6IFRoZSA8UGVyaW9kPiBlbGVtZW50IGFsc28gY29udGFpbnMgYW4gQGR1cmF0aW9uIGF0dHJpYnV0ZS4gVGhpcyBkdXJhdGlvblxuICAgKiAgICAgICBzcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBQZXJpb2QuIFRoaXMgYXR0cmlidXRlIGlzIGN1cnJlbnRseSBub3RcbiAgICogICAgICAgc3VwcG9ydGVkIGJ5IHRoZSByZXN0IG9mIHRoZSBwYXJzZXIsIGhvd2V2ZXIgd2Ugc3RpbGwgY2hlY2sgZm9yIGl0IHRvIHByZXZlbnRcbiAgICogICAgICAgZXJyb3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBkdXJhdGlvblxuICAgKi9cbiAgZHVyYXRpb24odmFsdWUpIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgICBpZiAoaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIFNlZ21lbnQgZHVyYXRpb24sIGluIHVuaXRzIG9mIHRoZSB2YWx1ZSBvZiB0aGUgQHRpbWVzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgZHVyYXRpb25cbiAgICovXG4gIGQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBNUEQgc3RhcnQgdGltZSwgaW4gQHRpbWVzY2FsZSB1bml0cywgdGhlIGZpcnN0IFNlZ21lbnQgaW4gdGhlIHNlcmllc1xuICAgKiBzdGFydHMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgUGVyaW9kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIHRpbWVcbiAgICovXG4gIHQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSByZXBlYXQgY291bnQgb2YgdGhlIG51bWJlciBvZiBmb2xsb3dpbmcgY29udGlndW91cyBTZWdtZW50cyB3aXRoIHRoZVxuICAgKiBzYW1lIGR1cmF0aW9uIGV4cHJlc3NlZCBieSB0aGUgdmFsdWUgb2YgQGRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgbnVtYmVyXG4gICAqL1xuICByKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgcHJlc2VudGF0aW9uVGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIHByZXNlbnRhdGlvblRpbWVcbiAgICovXG4gIHByZXNlbnRhdGlvblRpbWUodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBwYXJzZXIgZm9yIGFsbCBvdGhlciBhdHRyaWJ1dGVzLiBBY3RzIGFzIGEgbm8tb3AgYW5kIGp1c3QgcmV0dXJucyB0aGUgdmFsdWVcbiAgICogYXMgYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFVucGFyc2VkIHZhbHVlXG4gICAqL1xuICBERUZBVUxUKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbn07XG4vKipcbiAqIEdldHMgYWxsIHRoZSBhdHRyaWJ1dGVzIGFuZCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIG5vZGUsIHBhcnNlcyBhdHRyaWJ1dGVzIHdpdGgga25vd25cbiAqIHR5cGVzLCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGUgbmFtZXMgbWFwcGVkIHRvIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGVsXG4gKiAgICAgICAgVGhlIG5vZGUgdG8gcGFyc2UgYXR0cmlidXRlcyBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIE9iamVjdCB3aXRoIGFsbCBhdHRyaWJ1dGVzIG9mIGVsIHBhcnNlZFxuICovXG5cbmNvbnN0IHBhcnNlQXR0cmlidXRlcyA9IGVsID0+IHtcbiAgaWYgKCEoZWwgJiYgZWwuYXR0cmlidXRlcykpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZXR1cm4gZnJvbShlbC5hdHRyaWJ1dGVzKS5yZWR1Y2UoKGEsIGUpID0+IHtcbiAgICBjb25zdCBwYXJzZUZuID0gcGFyc2Vyc1tlLm5hbWVdIHx8IHBhcnNlcnMuREVGQVVMVDtcbiAgICBhW2UubmFtZV0gPSBwYXJzZUZuKGUudmFsdWUpO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59O1xuXG5jb25zdCBrZXlTeXN0ZW1zTWFwID0ge1xuICAndXJuOnV1aWQ6MTA3N2VmZWMtYzBiMi00ZDAyLWFjZTMtM2MxZTUyZTJmYjRiJzogJ29yZy53My5jbGVhcmtleScsXG4gICd1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWQnOiAnY29tLndpZGV2aW5lLmFscGhhJyxcbiAgJ3Vybjp1dWlkOjlhMDRmMDc5LTk4NDAtNDI4Ni1hYjkyLWU2NWJlMDg4NWY5NSc6ICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeScsXG4gICd1cm46dXVpZDpmMjM5ZTc2OS1lZmEzLTQ4NTAtOWMxNi1hOTAzYzY5MzJlZmInOiAnY29tLmFkb2JlLnByaW1ldGltZScsXG4gIC8vIElTT19JRUMgMjMwMDktMV8yMDIyIDUuOC41LjIuMiBUaGUgbXA0IFByb3RlY3Rpb24gU2NoZW1lXG4gICd1cm46bXBlZzpkYXNoOm1wNHByb3RlY3Rpb246MjAxMSc6ICdtcDRwcm90ZWN0aW9uJ1xufTtcbi8qKlxuICogQnVpbGRzIGEgbGlzdCBvZiB1cmxzIHRoYXQgaXMgdGhlIHByb2R1Y3Qgb2YgdGhlIHJlZmVyZW5jZSB1cmxzIGFuZCBCYXNlVVJMIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IHJlZmVyZW5jZXNcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgcmVmZXJlbmNlIFVSTCBhcyB3ZWxsIGFzIGl0cyBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge05vZGVbXX0gYmFzZVVybEVsZW1lbnRzXG4gKiAgICAgICAgTGlzdCBvZiBCYXNlVVJMIG5vZGVzIGZyb20gdGhlIG1wZFxuICogQHJldHVybiB7T2JqZWN0W119XG4gKiAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyB3aXRoIHJlc29sdmVkIHVybHMgYW5kIGF0dHJpYnV0ZXNcbiAqL1xuXG5jb25zdCBidWlsZEJhc2VVcmxzID0gKHJlZmVyZW5jZXMsIGJhc2VVcmxFbGVtZW50cykgPT4ge1xuICBpZiAoIWJhc2VVcmxFbGVtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgfVxuXG4gIHJldHVybiBmbGF0dGVuKHJlZmVyZW5jZXMubWFwKGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gYmFzZVVybEVsZW1lbnRzLm1hcChmdW5jdGlvbiAoYmFzZVVybEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxCYXNlVXJsID0gZ2V0Q29udGVudChiYXNlVXJsRWxlbWVudCk7XG4gICAgICBjb25zdCByZXNvbHZlZEJhc2VVcmwgPSByZXNvbHZlVXJsKHJlZmVyZW5jZS5iYXNlVXJsLCBpbml0aWFsQmFzZVVybCk7XG4gICAgICBjb25zdCBmaW5hbEJhc2VVcmwgPSBtZXJnZShwYXJzZUF0dHJpYnV0ZXMoYmFzZVVybEVsZW1lbnQpLCB7XG4gICAgICAgIGJhc2VVcmw6IHJlc29sdmVkQmFzZVVybFxuICAgICAgfSk7IC8vIElmIHRoZSBVUkwgaXMgcmVzb2x2ZWQsIHdlIHdhbnQgdG8gZ2V0IHRoZSBzZXJ2aWNlTG9jYXRpb24gZnJvbSB0aGUgcmVmZXJlbmNlXG4gICAgICAvLyBhc3N1bWluZyB0aGVyZSBpcyBubyBzZXJ2aWNlTG9jYXRpb24gb24gdGhlIGluaXRpYWxCYXNlVXJsXG5cbiAgICAgIGlmIChyZXNvbHZlZEJhc2VVcmwgIT09IGluaXRpYWxCYXNlVXJsICYmICFmaW5hbEJhc2VVcmwuc2VydmljZUxvY2F0aW9uICYmIHJlZmVyZW5jZS5zZXJ2aWNlTG9jYXRpb24pIHtcbiAgICAgICAgZmluYWxCYXNlVXJsLnNlcnZpY2VMb2NhdGlvbiA9IHJlZmVyZW5jZS5zZXJ2aWNlTG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5hbEJhc2VVcmw7XG4gICAgfSk7XG4gIH0pKTtcbn07XG4vKipcbiAqIENvbnRhaW5zIGFsbCBTZWdtZW50IGluZm9ybWF0aW9uIGZvciBpdHMgY29udGFpbmluZyBBZGFwdGF0aW9uU2V0XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudEluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge09iamVjdHx1bmRlZmluZWR9IHRlbXBsYXRlXG4gKiAgICAgICAgICAgQ29udGFpbnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBTZWdtZW50VGVtcGxhdGUgbm9kZVxuICogQHByb3BlcnR5IHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgICAgIENvbnRhaW5zIGEgbGlzdCBvZiBhdHJyaWJ1dGVzIGZvciBlYWNoIFMgbm9kZSB3aXRoaW4gdGhlIFNlZ21lbnRUaW1lbGluZSBub2RlXG4gKiBAcHJvcGVydHkge09iamVjdHx1bmRlZmluZWR9IGxpc3RcbiAqICAgICAgICAgICBDb250YWlucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIFNlZ21lbnRMaXN0IG5vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fHVuZGVmaW5lZH0gYmFzZVxuICogICAgICAgICAgIENvbnRhaW5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgU2VnbWVudEJhc2Ugbm9kZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIFNlZ21lbnQgaW5mb3JtYXRpb24gY29udGFpbmVkIHdpdGhpbiB0aGUgQWRhcHRhdGlvblNldCBub2RlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBhZGFwdGF0aW9uU2V0XG4gKiAgICAgICAgVGhlIEFkYXB0YXRpb25TZXQgbm9kZSB0byBnZXQgU2VnbWVudCBpbmZvcm1hdGlvbiBmcm9tXG4gKiBAcmV0dXJuIHtTZWdtZW50SW5mb3JtYXRpb259XG4gKiAgICAgICAgIFRoZSBTZWdtZW50IGluZm9ybWF0aW9uIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIEFkYXB0YXRpb25TZXRcbiAqL1xuXG5jb25zdCBnZXRTZWdtZW50SW5mb3JtYXRpb24gPSBhZGFwdGF0aW9uU2V0ID0+IHtcbiAgY29uc3Qgc2VnbWVudFRlbXBsYXRlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdTZWdtZW50VGVtcGxhdGUnKVswXTtcbiAgY29uc3Qgc2VnbWVudExpc3QgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1NlZ21lbnRMaXN0JylbMF07XG4gIGNvbnN0IHNlZ21lbnRVcmxzID0gc2VnbWVudExpc3QgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRMaXN0LCAnU2VnbWVudFVSTCcpLm1hcChzID0+IG1lcmdlKHtcbiAgICB0YWc6ICdTZWdtZW50VVJMJ1xuICB9LCBwYXJzZUF0dHJpYnV0ZXMocykpKTtcbiAgY29uc3Qgc2VnbWVudEJhc2UgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1NlZ21lbnRCYXNlJylbMF07XG4gIGNvbnN0IHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUgPSBzZWdtZW50TGlzdCB8fCBzZWdtZW50VGVtcGxhdGU7XG4gIGNvbnN0IHNlZ21lbnRUaW1lbGluZSA9IHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUsICdTZWdtZW50VGltZWxpbmUnKVswXTtcbiAgY29uc3Qgc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSA9IHNlZ21lbnRMaXN0IHx8IHNlZ21lbnRCYXNlIHx8IHNlZ21lbnRUZW1wbGF0ZTtcbiAgY29uc3Qgc2VnbWVudEluaXRpYWxpemF0aW9uID0gc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSAmJiBmaW5kQ2hpbGRyZW4oc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSwgJ0luaXRpYWxpemF0aW9uJylbMF07IC8vIFNlZ21lbnRUZW1wbGF0ZSBpcyBoYW5kbGVkIHNsaWdodGx5IGRpZmZlcmVudGx5LCBzaW5jZSBpdCBjYW4gaGF2ZSBib3RoXG4gIC8vIEBpbml0aWFsaXphdGlvbiBhbmQgYW4gPEluaXRpYWxpemF0aW9uPiBub2RlLiAgQGluaXRpYWxpemF0aW9uIGNhbiBiZSB0ZW1wbGF0ZWQsXG4gIC8vIHdoaWxlIHRoZSBub2RlIGNhbiBoYXZlIGEgdXJsIGFuZCByYW5nZSBzcGVjaWZpZWQuICBJZiB0aGUgPFNlZ21lbnRUZW1wbGF0ZT4gaGFzXG4gIC8vIGJvdGggQGluaXRpYWxpemF0aW9uIGFuZCBhbiA8SW5pdGlhbGl6YXRpb24+IHN1YmVsZW1lbnQgd2Ugb3B0IHRvIG92ZXJyaWRlIHdpdGhcbiAgLy8gdGhlIG5vZGUsIGFzIHRoaXMgaW50ZXJhY3Rpb24gaXMgbm90IGRlZmluZWQgaW4gdGhlIHNwZWMuXG5cbiAgY29uc3QgdGVtcGxhdGUgPSBzZWdtZW50VGVtcGxhdGUgJiYgcGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRUZW1wbGF0ZSk7XG5cbiAgaWYgKHRlbXBsYXRlICYmIHNlZ21lbnRJbml0aWFsaXphdGlvbikge1xuICAgIHRlbXBsYXRlLmluaXRpYWxpemF0aW9uID0gc2VnbWVudEluaXRpYWxpemF0aW9uICYmIHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pO1xuICB9IGVsc2UgaWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLmluaXRpYWxpemF0aW9uKSB7XG4gICAgLy8gSWYgaXQgaXMgQGluaXRpYWxpemF0aW9uIHdlIGNvbnZlcnQgaXQgdG8gYW4gb2JqZWN0IHNpbmNlIHRoaXMgaXMgdGhlIGZvcm1hdCB0aGF0XG4gICAgLy8gbGF0ZXIgZnVuY3Rpb25zIHdpbGwgcmVseSBvbiBmb3IgdGhlIGluaXRpYWxpemF0aW9uIHNlZ21lbnQuICBUaGlzIGlzIG9ubHkgdmFsaWRcbiAgICAvLyBmb3IgPFNlZ21lbnRUZW1wbGF0ZT5cbiAgICB0ZW1wbGF0ZS5pbml0aWFsaXphdGlvbiA9IHtcbiAgICAgIHNvdXJjZVVSTDogdGVtcGxhdGUuaW5pdGlhbGl6YXRpb25cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc2VnbWVudEluZm8gPSB7XG4gICAgdGVtcGxhdGUsXG4gICAgc2VnbWVudFRpbWVsaW5lOiBzZWdtZW50VGltZWxpbmUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRUaW1lbGluZSwgJ1MnKS5tYXAocyA9PiBwYXJzZUF0dHJpYnV0ZXMocykpLFxuICAgIGxpc3Q6IHNlZ21lbnRMaXN0ICYmIG1lcmdlKHBhcnNlQXR0cmlidXRlcyhzZWdtZW50TGlzdCksIHtcbiAgICAgIHNlZ21lbnRVcmxzLFxuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSksXG4gICAgYmFzZTogc2VnbWVudEJhc2UgJiYgbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRCYXNlKSwge1xuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSlcbiAgfTtcbiAgT2JqZWN0LmtleXMoc2VnbWVudEluZm8pLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoIXNlZ21lbnRJbmZvW2tleV0pIHtcbiAgICAgIGRlbGV0ZSBzZWdtZW50SW5mb1trZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWdtZW50SW5mbztcbn07XG4vKipcbiAqIENvbnRhaW5zIFNlZ21lbnQgaW5mb3JtYXRpb24gYW5kIGF0dHJpYnV0ZXMgbmVlZGVkIHRvIGNvbnN0cnVjdCBhIFBsYXlsaXN0IG9iamVjdFxuICogZnJvbSBhIFJlcHJlc2VudGF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVwcmVzZW50YXRpb25JbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHtTZWdtZW50SW5mb3JtYXRpb259IHNlZ21lbnRJbmZvXG4gKiAgICAgICAgICAgU2VnbWVudCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBSZXByZXNlbnRhdGlvblxuICogQHByb3BlcnR5IHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICAgICBJbmhlcml0ZWQgYXR0cmlidXRlcyBmb3IgdGhpcyBSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogTWFwcyBhIFJlcHJlc2VudGF0aW9uIG5vZGUgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgU2VnbWVudCBpbmZvcm1hdGlvbiBhbmQgYXR0cmlidXRlc1xuICpcbiAqIEBuYW1lIGluaGVyaXRCYXNlVXJsc0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Tm9kZX0gcmVwcmVzZW50YXRpb25cbiAqICAgICAgICBSZXByZXNlbnRhdGlvbiBub2RlIGZyb20gdGhlIG1wZFxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbn1cbiAqICAgICAgICAgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gbmVlZGVkIHRvIGNvbnN0cnVjdCBhIFBsYXlsaXN0IG9iamVjdFxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIFJlcHJlc2VudGF0aW9uIG5vZGVzIHRvXG4gKiBTZWdtZW50IGluZm9ybWF0aW9uIGFuZCBhdHRyaWJ1dGVzIHVzaW5nIGluaGVyaXRlZCBCYXNlVVJMIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGF0aW9uU2V0QXR0cmlidXRlc1xuICogICAgICAgIENvbnRhaW5zIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGJ5IHRoZSBBZGFwdGF0aW9uU2V0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBhZGFwdGF0aW9uU2V0QmFzZVVybHNcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyByZXNvbHZlZCBiYXNlIFVSTHMgYW5kIGF0dHJpYnV0ZXNcbiAqICAgICAgICBpbmhlcml0ZWQgYnkgdGhlIEFkYXB0YXRpb25TZXRcbiAqIEBwYXJhbSB7U2VnbWVudEluZm9ybWF0aW9ufSBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm9cbiAqICAgICAgICBDb250YWlucyBTZWdtZW50IGluZm9ybWF0aW9uIGZvciB0aGUgQWRhcHRhdGlvblNldFxuICogQHJldHVybiB7aW5oZXJpdEJhc2VVcmxzQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbmNvbnN0IGluaGVyaXRCYXNlVXJscyA9IChhZGFwdGF0aW9uU2V0QXR0cmlidXRlcywgYWRhcHRhdGlvblNldEJhc2VVcmxzLCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8pID0+IHJlcHJlc2VudGF0aW9uID0+IHtcbiAgY29uc3QgcmVwQmFzZVVybEVsZW1lbnRzID0gZmluZENoaWxkcmVuKHJlcHJlc2VudGF0aW9uLCAnQmFzZVVSTCcpO1xuICBjb25zdCByZXBCYXNlVXJscyA9IGJ1aWxkQmFzZVVybHMoYWRhcHRhdGlvblNldEJhc2VVcmxzLCByZXBCYXNlVXJsRWxlbWVudHMpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbWVyZ2UoYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMsIHBhcnNlQXR0cmlidXRlcyhyZXByZXNlbnRhdGlvbikpO1xuICBjb25zdCByZXByZXNlbnRhdGlvblNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKHJlcHJlc2VudGF0aW9uKTtcbiAgcmV0dXJuIHJlcEJhc2VVcmxzLm1hcChiYXNlVXJsID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VnbWVudEluZm86IG1lcmdlKGFkYXB0YXRpb25TZXRTZWdtZW50SW5mbywgcmVwcmVzZW50YXRpb25TZWdtZW50SW5mbyksXG4gICAgICBhdHRyaWJ1dGVzOiBtZXJnZShhdHRyaWJ1dGVzLCBiYXNlVXJsKVxuICAgIH07XG4gIH0pO1xufTtcbi8qKlxuICogVHJhbmZvcm1zIGEgc2VyaWVzIG9mIGNvbnRlbnQgcHJvdGVjdGlvbiBub2RlcyB0b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHNzaCBkYXRhIGJ5IGtleSBzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge05vZGVbXX0gY29udGVudFByb3RlY3Rpb25Ob2Rlc1xuICogICAgICAgIENvbnRlbnQgcHJvdGVjdGlvbiBub2Rlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHBzc2ggZGF0YSBieSBrZXkgc3lzdGVtXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbiA9IGNvbnRlbnRQcm90ZWN0aW9uTm9kZXMgPT4ge1xuICByZXR1cm4gY29udGVudFByb3RlY3Rpb25Ob2Rlcy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobm9kZSk7IC8vIEFsdGhvdWdoIGl0IGNvdWxkIGJlIGFyZ3VlZCB0aGF0IGFjY29yZGluZyB0byB0aGUgVVVJRCBSRkMgc3BlYyB0aGUgVVVJRCBzdHJpbmcgKGEtZiBjaGFycykgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICAgIC8vIGFzIGEgbG93ZXJjYXNlIHN0cmluZyBpdCBhbHNvIG1lbnRpb25zIGl0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGNhc2UtaW5zZW5zaXRpdmUgb24gaW5wdXQuIFNpbmNlIHRoZSBrZXkgc3lzdGVtXG4gICAgLy8gVVVJRHMgaW4gdGhlIGtleVN5c3RlbXNNYXAgYXJlIGhhcmRjb2RlZCBhcyBsb3dlcmNhc2UgaW4gdGhlIGNvZGViYXNlIHRoZXJlIGlzbid0IGFueSByZWFzb24gbm90IHRvIGRvXG4gICAgLy8gLnRvTG93ZXJDYXNlKCkgb24gdGhlIGlucHV0IFVVSUQgc3RyaW5nIGZyb20gdGhlIG1hbmlmZXN0IChhdCBsZWFzdCBJIGNvdWxkIG5vdCB0aGluayBvZiBvbmUpLlxuXG4gICAgaWYgKGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkpIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkgPSBhdHRyaWJ1dGVzLnNjaGVtZUlkVXJpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5U3lzdGVtID0ga2V5U3lzdGVtc01hcFthdHRyaWJ1dGVzLnNjaGVtZUlkVXJpXTtcblxuICAgIGlmIChrZXlTeXN0ZW0pIHtcbiAgICAgIGFjY1trZXlTeXN0ZW1dID0ge1xuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9O1xuICAgICAgY29uc3QgcHNzaE5vZGUgPSBmaW5kQ2hpbGRyZW4obm9kZSwgJ2NlbmM6cHNzaCcpWzBdO1xuXG4gICAgICBpZiAocHNzaE5vZGUpIHtcbiAgICAgICAgY29uc3QgcHNzaCA9IGdldENvbnRlbnQocHNzaE5vZGUpO1xuICAgICAgICBhY2Nba2V5U3lzdGVtXS5wc3NoID0gcHNzaCAmJiBkZWNvZGVCNjRUb1VpbnQ4QXJyYXkocHNzaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTsgLy8gZGVmaW5lZCBpbiBBTlNJX1NDVEUgMjE0LTEgMjAxNlxuXG5cbmNvbnN0IHBhcnNlQ2FwdGlvblNlcnZpY2VNZXRhZGF0YSA9IHNlcnZpY2UgPT4ge1xuICAvLyA2MDggY2FwdGlvbnNcbiAgaWYgKHNlcnZpY2Uuc2NoZW1lSWRVcmkgPT09ICd1cm46c2N0ZTpkYXNoOmNjOmNlYS02MDg6MjAxNScpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB0eXBlb2Ygc2VydmljZS52YWx1ZSAhPT0gJ3N0cmluZycgPyBbXSA6IHNlcnZpY2UudmFsdWUuc3BsaXQoJzsnKTtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCh2YWx1ZSA9PiB7XG4gICAgICBsZXQgY2hhbm5lbDtcbiAgICAgIGxldCBsYW5ndWFnZTsgLy8gZGVmYXVsdCBsYW5ndWFnZSB0byB2YWx1ZVxuXG4gICAgICBsYW5ndWFnZSA9IHZhbHVlO1xuXG4gICAgICBpZiAoL15DQ1xcZD0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIFtjaGFubmVsLCBsYW5ndWFnZV0gPSB2YWx1ZS5zcGxpdCgnPScpO1xuICAgICAgfSBlbHNlIGlmICgvXkNDXFxkJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY2hhbm5lbCA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsLFxuICAgICAgICBsYW5ndWFnZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzZXJ2aWNlLnNjaGVtZUlkVXJpID09PSAndXJuOnNjdGU6ZGFzaDpjYzpjZWEtNzA4OjIwMTUnKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdHlwZW9mIHNlcnZpY2UudmFsdWUgIT09ICdzdHJpbmcnID8gW10gOiBzZXJ2aWNlLnZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgZmxhZ3MgPSB7XG4gICAgICAgIC8vIHNlcnZpY2Ugb3IgY2hhbm5lbCBudW1iZXIgMS02M1xuICAgICAgICAnY2hhbm5lbCc6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gbGFuZ3VhZ2UgaXMgYSAzQUxQSEEgcGVyIElTTyA2MzkuMi9CXG4gICAgICAgIC8vIGZpZWxkIGlzIHJlcXVpcmVkXG4gICAgICAgICdsYW5ndWFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gQklUIDEvMCBvciA/XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMSwgbWVhbmluZyAxNjo5IGFzcGVjdCByYXRpbywgMCBpcyA0OjMsID8gaXMgdW5rbm93blxuICAgICAgICAnYXNwZWN0UmF0aW8nOiAxLFxuICAgICAgICAvLyBCSVQgMS8wXG4gICAgICAgIC8vIGVhc3kgcmVhZGVyIGZsYWcgaW5kaWNhdGVkIHRoZSB0ZXh0IGlzIHRhaWxlZCB0byB0aGUgbmVlZHMgb2YgYmVnaW5uaW5nIHJlYWRlcnNcbiAgICAgICAgLy8gZGVmYXVsdCAwLCBvciBvZmZcbiAgICAgICAgJ2Vhc3lSZWFkZXInOiAwLFxuICAgICAgICAvLyBCSVQgMS8wXG4gICAgICAgIC8vIElmIDNkIG1ldGFkYXRhIGlzIHByZXNlbnQgKENFQS03MDguMSkgdGhlbiAxXG4gICAgICAgIC8vIGRlZmF1bHQgMFxuICAgICAgICAnM0QnOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoLz0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IFtjaGFubmVsLCBvcHRzID0gJyddID0gdmFsdWUuc3BsaXQoJz0nKTtcbiAgICAgICAgZmxhZ3MuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIGZsYWdzLmxhbmd1YWdlID0gdmFsdWU7XG4gICAgICAgIG9wdHMuc3BsaXQoJywnKS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgY29uc3QgW25hbWUsIHZhbF0gPSBvcHQuc3BsaXQoJzonKTtcblxuICAgICAgICAgIGlmIChuYW1lID09PSAnbGFuZycpIHtcbiAgICAgICAgICAgIGZsYWdzLmxhbmd1YWdlID0gdmFsOyAvLyBlciBmb3IgZWFzeVJlYWRlcnlcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlcicpIHtcbiAgICAgICAgICAgIGZsYWdzLmVhc3lSZWFkZXIgPSBOdW1iZXIodmFsKTsgLy8gd2FyIGZvciB3aWRlIGFzcGVjdCByYXRpb1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3dhcicpIHtcbiAgICAgICAgICAgIGZsYWdzLmFzcGVjdFJhdGlvID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnM0QnKSB7XG4gICAgICAgICAgICBmbGFnc1snM0QnXSA9IE51bWJlcih2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGFncy5sYW5ndWFnZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxhZ3MuY2hhbm5lbCkge1xuICAgICAgICBmbGFncy5jaGFubmVsID0gJ1NFUlZJQ0UnICsgZmxhZ3MuY2hhbm5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH0pO1xuICB9XG59O1xuLyoqXG4gKiBBIG1hcCBjYWxsYmFjayB0aGF0IHdpbGwgcGFyc2UgYWxsIGV2ZW50IHN0cmVhbSBkYXRhIGZvciBhIGNvbGxlY3Rpb24gb2YgcGVyaW9kc1xuICogREFTSCBJU09fSUVDXzIzMDA5IDUuMTAuMi4yXG4gKiBodHRwczovL2Rhc2hpZi1kb2N1bWVudHMuYXp1cmV3ZWJzaXRlcy5uZXQvRXZlbnRzL21hc3Rlci9ldmVudC5odG1sI21wZC1ldmVudC10aW1pbmdcbiAqXG4gKiBAcGFyYW0ge1BlcmlvZEluZm9ybWF0aW9ufSBwZXJpb2Qgb2JqZWN0IGNvbnRhaW5pbmcgbmVjZXNzYXJ5IHBlcmlvZCBpbmZvcm1hdGlvblxuICogQHJldHVybiBhIGNvbGxlY3Rpb24gb2YgcGFyc2VkIGV2ZW50c3RyZWFtIGV2ZW50IG9iamVjdHNcbiAqL1xuXG5jb25zdCB0b0V2ZW50U3RyZWFtID0gcGVyaW9kID0+IHtcbiAgLy8gZ2V0IGFuZCBmbGF0dGVuIGFsbCBFdmVudFN0cmVhbXMgdGFncyBhbmQgcGFyc2UgYXR0cmlidXRlcyBhbmQgY2hpbGRyZW5cbiAgcmV0dXJuIGZsYXR0ZW4oZmluZENoaWxkcmVuKHBlcmlvZC5ub2RlLCAnRXZlbnRTdHJlYW0nKS5tYXAoZXZlbnRTdHJlYW0gPT4ge1xuICAgIGNvbnN0IGV2ZW50U3RyZWFtQXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhldmVudFN0cmVhbSk7XG4gICAgY29uc3Qgc2NoZW1lSWRVcmkgPSBldmVudFN0cmVhbUF0dHJpYnV0ZXMuc2NoZW1lSWRVcmk7IC8vIGZpbmQgYWxsIEV2ZW50cyBwZXIgRXZlbnRTdHJlYW0gdGFnIGFuZCBtYXAgdG8gcmV0dXJuIG9iamVjdHNcblxuICAgIHJldHVybiBmaW5kQ2hpbGRyZW4oZXZlbnRTdHJlYW0sICdFdmVudCcpLm1hcChldmVudCA9PiB7XG4gICAgICBjb25zdCBldmVudEF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMoZXZlbnQpO1xuICAgICAgY29uc3QgcHJlc2VudGF0aW9uVGltZSA9IGV2ZW50QXR0cmlidXRlcy5wcmVzZW50YXRpb25UaW1lIHx8IDA7XG4gICAgICBjb25zdCB0aW1lc2NhbGUgPSBldmVudFN0cmVhbUF0dHJpYnV0ZXMudGltZXNjYWxlIHx8IDE7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGV2ZW50QXR0cmlidXRlcy5kdXJhdGlvbiB8fCAwO1xuICAgICAgY29uc3Qgc3RhcnQgPSBwcmVzZW50YXRpb25UaW1lIC8gdGltZXNjYWxlICsgcGVyaW9kLmF0dHJpYnV0ZXMuc3RhcnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWVJZFVyaSxcbiAgICAgICAgdmFsdWU6IGV2ZW50U3RyZWFtQXR0cmlidXRlcy52YWx1ZSxcbiAgICAgICAgaWQ6IGV2ZW50QXR0cmlidXRlcy5pZCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZDogc3RhcnQgKyBkdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgbWVzc2FnZURhdGE6IGdldENvbnRlbnQoZXZlbnQpIHx8IGV2ZW50QXR0cmlidXRlcy5tZXNzYWdlRGF0YSxcbiAgICAgICAgY29udGVudEVuY29kaW5nOiBldmVudFN0cmVhbUF0dHJpYnV0ZXMuY29udGVudEVuY29kaW5nLFxuICAgICAgICBwcmVzZW50YXRpb25UaW1lT2Zmc2V0OiBldmVudFN0cmVhbUF0dHJpYnV0ZXMucHJlc2VudGF0aW9uVGltZU9mZnNldCB8fCAwXG4gICAgICB9O1xuICAgIH0pO1xuICB9KSk7XG59O1xuLyoqXG4gKiBNYXBzIGFuIEFkYXB0YXRpb25TZXQgbm9kZSB0byBhIGxpc3Qgb2YgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0c1xuICpcbiAqIEBuYW1lIHRvUmVwcmVzZW50YXRpb25zQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOb2RlfSBhZGFwdGF0aW9uU2V0XG4gKiAgICAgICAgQWRhcHRhdGlvblNldCBub2RlIGZyb20gdGhlIG1wZFxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbltdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBSZXByZXNlbnRhaW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgZm9yIEFycmF5LnByb3RvdHlwZS5tYXAgZm9yIG1hcHBpbmcgQWRhcHRhdGlvblNldCBub2RlcyB0byBhIGxpc3Qgb2ZcbiAqIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGVyaW9kQXR0cmlidXRlc1xuICogICAgICAgIENvbnRhaW5zIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGJ5IHRoZSBQZXJpb2RcbiAqIEBwYXJhbSB7T2JqZWN0W119IHBlcmlvZEJhc2VVcmxzXG4gKiAgICAgICAgQ29udGFpbnMgbGlzdCBvZiBvYmplY3RzIHdpdGggcmVzb2x2ZWQgYmFzZSB1cmxzIGFuZCBhdHRyaWJ1dGVzXG4gKiAgICAgICAgaW5oZXJpdGVkIGJ5IHRoZSBQZXJpb2RcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBlcmlvZFNlZ21lbnRJbmZvXG4gKiAgICAgICAgQ29udGFpbnMgU2VnbWVudCBJbmZvcm1hdGlvbiBhdCB0aGUgcGVyaW9kIGxldmVsXG4gKiBAcmV0dXJuIHt0b1JlcHJlc2VudGF0aW9uc0NhbGxiYWNrfVxuICogICAgICAgICBDYWxsYmFjayBtYXAgZnVuY3Rpb25cbiAqL1xuXG5jb25zdCB0b1JlcHJlc2VudGF0aW9ucyA9IChwZXJpb2RBdHRyaWJ1dGVzLCBwZXJpb2RCYXNlVXJscywgcGVyaW9kU2VnbWVudEluZm8pID0+IGFkYXB0YXRpb25TZXQgPT4ge1xuICBjb25zdCBhZGFwdGF0aW9uU2V0QXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhhZGFwdGF0aW9uU2V0KTtcbiAgY29uc3QgYWRhcHRhdGlvblNldEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhwZXJpb2RCYXNlVXJscywgZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdCYXNlVVJMJykpO1xuICBjb25zdCByb2xlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdSb2xlJylbMF07XG4gIGNvbnN0IHJvbGVBdHRyaWJ1dGVzID0ge1xuICAgIHJvbGU6IHBhcnNlQXR0cmlidXRlcyhyb2xlKVxuICB9O1xuICBsZXQgYXR0cnMgPSBtZXJnZShwZXJpb2RBdHRyaWJ1dGVzLCBhZGFwdGF0aW9uU2V0QXR0cmlidXRlcywgcm9sZUF0dHJpYnV0ZXMpO1xuICBjb25zdCBhY2Nlc3NpYmlsaXR5ID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdBY2Nlc3NpYmlsaXR5JylbMF07XG4gIGNvbnN0IGNhcHRpb25TZXJ2aWNlcyA9IHBhcnNlQ2FwdGlvblNlcnZpY2VNZXRhZGF0YShwYXJzZUF0dHJpYnV0ZXMoYWNjZXNzaWJpbGl0eSkpO1xuXG4gIGlmIChjYXB0aW9uU2VydmljZXMpIHtcbiAgICBhdHRycyA9IG1lcmdlKGF0dHJzLCB7XG4gICAgICBjYXB0aW9uU2VydmljZXNcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGxhYmVsID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdMYWJlbCcpWzBdO1xuXG4gIGlmIChsYWJlbCAmJiBsYWJlbC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGxhYmVsVmFsID0gbGFiZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUudHJpbSgpO1xuICAgIGF0dHJzID0gbWVyZ2UoYXR0cnMsIHtcbiAgICAgIGxhYmVsOiBsYWJlbFZhbFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgY29udGVudFByb3RlY3Rpb24gPSBnZW5lcmF0ZUtleVN5c3RlbUluZm9ybWF0aW9uKGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnQ29udGVudFByb3RlY3Rpb24nKSk7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGNvbnRlbnRQcm90ZWN0aW9uKS5sZW5ndGgpIHtcbiAgICBhdHRycyA9IG1lcmdlKGF0dHJzLCB7XG4gICAgICBjb250ZW50UHJvdGVjdGlvblxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc2VnbWVudEluZm8gPSBnZXRTZWdtZW50SW5mb3JtYXRpb24oYWRhcHRhdGlvblNldCk7XG4gIGNvbnN0IHJlcHJlc2VudGF0aW9ucyA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnUmVwcmVzZW50YXRpb24nKTtcbiAgY29uc3QgYWRhcHRhdGlvblNldFNlZ21lbnRJbmZvID0gbWVyZ2UocGVyaW9kU2VnbWVudEluZm8sIHNlZ21lbnRJbmZvKTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmVwcmVzZW50YXRpb25zLm1hcChpbmhlcml0QmFzZVVybHMoYXR0cnMsIGFkYXB0YXRpb25TZXRCYXNlVXJscywgYWRhcHRhdGlvblNldFNlZ21lbnRJbmZvKSkpO1xufTtcbi8qKlxuICogQ29udGFpbnMgYWxsIHBlcmlvZCBpbmZvcm1hdGlvbiBmb3IgbWFwcGluZyBub2RlcyBvbnRvIGFkYXB0YXRpb24gc2V0cy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJpb2RJbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHtOb2RlfSBwZXJpb2Qubm9kZVxuICogICAgICAgICAgIFBlcmlvZCBub2RlIGZyb20gdGhlIG1wZFxuICogQHByb3BlcnR5IHtPYmplY3R9IHBlcmlvZC5hdHRyaWJ1dGVzXG4gKiAgICAgICAgICAgUGFyc2VkIHBlcmlvZCBhdHRyaWJ1dGVzIGZyb20gbm9kZSBwbHVzIGFueSBhZGRlZFxuICovXG5cbi8qKlxuICogTWFwcyBhIFBlcmlvZEluZm9ybWF0aW9uIG9iamVjdCB0byBhIGxpc3Qgb2YgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0cyBmb3IgYWxsXG4gKiBBZGFwdGF0aW9uU2V0IG5vZGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIFBlcmlvZC5cbiAqXG4gKiBAbmFtZSB0b0FkYXB0YXRpb25TZXRzQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtQZXJpb2RJbmZvcm1hdGlvbn0gcGVyaW9kXG4gKiAgICAgICAgUGVyaW9kIG9iamVjdCBjb250YWluaW5nIG5lY2Vzc2FyeSBwZXJpb2QgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2RTdGFydFxuICogICAgICAgIFN0YXJ0IHRpbWUgb2YgdGhlIFBlcmlvZCB3aXRoaW4gdGhlIG1wZFxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbltdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBSZXByZXNlbnRhaW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgZm9yIEFycmF5LnByb3RvdHlwZS5tYXAgZm9yIG1hcHBpbmcgUGVyaW9kIG5vZGVzIHRvIGEgbGlzdCBvZlxuICogUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtcGRBdHRyaWJ1dGVzXG4gKiAgICAgICAgQ29udGFpbnMgYXR0cmlidXRlcyBpbmhlcml0ZWQgYnkgdGhlIG1wZFxuICAqIEBwYXJhbSB7T2JqZWN0W119IG1wZEJhc2VVcmxzXG4gKiAgICAgICAgQ29udGFpbnMgbGlzdCBvZiBvYmplY3RzIHdpdGggcmVzb2x2ZWQgYmFzZSB1cmxzIGFuZCBhdHRyaWJ1dGVzXG4gKiAgICAgICAgaW5oZXJpdGVkIGJ5IHRoZSBtcGRcbiAqIEByZXR1cm4ge3RvQWRhcHRhdGlvblNldHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cblxuY29uc3QgdG9BZGFwdGF0aW9uU2V0cyA9IChtcGRBdHRyaWJ1dGVzLCBtcGRCYXNlVXJscykgPT4gKHBlcmlvZCwgaW5kZXgpID0+IHtcbiAgY29uc3QgcGVyaW9kQmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKG1wZEJhc2VVcmxzLCBmaW5kQ2hpbGRyZW4ocGVyaW9kLm5vZGUsICdCYXNlVVJMJykpO1xuICBjb25zdCBwZXJpb2RBdHRyaWJ1dGVzID0gbWVyZ2UobXBkQXR0cmlidXRlcywge1xuICAgIHBlcmlvZFN0YXJ0OiBwZXJpb2QuYXR0cmlidXRlcy5zdGFydFxuICB9KTtcblxuICBpZiAodHlwZW9mIHBlcmlvZC5hdHRyaWJ1dGVzLmR1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgIHBlcmlvZEF0dHJpYnV0ZXMucGVyaW9kRHVyYXRpb24gPSBwZXJpb2QuYXR0cmlidXRlcy5kdXJhdGlvbjtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0YXRpb25TZXRzID0gZmluZENoaWxkcmVuKHBlcmlvZC5ub2RlLCAnQWRhcHRhdGlvblNldCcpO1xuICBjb25zdCBwZXJpb2RTZWdtZW50SW5mbyA9IGdldFNlZ21lbnRJbmZvcm1hdGlvbihwZXJpb2Qubm9kZSk7XG4gIHJldHVybiBmbGF0dGVuKGFkYXB0YXRpb25TZXRzLm1hcCh0b1JlcHJlc2VudGF0aW9ucyhwZXJpb2RBdHRyaWJ1dGVzLCBwZXJpb2RCYXNlVXJscywgcGVyaW9kU2VnbWVudEluZm8pKSk7XG59O1xuLyoqXG4gKiBUcmFuZm9ybXMgYW4gYXJyYXkgb2YgY29udGVudCBzdGVlcmluZyBub2RlcyBpbnRvIGFuIG9iamVjdFxuICogY29udGFpbmluZyBDRE4gY29udGVudCBzdGVlcmluZyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBNUEQgbWFuaWZlc3QuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIERBU0ggc3BlYyBmb3IgQ29udGVudCBTdGVlcmluZyBwYXJzaW5nLCBzZWU6XG4gKiBodHRwczovL2Rhc2hpZi5vcmcvZG9jcy9EQVNILUlGLUNUUy0wMFhYLUNvbnRlbnQtU3RlZXJpbmctQ29tbXVuaXR5LVJldmlldy5wZGZcbiAqXG4gKiBAcGFyYW0ge05vZGVbXX0gY29udGVudFN0ZWVyaW5nTm9kZXNcbiAqICAgICAgICBDb250ZW50IHN0ZWVyaW5nIG5vZGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXJcbiAqICAgICAgICBUaGUgZXZlbnQgaGFuZGxlciBwYXNzZWQgaW50byB0aGUgcGFyc2VyIG9wdGlvbnMgdG8gaGFuZGxlIHdhcm5pbmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgY29udGVudCBzdGVlcmluZyBkYXRhXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVDb250ZW50U3RlZXJpbmdJbmZvcm1hdGlvbiA9IChjb250ZW50U3RlZXJpbmdOb2RlcywgZXZlbnRIYW5kbGVyKSA9PiB7XG4gIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIENvbnRlbnRTdGVlcmluZyB0YWdzLCB0aHJvdyBhbiBlcnJvclxuICBpZiAoY29udGVudFN0ZWVyaW5nTm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGV2ZW50SGFuZGxlcih7XG4gICAgICB0eXBlOiAnd2FybicsXG4gICAgICBtZXNzYWdlOiAnVGhlIE1QRCBtYW5pZmVzdCBzaG91bGQgY29udGFpbiBubyBtb3JlIHRoYW4gb25lIENvbnRlbnRTdGVlcmluZyB0YWcnXG4gICAgfSk7XG4gIH0gLy8gUmV0dXJuIGEgbnVsbCB2YWx1ZSBpZiB0aGVyZSBhcmUgbm8gQ29udGVudFN0ZWVyaW5nIHRhZ3NcblxuXG4gIGlmICghY29udGVudFN0ZWVyaW5nTm9kZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpbmZvRnJvbUNvbnRlbnRTdGVlcmluZ1RhZyA9IG1lcmdlKHtcbiAgICBzZXJ2ZXJVUkw6IGdldENvbnRlbnQoY29udGVudFN0ZWVyaW5nTm9kZXNbMF0pXG4gIH0sIHBhcnNlQXR0cmlidXRlcyhjb250ZW50U3RlZXJpbmdOb2Rlc1swXSkpOyAvLyBDb252ZXJ0cyBgcXVlcnlCZWZvcmVTdGFydGAgdG8gYSBib29sZWFuLCBhcyB3ZWxsIGFzIHNldHRpbmcgdGhlIGRlZmF1bHQgdmFsdWVcbiAgLy8gdG8gYGZhbHNlYCBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cbiAgaW5mb0Zyb21Db250ZW50U3RlZXJpbmdUYWcucXVlcnlCZWZvcmVTdGFydCA9IGluZm9Gcm9tQ29udGVudFN0ZWVyaW5nVGFnLnF1ZXJ5QmVmb3JlU3RhcnQgPT09ICd0cnVlJztcbiAgcmV0dXJuIGluZm9Gcm9tQ29udGVudFN0ZWVyaW5nVGFnO1xufTtcbi8qKlxuICogR2V0cyBQZXJpb2RAc3RhcnQgcHJvcGVydHkgZm9yIGEgZ2l2ZW4gcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF0dHJpYnV0ZXNcbiAqICAgICAgICBQZXJpb2QgYXR0cmlidXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByaW9yUGVyaW9kQXR0cmlidXRlc11cbiAqICAgICAgICBQcmlvciBwZXJpb2QgYXR0cmlidXRlcyAoaWYgcHJpb3IgcGVyaW9kIGlzIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1wZFR5cGVcbiAqICAgICAgICBUaGUgTVBEQHR5cGUgdGhlc2UgcGVyaW9kcyBjYW1lIGZyb21cbiAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuICogICAgICAgICBUaGUgcGVyaW9kIHN0YXJ0LCBvciBudWxsIGlmIGl0J3MgYW4gZWFybHkgYXZhaWxhYmxlIHBlcmlvZCBvciBlcnJvclxuICovXG5cbmNvbnN0IGdldFBlcmlvZFN0YXJ0ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLFxuICBtcGRUeXBlXG59KSA9PiB7XG4gIC8vIFN1bW1hcnkgb2YgcGVyaW9kIHN0YXJ0IHRpbWUgY2FsY3VsYXRpb24gZnJvbSBEQVNIIHNwZWMgc2VjdGlvbiA1LjMuMi4xXG4gIC8vXG4gIC8vIEEgcGVyaW9kJ3Mgc3RhcnQgaXMgdGhlIGZpcnN0IHBlcmlvZCdzIHN0YXJ0ICsgdGltZSBlbGFwc2VkIGFmdGVyIHBsYXlpbmcgYWxsXG4gIC8vIHByaW9yIHBlcmlvZHMgdG8gdGhpcyBvbmUuIFBlcmlvZHMgY29udGludWUgb25lIGFmdGVyIHRoZSBvdGhlciBpbiB0aW1lICh3aXRob3V0XG4gIC8vIGdhcHMpIHVudGlsIHRoZSBlbmQgb2YgdGhlIHByZXNlbnRhdGlvbi5cbiAgLy9cbiAgLy8gVGhlIHZhbHVlIG9mIFBlcmlvZEBzdGFydCBzaG91bGQgYmU6XG4gIC8vIDEuIGlmIFBlcmlvZEBzdGFydCBpcyBwcmVzZW50OiB2YWx1ZSBvZiBQZXJpb2RAc3RhcnRcbiAgLy8gMi4gaWYgcHJldmlvdXMgcGVyaW9kIGV4aXN0cyBhbmQgaXQgaGFzIEBkdXJhdGlvbjogcHJldmlvdXMgUGVyaW9kQHN0YXJ0ICtcbiAgLy8gICAgcHJldmlvdXMgUGVyaW9kQGR1cmF0aW9uXG4gIC8vIDMuIGlmIHRoaXMgaXMgZmlyc3QgcGVyaW9kIGFuZCBNUERAdHlwZSBpcyAnc3RhdGljJzogMFxuICAvLyA0LiBpbiBhbGwgb3RoZXIgY2FzZXMsIGNvbnNpZGVyIHRoZSBwZXJpb2QgYW4gXCJlYXJseSBhdmFpbGFibGUgcGVyaW9kXCIgKG5vdGU6IG5vdFxuICAvLyAgICBjdXJyZW50bHkgc3VwcG9ydGVkKVxuICAvLyAoMSlcbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLnN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzLnN0YXJ0O1xuICB9IC8vICgyKVxuXG5cbiAgaWYgKHByaW9yUGVyaW9kQXR0cmlidXRlcyAmJiB0eXBlb2YgcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLnN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLmR1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBwcmlvclBlcmlvZEF0dHJpYnV0ZXMuc3RhcnQgKyBwcmlvclBlcmlvZEF0dHJpYnV0ZXMuZHVyYXRpb247XG4gIH0gLy8gKDMpXG5cblxuICBpZiAoIXByaW9yUGVyaW9kQXR0cmlidXRlcyAmJiBtcGRUeXBlID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiAwO1xuICB9IC8vICg0KVxuICAvLyBUaGVyZSBpcyBjdXJyZW50bHkgbm8gbG9naWMgZm9yIGNhbGN1bGF0aW5nIHRoZSBQZXJpb2RAc3RhcnQgdmFsdWUgaWYgdGhlcmUgaXNcbiAgLy8gbm8gUGVyaW9kQHN0YXJ0IG9yIHByaW9yIFBlcmlvZEBzdGFydCBhbmQgUGVyaW9kQGR1cmF0aW9uIGF2YWlsYWJsZS4gVGhpcyBpcyBub3QgbWFkZVxuICAvLyBleHBsaWNpdCBieSB0aGUgREFTSCBpbnRlcm9wIGd1aWRlbGluZXMgb3IgdGhlIERBU0ggc3BlYywgaG93ZXZlciwgc2luY2UgdGhlcmUnc1xuICAvLyBub3RoaW5nIGFib3V0IGFueSBvdGhlciByZXNvbHV0aW9uIHN0cmF0ZWdpZXMsIGl0J3MgaW1wbGllZC4gVGh1cywgdGhpcyBjYXNlIHNob3VsZFxuICAvLyBiZSBjb25zaWRlcmVkIGFuIGVhcmx5IGF2YWlsYWJsZSBwZXJpb2QsIG9yIGVycm9yLCBhbmQgbnVsbCBzaG91bGQgc3VmZmljZSBmb3IgYm90aFxuICAvLyBvZiB0aG9zZSBjYXNlcy5cblxuXG4gIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogVHJhdmVyc2VzIHRoZSBtcGQgeG1sIHRyZWUgdG8gZ2VuZXJhdGUgYSBsaXN0IG9mIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqIHRoYXQgaGF2ZSBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBub2Rlc1xuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbXBkXG4gKiAgICAgICAgVGhlIHJvb3Qgbm9kZSBvZiB0aGUgbXBkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIEF2YWlsYWJsZSBvcHRpb25zIGZvciBpbmhlcml0QXR0cmlidXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWFuaWZlc3RVcmlcbiAqICAgICAgICBUaGUgdXJpIHNvdXJjZSBvZiB0aGUgbXBkXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5OT1dcbiAqICAgICAgICBDdXJyZW50IHRpbWUgcGVyIERBU0ggSU9QLiAgRGVmYXVsdCBpcyBjdXJyZW50IHRpbWUgaW4gbXMgc2luY2UgZXBvY2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNsaWVudE9mZnNldFxuICogICAgICAgIENsaWVudCB0aW1lIGRpZmZlcmVuY2UgZnJvbSBOT1cgKGluIG1pbGxpc2Vjb25kcylcbiAqIEByZXR1cm4ge1JlcHJlc2VudGF0aW9uSW5mb3JtYXRpb25bXX1cbiAqICAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb25cbiAqL1xuXG5jb25zdCBpbmhlcml0QXR0cmlidXRlcyA9IChtcGQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7XG4gICAgbWFuaWZlc3RVcmkgPSAnJyxcbiAgICBOT1cgPSBEYXRlLm5vdygpLFxuICAgIGNsaWVudE9mZnNldCA9IDAsXG4gICAgLy8gVE9ETzogRm9yIG5vdywgd2UgYXJlIGV4cGVjdGluZyBhbiBldmVudEhhbmRsZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAvLyB0byBiZSBwYXNzZWQgaW50byB0aGUgbXBkIHBhcnNlciBhcyBhbiBvcHRpb24uXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIGVuYWJsZSBzdHJlYW0gcGFyc2luZyBieSB1c2luZyB0aGUgU3RyZWFtIGNsYXNzIGZyb20gdmhzLXV0aWxzLlxuICAgIC8vIFRoaXMgd2lsbCBzdXBwb3J0IG5ldyBmZWF0dXJlcyBpbmNsdWRpbmcgYSBzdGFuZGFyZGl6ZWQgZXZlbnQgaGFuZGxlci5cbiAgICAvLyBTZWUgdGhlIG0zdTggcGFyc2VyIGZvciBleGFtcGxlcyBvZiBob3cgc3RyZWFtIHBhcnNpbmcgaXMgY3VycmVudGx5IHVzZWQgZm9yIEhMUyBwYXJzaW5nLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3Zocy11dGlscy9ibG9iLzg4ZDZlMTBjNjMxZTU3YTVhZjAyYzVhNjJiYzczNzZjZDQ1NmI0ZjUvc3JjL3N0cmVhbS5qcyNMOVxuICAgIGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwZXJpb2ROb2RlcyA9IGZpbmRDaGlsZHJlbihtcGQsICdQZXJpb2QnKTtcblxuICBpZiAoIXBlcmlvZE5vZGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU5WQUxJRF9OVU1CRVJfT0ZfUEVSSU9EKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2F0aW9ucyA9IGZpbmRDaGlsZHJlbihtcGQsICdMb2NhdGlvbicpO1xuICBjb25zdCBtcGRBdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1wZCk7XG4gIGNvbnN0IG1wZEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhbe1xuICAgIGJhc2VVcmw6IG1hbmlmZXN0VXJpXG4gIH1dLCBmaW5kQ2hpbGRyZW4obXBkLCAnQmFzZVVSTCcpKTtcbiAgY29uc3QgY29udGVudFN0ZWVyaW5nTm9kZXMgPSBmaW5kQ2hpbGRyZW4obXBkLCAnQ29udGVudFN0ZWVyaW5nJyk7IC8vIFNlZSBEQVNIIHNwZWMgc2VjdGlvbiA1LjMuMS4yLCBTZW1hbnRpY3Mgb2YgTVBEIGVsZW1lbnQuIERlZmF1bHQgdHlwZSB0byAnc3RhdGljJy5cblxuICBtcGRBdHRyaWJ1dGVzLnR5cGUgPSBtcGRBdHRyaWJ1dGVzLnR5cGUgfHwgJ3N0YXRpYyc7XG4gIG1wZEF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24gPSBtcGRBdHRyaWJ1dGVzLm1lZGlhUHJlc2VudGF0aW9uRHVyYXRpb24gfHwgMDtcbiAgbXBkQXR0cmlidXRlcy5OT1cgPSBOT1c7XG4gIG1wZEF0dHJpYnV0ZXMuY2xpZW50T2Zmc2V0ID0gY2xpZW50T2Zmc2V0O1xuXG4gIGlmIChsb2NhdGlvbnMubGVuZ3RoKSB7XG4gICAgbXBkQXR0cmlidXRlcy5sb2NhdGlvbnMgPSBsb2NhdGlvbnMubWFwKGdldENvbnRlbnQpO1xuICB9XG5cbiAgY29uc3QgcGVyaW9kcyA9IFtdOyAvLyBTaW5jZSB0b0FkYXB0YXRpb25TZXRzIGFjdHMgb24gaW5kaXZpZHVhbCBwZXJpb2RzIHJpZ2h0IG5vdywgdGhlIHNpbXBsZXN0IGFwcHJvYWNoIHRvXG4gIC8vIGFkZGluZyBwcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBsb29raW5nIGF0IHByaW9yIHBlcmlvZHMgaXMgdG8gcGFyc2UgYXR0cmlidXRlcyBhbmQgYWRkXG4gIC8vIG1pc3Npbmcgb25lcyBiZWZvcmUgdG9BZGFwdGF0aW9uU2V0cyBpcyBjYWxsZWQuIElmIG1vcmUgc3VjaCBwcm9wZXJ0aWVzIGFyZSBhZGRlZCwgaXRcbiAgLy8gbWF5IGJlIGJldHRlciB0byByZWZhY3RvciB0b0FkYXB0YXRpb25TZXRzLlxuXG4gIHBlcmlvZE5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhub2RlKTsgLy8gVXNlIHRoZSBsYXN0IG1vZGlmaWVkIHByaW9yIHBlcmlvZCwgYXMgaXQgbWF5IGNvbnRhaW4gYWRkZWQgaW5mb3JtYXRpb24gbmVjZXNzYXJ5XG4gICAgLy8gZm9yIHRoaXMgcGVyaW9kLlxuXG4gICAgY29uc3QgcHJpb3JQZXJpb2QgPSBwZXJpb2RzW2luZGV4IC0gMV07XG4gICAgYXR0cmlidXRlcy5zdGFydCA9IGdldFBlcmlvZFN0YXJ0KHtcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBwcmlvclBlcmlvZEF0dHJpYnV0ZXM6IHByaW9yUGVyaW9kID8gcHJpb3JQZXJpb2QuYXR0cmlidXRlcyA6IG51bGwsXG4gICAgICBtcGRUeXBlOiBtcGRBdHRyaWJ1dGVzLnR5cGVcbiAgICB9KTtcbiAgICBwZXJpb2RzLnB1c2goe1xuICAgICAgbm9kZSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb25zOiBtcGRBdHRyaWJ1dGVzLmxvY2F0aW9ucyxcbiAgICBjb250ZW50U3RlZXJpbmdJbmZvOiBnZW5lcmF0ZUNvbnRlbnRTdGVlcmluZ0luZm9ybWF0aW9uKGNvbnRlbnRTdGVlcmluZ05vZGVzLCBldmVudEhhbmRsZXIpLFxuICAgIC8vIFRPRE86IFRoZXJlIGFyZSBvY2N1cmVuY2VzIHdoZXJlIHRoaXMgYHJlcHJlc2VudGF0aW9uSW5mb2AgYXJyYXkgY29udGFpbnMgdW5kZXNpcmVkXG4gICAgLy8gZHVwbGljYXRlcy4gVGhpcyBnZW5lcmFsbHkgb2NjdXJzIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIEJhc2VVUkwgbm9kZXMgdGhhdCBhcmVcbiAgICAvLyBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIE1QRCBub2RlLiBXaGVuIHdlIGF0dGVtcHQgdG8gcmVzb2x2ZSBVUkxzIGZyb20gYSBjb21iaW5hdGlvbiBvZiB0aGVcbiAgICAvLyBwYXJlbnQgQmFzZVVSTCBhbmQgYSBjaGlsZCBCYXNlVVJMLCBhbmQgdGhlIHZhbHVlIGRvZXMgbm90IHJlc29sdmUsXG4gICAgLy8gd2UgZW5kIHVwIHJldHVybmluZyB0aGUgY2hpbGQgQmFzZVVSTCBtdWx0aXBsZSB0aW1lcy5cbiAgICAvLyBXZSBuZWVkIHRvIGRldGVybWluZSBhIHdheSB0byByZW1vdmUgdGhlc2UgZHVwbGljYXRlcyBpbiBhIHNhZmUgd2F5LlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvbXBkLXBhcnNlci9wdWxsLzE3I2Rpc2N1c3Npb25fcjE2Mjc1MDUyN1xuICAgIHJlcHJlc2VudGF0aW9uSW5mbzogZmxhdHRlbihwZXJpb2RzLm1hcCh0b0FkYXB0YXRpb25TZXRzKG1wZEF0dHJpYnV0ZXMsIG1wZEJhc2VVcmxzKSkpLFxuICAgIGV2ZW50U3RyZWFtOiBmbGF0dGVuKHBlcmlvZHMubWFwKHRvRXZlbnRTdHJlYW0pKVxuICB9O1xufTtcblxuY29uc3Qgc3RyaW5nVG9NcGRYbWwgPSBtYW5pZmVzdFN0cmluZyA9PiB7XG4gIGlmIChtYW5pZmVzdFN0cmluZyA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkRBU0hfRU1QVFlfTUFOSUZFU1QpO1xuICB9XG5cbiAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICBsZXQgeG1sO1xuICBsZXQgbXBkO1xuXG4gIHRyeSB7XG4gICAgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYW5pZmVzdFN0cmluZywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIG1wZCA9IHhtbCAmJiB4bWwuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUgPT09ICdNUEQnID8geG1sLmRvY3VtZW50RWxlbWVudCA6IG51bGw7XG4gIH0gY2F0Y2ggKGUpIHsvLyBpZSAxMSB0aHJvd3Mgb24gaW52YWxpZCB4bWxcbiAgfVxuXG4gIGlmICghbXBkIHx8IG1wZCAmJiBtcGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuREFTSF9JTlZBTElEX1hNTCk7XG4gIH1cblxuICByZXR1cm4gbXBkO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIG1hbmlmZXN0IGZvciBhIFVUQ1RpbWluZyBub2RlLCByZXR1cm5pbmcgdGhlIG5vZGVzIGF0dHJpYnV0ZXMgaWYgZm91bmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbXBkXG4gKiAgICAgICAgWE1MIHN0cmluZyBvZiB0aGUgTVBEIG1hbmlmZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAqICAgICAgICAgQXR0cmlidXRlcyBvZiBVVENUaW1pbmcgbm9kZSBzcGVjaWZpZWQgaW4gdGhlIG1hbmlmZXN0LiBOdWxsIGlmIG5vbmUgZm91bmRcbiAqL1xuXG5jb25zdCBwYXJzZVVUQ1RpbWluZ1NjaGVtZSA9IG1wZCA9PiB7XG4gIGNvbnN0IFVUQ1RpbWluZ05vZGUgPSBmaW5kQ2hpbGRyZW4obXBkLCAnVVRDVGltaW5nJylbMF07XG5cbiAgaWYgKCFVVENUaW1pbmdOb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKFVUQ1RpbWluZ05vZGUpO1xuXG4gIHN3aXRjaCAoYXR0cmlidXRlcy5zY2hlbWVJZFVyaSkge1xuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaGVhZDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLWhlYWQ6MjAxMic6XG4gICAgICBhdHRyaWJ1dGVzLm1ldGhvZCA9ICdIRUFEJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC14c2RhdGU6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1pc286MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC14c2RhdGU6MjAxMic6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1pc286MjAxMic6XG4gICAgICBhdHRyaWJ1dGVzLm1ldGhvZCA9ICdHRVQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpkaXJlY3Q6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6ZGlyZWN0OjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnRElSRUNUJztcbiAgICAgIGF0dHJpYnV0ZXMudmFsdWUgPSBEYXRlLnBhcnNlKGF0dHJpYnV0ZXMudmFsdWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLW50cDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpudHA6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6c250cDoyMDE0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5VTlNVUFBPUlRFRF9VVENfVElNSU5HX1NDSEVNRSk7XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbmNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uO1xuLypcbiAqIEdpdmVuIGEgREFTSCBtYW5pZmVzdCBzdHJpbmcgYW5kIG9wdGlvbnMsIHBhcnNlcyB0aGUgREFTSCBtYW5pZmVzdCBpbnRvIGFuIG9iamVjdCBpbiB0aGVcbiAqIGZvcm0gb3V0cHV0ZWQgYnkgbTN1OC1wYXJzZXIgYW5kIGFjY2VwdGVkIGJ5IHZpZGVvanMvaHR0cC1zdHJlYW1pbmcuXG4gKlxuICogRm9yIGxpdmUgREFTSCBtYW5pZmVzdHMsIGlmIGBwcmV2aW91c01hbmlmZXN0YCBpcyBwcm92aWRlZCBpbiBvcHRpb25zLCB0aGVuIHRoZSBuZXdseVxuICogcGFyc2VkIERBU0ggbWFuaWZlc3Qgd2lsbCBoYXZlIGl0cyBtZWRpYSBzZXF1ZW5jZSBhbmQgZGlzY29udGludWl0eSBzZXF1ZW5jZSB2YWx1ZXNcbiAqIHVwZGF0ZWQgdG8gcmVmbGVjdCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHByaW9yIG1hbmlmZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFN0cmluZyAtIHRoZSBEQVNIIG1hbmlmZXN0IGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAtIGFueSBvcHRpb25zXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbWFuaWZlc3Qgb2JqZWN0XG4gKi9cblxuY29uc3QgcGFyc2UgPSAobWFuaWZlc3RTdHJpbmcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBwYXJzZWRNYW5pZmVzdEluZm8gPSBpbmhlcml0QXR0cmlidXRlcyhzdHJpbmdUb01wZFhtbChtYW5pZmVzdFN0cmluZyksIG9wdGlvbnMpO1xuICBjb25zdCBwbGF5bGlzdHMgPSB0b1BsYXlsaXN0cyhwYXJzZWRNYW5pZmVzdEluZm8ucmVwcmVzZW50YXRpb25JbmZvKTtcbiAgcmV0dXJuIHRvTTN1OCh7XG4gICAgZGFzaFBsYXlsaXN0czogcGxheWxpc3RzLFxuICAgIGxvY2F0aW9uczogcGFyc2VkTWFuaWZlc3RJbmZvLmxvY2F0aW9ucyxcbiAgICBjb250ZW50U3RlZXJpbmc6IHBhcnNlZE1hbmlmZXN0SW5mby5jb250ZW50U3RlZXJpbmdJbmZvLFxuICAgIHNpZHhNYXBwaW5nOiBvcHRpb25zLnNpZHhNYXBwaW5nLFxuICAgIHByZXZpb3VzTWFuaWZlc3Q6IG9wdGlvbnMucHJldmlvdXNNYW5pZmVzdCxcbiAgICBldmVudFN0cmVhbTogcGFyc2VkTWFuaWZlc3RJbmZvLmV2ZW50U3RyZWFtXG4gIH0pO1xufTtcbi8qKlxuICogUGFyc2VzIHRoZSBtYW5pZmVzdCBmb3IgYSBVVENUaW1pbmcgbm9kZSwgcmV0dXJuaW5nIHRoZSBub2RlcyBhdHRyaWJ1dGVzIGlmIGZvdW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hbmlmZXN0U3RyaW5nXG4gKiAgICAgICAgWE1MIHN0cmluZyBvZiB0aGUgTVBEIG1hbmlmZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAqICAgICAgICAgQXR0cmlidXRlcyBvZiBVVENUaW1pbmcgbm9kZSBzcGVjaWZpZWQgaW4gdGhlIG1hbmlmZXN0LiBOdWxsIGlmIG5vbmUgZm91bmRcbiAqL1xuXG5cbmNvbnN0IHBhcnNlVVRDVGltaW5nID0gbWFuaWZlc3RTdHJpbmcgPT4gcGFyc2VVVENUaW1pbmdTY2hlbWUoc3RyaW5nVG9NcGRYbWwobWFuaWZlc3RTdHJpbmcpKTtcblxuZXhwb3J0IHsgVkVSU0lPTiwgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCQxIGFzIGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QsIGdlbmVyYXRlU2lkeEtleSwgaW5oZXJpdEF0dHJpYnV0ZXMsIHBhcnNlLCBwYXJzZVVUQ1RpbWluZywgc3RyaW5nVG9NcGRYbWwsIHRvTTN1OCwgdG9QbGF5bGlzdHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpd-parser/dist/mpd-parser.es.js\n");

/***/ })

};
;